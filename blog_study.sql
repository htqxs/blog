/*
 Navicat Premium Data Transfer

 Source Server         : htz
 Source Server Type    : MySQL
 Source Server Version : 80019
 Source Host           : localhost:3306
 Source Schema         : blog_study

 Target Server Type    : MySQL
 Target Server Version : 80019
 File Encoding         : 65001

 Date: 26/02/2022 09:01:58
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_id` int(0) NOT NULL COMMENT '作者',
  `category_id` int(0) DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '内容',
  `create_time` datetime(0) DEFAULT NULL COMMENT '发表时间',
  `update_time` datetime(0) DEFAULT NULL COMMENT '更新时间',
  `is_top` tinyint(1) DEFAULT NULL COMMENT '是否置顶 0否 1是',
  `is_draft` tinyint(1) DEFAULT 0 COMMENT '是否为草稿 0否 1是',
  `is_delete` tinyint(1) DEFAULT 0 COMMENT '是否删除  0否 1是',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `category_id`(`category_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 74 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (40, 1, 13, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620140202321.jpg', '博客数据库', '## 数据库\n\n### 数据表\n\n| 表名             | 中文含义         | 说明                                                         |\n| ---------------- | ---------------- | ------------------------------------------------------------ |\n| tb_article       | 文章表           | 存放文章标题、内容、分类id、发布时间、置顶状态等             |\n| tb_category      | 分类表           | 存放分类名称、创建时间                                       |\n| tb_tag           | 标签表           | 存放标签名称、创建时间                                       |\n| tb_article_tag   | 文章标签关系表   | 文章与标签之类是多对多的关系，存放article_id、tag_id         |\n| tb_friend_link   | 友链表           | 存放友链信息，名称、地址、介绍、头像、创建时间等             |\n| tb_message       | 留言表           | 存放留言用户ip、地址、昵称、头像url、内容、时间等            |\n| tb_comment       | 评论表           | 存放评论用户id、评论文章id、内容、回复用户id、父评论id等     |\n| tb_operation_log | 操作日志表       | 记录管理也操作的日志，操作模块、类型、url、方法、描述、参数、请求方式、返回数据、用户id、昵称、操作ip、地址等 |\n| tb_menu          | 菜单表           | 存放菜单名、菜单路径、组件、菜单icon、父菜单id、时间、状态信息等 |\n| tb_resource      | 权限表           | 存放权限名、权限路径、请求方式、父权限id、时间、状态信息等   |\n| tb_role          | 角色表           | 存放角色名、角色描述、时间、状态信息等                       |\n| tb_role_menu     | 角色菜单关系表   | 菜单和角色是多对多的关系，存放role_id、menu_id               |\n| tb_role_resource | 角色权限关系表   | 角色和权限是多对多的关系，存放role_id、resource_id           |\n| tb_user_auth     | 用户登录信息表   | 存放用户个人信息id、用户名、密码、登录类型、ip、ip来源、时间等 |\n| tb_user_info     | 用户个人信息表   | 存放邮箱、昵称、头像url、用户简介、个人网站、时间、是否禁用等 |\n| tb_user_role     | 用户角色关系表   | 用户和角色是多对多的关系，存放user_id、role_id               |\n| tb_unique_view   | 网站单日访问量表 | 存放网站每天的访问量信息，如时间、访问量                     |\n\n### 表关系\n\n+ 文章和标签是多对多的关系，即一个文章可以含有多个标签，一个标签也可以对应多个文章。所以使用tb_article_tag 来维护这个关系。\n+ 菜单和角色是多对多的关系，一个菜单可以被多个角色访问，一个角色也可以访问多个菜单。\n+ 角色和权限是多对多的关系，一个角色可以有多个访问权限，一个权限也可以被多个角色访问。\n+ 用户和角色是多对多的关系，一个用户可以有多个角色，一个角色可以被多个用户拥有。\n\n**注意**\n + 用户的访问权限该博客是使用 SpringSecurity 来控制的，具体的见后序分析。\n + 用户对菜单的访问是在查询是用代码控制的。由用户id可以确定角色集合，再通过角色即可以确定访问的菜单集合\n\n### 建表语句\n\n```sql\n-- ----------------------------\n-- Table structure for tb_article 文章表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_article`;\nCREATE TABLE `tb_article`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_id` int(11) NOT NULL COMMENT \'作者\',\n  `category_id` int(11) DEFAULT NULL COMMENT \'文章分类\',\n  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'文章缩略图\',\n  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标题\',\n  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'内容\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'发表时间\',\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\n  `is_top` tinyint(1) DEFAULT NULL COMMENT \'是否置顶 0否 1是\',\n  `is_draft` tinyint(1) DEFAULT 0 COMMENT \'是否为草稿 0否 1是\',\n  `is_delete` tinyint(1) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `category_id`(`category_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_category 分类表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_category`;\nCREATE TABLE `tb_category`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'分类名\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_tag 标签表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_tag`;\nCREATE TABLE `tb_tag`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标签名\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_article_tag 文章标签关系表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_article_tag`;\nCREATE TABLE `tb_article_tag`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `article_id` int(11) NOT NULL COMMENT \'文章id\',\n  `tag_id` int(11) NOT NULL COMMENT \'标签id\',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,\n  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_friend_link 友链表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_friend_link`;\nCREATE TABLE `tb_friend_link`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接名\',\n  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接头像\',\n  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接地址\',\n  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接介绍\',\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `fk_friend_link_user`(`link_name`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_message 留言表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_message`;\nCREATE TABLE `tb_message`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\n  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户ip\',\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户地址\',\n  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'昵称\',\n  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'头像\',\n  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'留言内容\',\n  `time` tinyint(1) DEFAULT NULL COMMENT \'弹幕速度\',\n  `create_time` datetime(0) NOT NULL COMMENT \'发布时间\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 3435 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_comment 评论表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_comment`;\nCREATE TABLE `tb_comment`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_id` int(11) NOT NULL COMMENT \'评论用户Id\',\n  `article_id` int(11) DEFAULT NULL COMMENT \'评论文章id\',\n  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'评论内容\',\n  `create_time` datetime(0) NOT NULL COMMENT \'评论时间\',\n  `reply_id` int(11) DEFAULT NULL COMMENT \'回复用户id\',\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父评论id\',\n  `is_delete` tinyint(4) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `fk_comment_user`(`user_id`) USING BTREE,\n  INDEX `fk_comment_article`(`article_id`) USING BTREE,\n  INDEX `fk_comment_parent`(`parent_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 268 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_operation_log 操作日志表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_operation_log`;\nCREATE TABLE `tb_operation_log`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\n  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作模块\',\n  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作类型\',\n  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作url\',\n  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作方法\',\n  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作描述\',\n  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'请求参数\',\n  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\n  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'返回数据\',\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户昵称\',\n  `ip_addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作ip\',\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作地址\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_menu 菜单表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_menu`;\nCREATE TABLE `tb_menu`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单名\',\n  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单路径\',\n  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'组件\',\n  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单icon\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\n  `order_num` tinyint(4) DEFAULT NULL COMMENT \'排序\',\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父id\',\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否1是\',\n  `is_hidden` tinyint(1) DEFAULT NULL COMMENT \'是否隐藏  0否1是\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 203 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_resource 权限表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_resource`;\nCREATE TABLE `tb_resource`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'资源名\',\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'权限路径\',\n  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父权限id\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'修改时间\',\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否 1是\',\n  `is_anonymous` tinyint(4) DEFAULT NULL COMMENT \'是否匿名访问 0否 1是\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 250 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_role 角色表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_role`;\nCREATE TABLE `tb_role`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\n  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色名\',\n  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色描述\',\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用  0否 1是\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_role_menu 角色菜单关系表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_role_menu`;\nCREATE TABLE `tb_role_menu`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\n  `menu_id` int(11) DEFAULT NULL COMMENT \'菜单id\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1265 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_role_resource 角色权限关系表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_role_resource`;\nCREATE TABLE `tb_role_resource`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\n  `resource_id` int(11) DEFAULT NULL COMMENT \'权限id\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4181 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_user_auth 用户登录信息表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_user_auth`;\nCREATE TABLE `tb_user_auth`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_info_id` int(11) NOT NULL COMMENT \'用户信息id\',\n  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户名\',\n  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'密码\',\n  `login_type` tinyint(1) NOT NULL COMMENT \'登录类型\',\n  `ip_addr` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户登录ip\',\n  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'ip来源\',\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\n  `last_login_time` datetime(0) DEFAULT NULL COMMENT \'上次登录时间\',\n  PRIMARY KEY (`id`) USING BTREE,\n  UNIQUE INDEX `username`(`username`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 201 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_user_info 用户个人信息表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_user_info`;\nCREATE TABLE `tb_user_info`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'邮箱号\',\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户昵称\',\n  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT \'\' COMMENT \'用户头像\',\n  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户简介\',\n  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'个人网站\',\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\n  `is_disable` tinyint(1) DEFAULT 0 COMMENT \'是否禁用\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 212 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_user_role 用户角色关系表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_user_role`;\nCREATE TABLE `tb_user_role`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 221 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n\n\n-- ----------------------------\n-- Table structure for tb_unique_view 网站单日访问量表\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_unique_view`;\nCREATE TABLE `tb_unique_view`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `create_time` datetime(0) NOT NULL COMMENT \'时间\',\n  `views_count` int(11) NOT NULL COMMENT \'访问量\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 225 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\n```', '2021-05-04 22:56:46', NULL, 1, 0, 0);
INSERT INTO `tb_article` VALUES (42, 1, 13, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620215219268.jpg', '博客权限控制 SpringSecurity', '## SpringScurity 权限控制\n\n### SpringSecurity 配置类 config.WebSecurityConfig\n\n```java\n/**\n * Security配置类\n */\n@Configuration\n// 开启security自定义配置\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\n    @Autowired\n    private AccessDeniedHandlerImpl accessDeniedHandler;\n    @Autowired\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\n    @Autowired\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\n    @Autowired\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\n\n    // 自定义登录校验接口\n    @Autowired\n    private UserDetailsServiceImpl userDetailsService;\n\n    @Bean\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\n        return new FilterInvocationSecurityMetadataSourceImpl();\n    }\n\n    @Bean\n    public AccessDecisionManager accessDecisionManager() {\n        return new AccessDecisionManagerImpl();\n    }\n\n    @Bean\n    public SessionRegistry sessionRegistry() {\n        return new SessionRegistryImpl();\n    }\n\n    // 防用户重复登录\n    @Bean\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\n        return new HttpSessionEventPublisher();\n    }\n\n    /**\n     * 密码加密\n     */\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        // 指定 userDetailsService\n        auth.userDetailsService(userDetailsService)\n                // 密码编码器\n                .passwordEncoder(passwordEncoder());\n    }\n\n    /**\n     * 配置权限\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // 配置登录注销路径\n        http.formLogin()\n                .loginProcessingUrl(\"/login\")\n                // 登录成功处理\n                .successHandler(authenticationSuccessHandler)\n                // 登陆失败处理\n                .failureHandler(authenticationFailHandler).and()\n                .logout().logoutUrl(\"/logout\")\n                // 退出登录处理\n                .logoutSuccessHandler(logoutSuccessHandler);\n\n        // 配置路由权限信息\n        http.authorizeRequests()\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\n                        // 设置自定义的 AccessDecisionManager\n                        fsi.setAccessDecisionManager(accessDecisionManager());\n                        return fsi;\n                    }\n                })\n                .anyRequest().permitAll()\n                .and()\n                // 关闭跨站请求防护\n                .csrf().disable().exceptionHandling()\n                // 未登录处理\n                .authenticationEntryPoint(authenticationEntryPoint)\n                // 权限不足处理\n                .accessDeniedHandler(accessDeniedHandler).and()\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\n                .headers().frameOptions().disable()\n                .and()\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\n                .sessionManagement()\n                .maximumSessions(20)\n                // sessionRegistry 用来统计在线用户\n                .sessionRegistry(sessionRegistry());\n    }\n}\n```\n\n### 用户登录信息，UserDetails 的实现类 UserInfoDTO\n\n```java\n/*\n * 用户登录信息\n */\n@Data\n@Builder\npublic class UserInfoDTO implements UserDetails {\n    /**\n     * 用户账号id\n     */\n    private Integer id;\n\n    /**\n     * 用户信息id\n     */\n    private Integer userInfoId;\n\n    /**\n     * 邮箱号\n     */\n    private String email;\n\n    /**\n     * 登录方式\n     */\n    private Integer loginType;\n\n    /**\n     * 用户名\n     */\n    private String username;\n\n    /**\n     * 密码\n     */\n    private String password;\n\n    /**\n     * 用户角色\n     */\n    private List<String> roleList;\n\n    /**\n     * 用户昵称\n     */\n    private String nickname;\n\n    /**\n     * 用户头像\n     */\n    private String avatar;\n\n    /**\n     * 用户简介\n     */\n    private String intro;\n\n    /**\n     * 个人网站\n     */\n    private String webSite;\n\n    /**\n     * 点赞文章集合\n     */\n    private Set<Integer> articleLikeSet;\n\n    /**\n     * 点赞评论集合\n     */\n    private Set<Integer> commentLikeSet;\n\n    /**\n     * 用户登录ip\n     */\n    private String ipAddr;\n\n    /**\n     * ip来源\n     */\n    private String ipSource;\n\n    /**\n     * 浏览器\n     */\n    private String browser;\n\n    /**\n     * 操作系统\n     */\n    private String os;\n\n    /**\n     * 最近登录时间\n     */\n    private Date lastLoginTime;\n\n    /**\n     * 获取角色集合\n     * @return\n     */\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return this.username;\n    }\n\n    /**\n     * 账户是非过期的\n     */\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    /**\n     * 用户账号是非被锁定的\n     */\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    /**\n     * 用户密码是非过期的\n     */\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    /**\n     * 用户是否可用\n     */\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n### 自定义登录校验 UserDetailsServiceImpl\n\n```java\n/**\n * 自定义 UserDetailsService，将用户信息和权限注入进来\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n    @Autowired\n    private UserAuthDao userAuthDao;\n    @Autowired\n    private UserInfoDao userInfoDao;\n    @Autowired\n    private RoleDao roleDao;\n    @Autowired\n    private RedisTemplate redisTemplate;\n    @Resource\n    private HttpServletRequest request;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) {\n        if (StringUtils.isBlank(username)) {\n            throw new ServeException(\"用户名不能为空！\");\n        }\n        // 查询账号是否存在\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\n                .eq(UserAuth::getUsername, username));\n        if (Objects.isNull(user)) {\n            throw new ServeException(\"用户名不存在!\");\n        }\n        // 查询账号信息\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\n                .eq(UserInfo::getId, user.getUserInfoId()));\n        // 查询账号对应的角色集合\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\n        // 查询账号点赞信息\n        // 点赞的文章集合\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\n        // 点赞的评论集合\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\n    }\n}\n\n------------------------------------------------------------------------\n/**\n * 用户工具类\n */\npublic class UserUtil {\n\n    /**\n     * 获取当前登录用户\n     * @return 用户登录信息\n     */\n    public static UserInfoDTO getLoginUser() {\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    }\n\n    /**\n     * 封装用户登录信息\n     *\n     * @param user           用户账号\n     * @param userInfo       用户信息\n     * @param articleLikeSet 点赞文章id集合\n     * @param commentLikeSet 点赞评论id集合\n     * @param request        请求\n     * @return 用户登录信息\n     */\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\n        // 获取登录信息\n        String ipAddr = IpUtil.getIpAddr(request);\n        String ipSource = IpUtil.getIpSource(ipAddr);\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\"User-Agent\"));\n        // 封装权限集合\n        return UserInfoDTO.builder()\n                .id(user.getId())\n                .loginType(user.getLoginType())\n                .userInfoId(userInfo.getId())\n                .username(user.getUsername())\n                .password(user.getPassword())\n                .email(userInfo.getEmail())\n                .roleList(roleList)\n                .nickname(userInfo.getNickname())\n                .avatar(userInfo.getAvatar())\n                .intro(userInfo.getIntro())\n                .webSite(userInfo.getWebSite())\n                .articleLikeSet(articleLikeSet)\n                .commentLikeSet(commentLikeSet)\n                .ipAddr(ipAddr)\n                .ipSource(ipSource)\n                .browser(userAgent.getBrowser().getName())\n                .os(userAgent.getOperatingSystem().getName())\n                .lastLoginTime(new Date())\n                .build();\n    }\n}\n```\n\n### 登录成功处理器 handler.AuthenticationSuccessHandlerImpl\n\n```java\n/**\n * 登录成功处理，更新用户信息，返回登录用户信息\n */\n@Component\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\n    @Autowired\n    private UserAuthDao userAuthDao;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\n        // 更新用户ip，最近登录时间\n        updateUserInfo();\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\n        httpServletResponse.setContentType(\"application/json;charset=UTF-8\");\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \"登录成功!\", userLoginDTO)));\n    }\n\n    // 更新用户信息\n    @Async\n    public void updateUserInfo() {\n        UserAuth userAuth = UserAuth.builder()\n                .id(UserUtil.getLoginUser().getId())\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\n                .ipSource(UserUtil.getLoginUser().getIpSource())\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\n                .build();\n        userAuthDao.updateById(userAuth);\n    }\n}\n```\n\n### 登录失败处理器 handler.AuthenticationFailHandlerImpl\n\n```java\n/**\n * 登录失败处理，返回错误信息\n */\n@Component\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\n        httpServletResponse.setContentType(\"application/json;charset=UTF-8\");\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\n    }\n}\n```\n\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\n\n```java\n/**\n * 注销处理，返回成功信息\n */\n@Component\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\n        httpServletResponse.setContentType(\"application/json;charset=UTF-8\");\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\"注销成功\")));\n    }\n}\n```\n\n### 权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl\n\n```java\n/**\n * 用户权限不足，返回没有操作权限的错误信息\n */\n@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\n\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\n        httpServletResponse.setContentType(\"application/json;charset=utf-8\");\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \"没有操作权限\")));\n    }\n}\n```\n\n### 用户未登录处理 hanlder.AuthenticationEntryPointImpl\n\n```java\n/**\n * 用户未登录处理，返回未登录的提示信息\n */\n@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\n        httpServletResponse.setContentType(\"application/json;charset=utf-8\");\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \"请登录\")));\n    }\n}\n```\n\n### 自定义的 FilterInvocationSecurityMetadataSource\n\n```java\n/**\n * 用来储存请求与权限的对应关系\n */\n@Component\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\n    /**\n     * 接口角色列表\n     */\n    private static List<UrlRoleDTO> urlRoleList;\n\n    @Autowired\n    private RoleDao roleDao;\n\n    /**\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\n     */\n    @PostConstruct\n    private void loadDataSource() {\n        // 查询的是资源非匿名的集合\n        urlRoleList = roleDao.listUrlRoles();\n    }\n\n    /**\n     * 清空接口角色信息\n     */\n    public void clearDataSource() {\n        urlRoleList = null;\n    }\n\n    /**\n     * 返回请求的资源需要的角色集合\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\n     */\n    @Override\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\n        // 修改接口角色关系后重新加载\n        if (CollectionUtils.isEmpty(urlRoleList)) {\n            this.loadDataSource();\n        }\n        FilterInvocation fi = (FilterInvocation) object;\n        // 获取用户请求方式\n        String method = fi.getRequest().getMethod();\n        // 获取用户请求Url\n        String url = fi.getRequest().getRequestURI();\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\n        // 获取接口角色信息，若无对应角色则禁止\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\n            // 如果 url、method都相同\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\n                List<String> roleList = urlRoleDTO.getRoleList();\n                if (CollectionUtils.isEmpty(roleList)) {\n                    return SecurityConfig.createList(\"disable\");\n                }\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return FilterInvocation.class.isAssignableFrom(aClass);\n    }\n}\n\n-------------------------------------------------------------------------------------------\n/**\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\n * 这里的资源由 url 和 requestMethod 确定\n */\n@Data\npublic class UrlRoleDTO {\n\n    /**\n     * 资源id\n     */\n    private Integer id;\n\n    /**\n     * 路径\n     */\n    private String url;\n\n    /**\n     * 请求方式\n     */\n    private String requestMethod;\n\n    /**\n     * 角色名\n     */\n    private List<String> roleList;\n\n    /**\n     * 是否匿名\n     */\n    private Integer isAnonymous;\n}\n```\n\n### 自定决策器 AccessDecisionManagerImpl\n\n```java\n/**\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\n */\n@Component\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\n\n    /**\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\n     *\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\n     * @param configAttributes configAttributes是本次访问需要的权限\n     */\n    @Override\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\n        // 获取用户权限列表\n        List<String> permissionList = authentication.getAuthorities()\n                .stream()\n                .map(GrantedAuthority::getAuthority)\n                .collect(Collectors.toList());\n        // 判断该用户是否用户本次访问需要的权限\n        for (ConfigAttribute item : configAttributes) {\n            if (permissionList.contains(item.getAttribute())) {\n                return;\n            }\n        }\n        throw new AccessDeniedException(\"没有操作权限\");\n    }\n\n    /**\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\n     */\n    @Override\n    public boolean supports(ConfigAttribute configAttribute) {\n        return true;\n    }\n\n    /**\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\n     */\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n}\n```\n', '2021-05-05 19:47:02', '2021-05-05 19:52:39', 1, 0, 0);
INSERT INTO `tb_article` VALUES (43, 1, 13, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620215839705.jpg', '博客中Redis和RabbitMQ的使用场景', '## Redis 使用场景\n\n### Redis 配置类\n\n```java\npackage top.bravecoder.blog.config;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n/**\n * redis配置\n * @author zhangzhi\n */\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(factory);\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL,\n                JsonTypeInfo.As.PROPERTY);\n        jackson2JsonRedisSerializer.setObjectMapper(mapper);\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n        // key采用String的序列化方式\n        redisTemplate.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n```\n\n### Redis常量\n\n```java\npackage top.bravecoder.blog.constant;\n\n/**\n * redis常量\n */\npublic class RedisPrefixConst {\n\n    /**\n     * 验证码过期时间\n     */\n    public static final long CODE_EXPIRE_TIME = 15 * 60 * 1000;\n\n    /**\n     * 验证码\n     */\n    public static final String CODE_KEY = \"code_\";\n\n    /**\n     * 博客总浏览量\n     */\n    public static final String BLOG_VIEWS_COUNT = \"blog_views_count\";\n\n    /**\n     * 文章浏览量\n     */\n    public static final String ARTICLE_VIEWS_COUNT = \"article_views_count\";\n\n    /**\n     * 文章点赞量\n     */\n    public static final String ARTICLE_LIKE_COUNT = \"article_like_count\";\n\n    /**\n     * 用户点赞文章\n     */\n    public static final String ARTICLE_USER_LIKE = \"article_user_like\";\n\n    /**\n     * 评论点赞量\n     */\n    public static final String COMMENT_LIKE_COUNT = \"comment_like_count\";\n\n    /**\n     * 用户点赞评论\n     */\n    public static final String COMMENT_USER_LIKE = \"comment_user_like\";\n\n    /**\n     * 关于我信息\n     */\n    public static final String ABOUT = \"about\";\n\n    /**\n     * 公告\n     */\n    public static final String NOTICE = \"notice\";\n\n    /**\n     * ip集合\n     */\n    public static final String IP_SET = \"ip_set\";\n}\n```\n\n+ 用户注册时，存放验证码，**string**\n\n  ```java\n  // 将验证码存入redis，设置过期时间为15分钟\n  redisTemplate.boundValueOps(CODE_KEY + username).set(code);\n  redisTemplate.expire(CODE_KEY + username, CODE_EXPIRE_TIME, TimeUnit.MILLISECONDS);\n  ```\n\n+ 存放博客的总浏览量，**string**\n\n   ```java\n   // 判断当前ip是否访问，增加访问量\n    String ipAddr = IpUtil.getIpAddr(request);\n    if (!ipAddr.equals(ip)) {\n      session.setAttribute(\"ip\", ipAddr);\n      // 博客总浏览量 +1\n      redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\n    }\n   ```\n\n+ 存放文章的浏览量，**hash**\n\n  ```java\n  // 判断是否第一次访问，增加浏览量\n  Set<Integer> set = (Set<Integer>) session.getAttribute(\"articleSet\");\n  if (Objects.isNull(set)) {\n      set = new HashSet<>();\n  }\n  if (!set.contains(articleId)) {\n      set.add(articleId);\n      session.setAttribute(\"articleSet\", set);\n      // 浏览量+1\n      redisTemplate.boundHashOps(ARTICLE_VIEWS_COUNT).increment(articleId.toString(), 1);\n  }\n  ```\n\n+ 存放所有文章各自的点赞量和用户点赞的文章集合，**hash**\n\n```java\n public void saveArticleLike(Integer articleId) {\n        // 查询当前用户点赞过的文章id集合\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\n        // 第一次点赞则创建\n        if (CollectionUtils.isEmpty(articleLikeSet)) {\n            articleLikeSet = new HashSet<>();\n        }\n        // 判断是否点赞\n        if (articleLikeSet.contains(articleId)) {\n            // 点过赞则删除文章id\n            articleLikeSet.remove(articleId);\n            // 文章点赞量-1\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), -1);\n        } else {\n            // 未点赞则增加文章id\n            articleLikeSet.add(articleId);\n            // 文章点赞量+1\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), 1);\n        }\n        // 保存用户的点赞记录\n  redisTemplate.boundHashOps(ARTICLE_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), articleLikeSet);\n    }\n```\n\n+ 存放所有评论各自的点赞量和用户点赞的评论集合，与上面类似，**hash**\n\n```java\n public void saveCommentLike(Integer commentId) {\n        // 查询当前用户点赞过的评论id集合\n        HashSet<Integer> commentLikeSet = (HashSet<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\n        // 第一次点赞则创建\n        if (CollectionUtils.isEmpty(commentLikeSet)) {\n            commentLikeSet = new HashSet<>();\n        }\n        // 判断是否点赞\n        if (commentLikeSet.contains(commentId)) {\n            // 点过赞则删除评论id\n            commentLikeSet.remove(commentId);\n            // 评论点赞量-1\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), -1);\n        } else {\n            // 未点赞则增加评论id\n            commentLikeSet.add(commentId);\n            // 评论点赞量+1\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), 1);\n        }\n        // 保存点赞记录\n  redisTemplate.boundHashOps(COMMENT_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), commentLikeSet);\n    }\n```\n\n+ 存放关于我、公告信息，**string**\n\n  ```java\n  public void updateAbout(String aboutContent) {\n      redisTemplate.boundValueOps(ABOUT).set(aboutContent);\n  }\n\n  public void updateNotice(String notice) {\n      redisTemplate.boundValueOps(NOTICE).set(notice);\n  }\n\n  ```\n\n+ 存放ip，统计每日用户量，**set**\n\n  暂时存储每天的ip集合，定时把当天的访问量存储到数据库，定时删除\n\n  ```java\n\n  /**\n   * request监听\n   */\n  @Component\n  public class ServletRequestListenerImpl implements ServletRequestListener {\n      @Autowired\n      private RedisTemplate redisTemplate;\n\n      @Override\n      public void requestInitialized(ServletRequestEvent sre) {\n          HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\n          HttpSession session = request.getSession();\n          String ip = (String) session.getAttribute(\"ip\");\n          // 判断当前ip是否访问，增加访问量\n          String ipAddr = IpUtil.getIpAddr(request);\n          if (!ipAddr.equals(ip)) {\n              session.setAttribute(\"ip\", ipAddr);\n              redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\n          }\n          // 将ip存入redis，统计每日用户量\n          redisTemplate.boundSetOps(IP_SET).add(ipAddr);\n      }\n\n      // 每天凌晨0点1分执行一次\n      @Scheduled(cron = \" 0 1 0 * * ?\")\n      private void clear() {\n          // 清空redis中的ip\n          redisTemplate.delete(IP_SET);\n      }\n  }\n\n  -----------------------------------------------------------\n  @Service\n  public class UniqueViewServiceImpl extends ServiceImpl<UniqueViewDao, UniqueView> implements UniqueViewService {\n      @Autowired\n      private RedisTemplate redisTemplate;\n      @Autowired\n      private UniqueViewDao uniqueViewDao;\n\n      // 每天 0 点执行一次\n      @Scheduled(cron = \" 0 0 0 * * ?\")\n      @Override\n      public void saveUniqueView() {\n          // 获取每天用户量\n          Long count = redisTemplate.boundSetOps(\"ip_set\").size();\n          // 获取昨天日期插入数据\n          UniqueView uniqueView = UniqueView.builder()\n                  .createTime(DateUtil.getSomeDay(new Date(), -1))\n                  .viewsCount(Objects.nonNull(count) ? count.intValue() : 0).build();\n          uniqueViewDao.insert(uniqueView);\n      }\n  }\n  ```\n\n## RabbitMQ使用场景\n\n### MQ常量类\n\n```java\n/**\n * MQ常量\n */\npublic class MQPrefixConst {\n\n    /**\n     * email交换机\n     */\n    public static final String EMAIL_EXCHANGE = \"send\";\n\n    /**\n     * 邮件队列\n     */\n    public static final String EMAIL_QUEUE = \"email\";\n}\n```\n\n### RabbitMQ配置类\n\n```java\n/**\n * Rabbitmq配置类\n */\n@Configuration\npublic class RabbitConfig {\n\n    // 创建队列\n    @Bean\n    public Queue emailQueue() {\n        return new Queue(MQPrefixConst.EMAIL_QUEUE, true);\n    }\n\n    // 创建交换机\n    @Bean\n    public FanoutExchange emailExchange() {\n        return new FanoutExchange(MQPrefixConst.EMAIL_EXCHANGE, true, false);\n    }\n\n    // 把队列和交换机绑定在一起\n    @Bean\n    public Binding bindingEmailDirect() {\n        return BindingBuilder.bind(emailQueue()).to(emailExchange());\n    }\n}\n```\n\n### 消费者 EmailReceiver\n\n```java\n/**\n * 监听EMAIL_QUEUE，发送邮件\n */\n@Component\n@RabbitListener(queues = MQPrefixConst.EMAIL_QUEUE)\npublic class EmailReceiver {\n    /**\n     * 邮箱号\n     */\n    @Value(\"${spring.mail.username}\")\n    private String email;\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @RabbitHandler\n    public void process(byte[] data) {\n        EmailDTO emailDTO = JSON.parseObject(new String(data), EmailDTO.class);\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(email);\n        message.setTo(emailDTO.getEmail());\n        message.setSubject(emailDTO.getSubject());\n        message.setText(emailDTO.getContent());\n        javaMailSender.send(message);\n    }\n}\n```\n\n### 场景一\n\n用户注册时，对邮箱发送验证码\n\n```java\nrabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \"*\", new Message(JSON.toJSONBytes(emailDTO), \n                new MessageProperties()));\n```\n\n### 场景二\n\n用户的评论收到回复时，发邮件进行通知\n\n```java\n/**\n * 通知评论用户\n */\n@Async\npublic void notice(CommentVO commentVO) {\n    // 判断是回复用户还是评论作者\n    Integer userId = Objects.nonNull(commentVO.getReplyId()) ? commentVO.getReplyId() : BLOGGER_ID;\n    // 查询邮箱号\n    String email = userInfoDao.selectById(userId).getEmail();\n    if (StringUtils.isNotBlank(email)) {\n        // 判断页面路径\n        String url = Objects.nonNull(commentVO.getArticleId()) ? URL + ARTICLE_PATH + commentVO.getArticleId() : URL + LINK_PATH;\n        // 发送消息\n        EmailDTO emailDTO = EmailDTO.builder()\n            .email(email)\n            .subject(\"评论提醒\")\n            .content(\"您收到了一条新的回复，请前往\" + url + \"\\n页面查看\")\n            .build();\n        rabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \"*\", \n                       new Message(JSON.toJSONBytes(emailDTO), new MessageProperties()));\n    }\n}\n```\n\n', '2021-05-05 19:57:23', NULL, 1, 0, 0);
INSERT INTO `tb_article` VALUES (44, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620458051532.jpeg', '二分刷题记录', '## 1、最大值最小化\n\n### [POJ-3273 Monthly Expense](http://poj.org/problem?id=3273)\n\n**Description**\n\nFarmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ *moneyi* ≤ 10,000) that he will need to spend each day over the next *N* (1 ≤ *N* ≤ 100,000) days.\n\nFJ wants to create a budget for a sequential set of exactly *M* (1 ≤ *M* ≤ *N*) fiscal periods called \"fajomonths\". Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth.\n\nFJ\'s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit.\n\n**Input**\n\nLine 1: Two space-separated integers: *N* and *M*\nLines 2..*N*+1: Line *i*+1 contains the number of dollars Farmer John spends on the *i*th day\n\n**Output**\n\nLine 1: The smallest possible monthly limit Farmer John can afford to live with.\n\n**Sample Input**\n\n```c++\n7 5\n100\n400\n300\n100\n500\n101\n400\n```\n\n**Sample Output**\n\n```c++\n500\n```\n\n**题解：**\n\n题目大意：共N天，已知每天的花费，把这N天分成连续的m组，在求得各组的花费和以后，取出其中的最大值。问如何使这个最大值最小。\n\n分析：最大值最小化\n\n+ N天中最大的花费为left，N天的花费和为right\n+ 二分，判断mid值是否符合分成m组的条件（具体细节见代码注释）\n\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 100005;\nint n, m; // 分m段，则要划出m-1条线\nint money[maxn];\n\nint check(int k) { // k是所有段中的最大值，希望其最小\n	int sum = 0, num = 0;\n	for (int i = 0; i < n; i++) {\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\n		if (sum + money[i] > k) {  \n			sum = money[i];\n			num++;\n			printf(\"%d %d\\n\", num, sum);\n		} else {\n			sum += money[i];\n		}\n	} \n	if (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\n		return 0;\n	}\n	return 1;\n}\n\nint main() {\n	while (~scanf(\"%d%d\", &n, &m)) {\n		int l = 0, r = 0, ans = 0;\n		for (int i = 0; i < n; i++) {\n			scanf(\"%d\", &money[i]);\n			l = max(l, money[i]);\n			r += money[i];\n		}\n		while (l <= r) {\n			int mid = (l + r) >> 1;\n			if (check(mid)) { // 符合，往左走\n				ans = mid;\n				r = mid - 1;\n			} else { // 不符合，往右走\n				l = mid + 1;\n			}\n		}\n		printf(\"%d\\n\", ans);\n	}\n	return 0;\n} \n```\n\n## 2、最小值最大化\n\n### [2018安徽省赛 J-数列分段](https://acm.webturing.com/problem.php?cid=1323&pid=9&langmask=262132&puzzle_mask=0)\n\n题目描述： 有n个整数，分成m段。使每一段的和的**最小值尽可能的大**。\n\n**输入**\n\n 第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有两个整数n，m，接下来一行是n个整数。其中T<=50,n,m<1e5 。\n\n**输出**\n\n 尽可能的大的每一段的和的最小值。\n\n**样例输入**\n\n```c++\n1\n5 3\n4 5 4 5 1\n```\n\n**样例输出**\n\n```c++\n4\n```\n\n**题解：**\n\n最小值最大化：check时，sum如果大于等于k立即划分为一段，num++，如果num大于等于m的，说明该k值一定满足。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nint T, n, m;\nint a[maxn];\n\nint check(int k) {\n	int num = 0, sum = 0;\n	for (int i = 1; i <= n; i++) {\n		if (sum + a[i] >= k) {\n			num++;\n			sum = 0;\n		} else {\n			sum += a[i];\n		}\n	} \n	if (num >= m) {\n		return 1;\n	}\n	return 0;\n}\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		int r = 0;\n		int l = 0x3f3f3f3f;\n		int ans = 0;\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n			r += a[i];\n			l = min(l, a[i]);\n		}\n		while (l <= r) {\n			int mid = (l + r) >> 1;\n			if (check(mid)) {\n				ans = mid;\n				l = mid + 1;\n			} else {\n				r = mid - 1;\n			}\n		}\n		printf(\"%d\\n\", ans);\n	}\n	return 0;\n}\n```\n\n## 3、基本思想\n\n### [POJ-3122 Pie](http://poj.org/problem?id=3122)\n\n**Description**\n\n我有N个不同口味、不同大小的派。\n有F个朋友会来参加我的派对，每个人会拿到一块派（不能由几个派的小块拼成；可以是一整个派）。\n所有人拿到的派必须是同样大小的（但不需要是同样形状的）。\n当然，我也要给自己留一块，而这一块也要和其他人的同样大小。\n每个派都是一个高为1，半径不等的圆柱体。\n请问我们每个人拿到的派最大是多少？\n\n**Input**\n\n第一行输入一个T代表组数。\n随后T组包含两个正整数N和F，1 ≤ N, F ≤ 10000和N个1到10000之间的整数，表示派的数量，朋友的数量和每个派的半径。\n\n**Output**\n\n输出每个人能得到的最大的派的体积，精确到小数点后四位。\n\n**Sample Input**\n\n3\n3 3\n4 3 3\n1 24\n5\n10 5\n1 4 2 3 4 5 6 5 4 2\n\n**Sample Output**\n\n25.1327\n3.1416\n50.2655\n\n#### 代码\n\n**思路** 找出最大的派的面积，最小则为0，进行二分，判断每次的中间值是否可行，以缩小范围\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\ndouble pie[10001];\nint main()\n{\n	int t, n, f;\n	\n	scanf(\"%d\", &t);\n	for (int i = 0; i < t; i++)\n	{\n		scanf(\"%d%d\", &n, &f);\n		f++;\n		\n		double l = 0, r = 0;\n		for (int j = 0; j < n; j++)\n		{\n			scanf(\"%lf\", &pie[j]);\n			pie[j] = pie[j]*pie[j];\n			if (r < pie[j])\n				r = pie[j];\n		}\n		double mid;\n		while (r - l > 1e-6)\n		{\n			mid = (l + r) / 2;\n			int cnt = 0;\n			bool flag = false;\n			for (int j = 0; j < n; j++)\n			{\n				cnt += pie[j] / mid;\n				if (cnt >= f)\n				{\n					flag = true;\n					break;\n				}\n			}\n			if (flag)\n				l = mid;\n			else\n				r = mid;\n		}\n		printf(\"%.4lf\\n\", l*PI);\n	}\n	return 0;\n} \n```\n', '2021-05-08 15:14:24', '2021-05-08 15:18:17', 0, 0, 0);
INSERT INTO `tb_article` VALUES (46, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620460201284.jpg', '2021安徽省程序设计网络赛题解', '## [最多约数](https://acm.webturing.com/problem.php?cid=1643&pid=0&langmask=262141&puzzle_mask=0)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2000000;\nint dp[maxn]; // dp[i] 存储 i 的约数\n\nint main() {\n	int a, b;\n	cin>>a>>b;\n	int res = 0;\n	for (int i = a; i <= b; i++) {\n        // 以 i 的倍数进行增加\n		for (int j = i; j <= b; j += i) {\n			dp[j]++; // dp[j]++是因为，i 此时是 j 的约数，j = n*i;\n		}\n		res = max(res, dp[i]);\n	}\n	cout<<res<<endl;\n	return 0;\n} \n```\n\n## [会场安排问题](https://acm.webturing.com/problem.php?cid=1643&pid=1&langmask=262141&puzzle_mask=0)\n\n每个活动都有一个开始时间和一个结束时间，所有需要的会议数是活动之间重叠的次数 + 1\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nconst int maxn = 1000001;\n\ntypedef struct node {\n	int start;\n	int end;\n} Act;\n\nbool cmp(Act a, Act b) {\n	return a.start < b.start;\n}\n\n// 活动数组 \nAct acts[maxn];\nint k;\nint main()\n{\n	cin>>k;\n	for (int i = 0; i < k; i++) {\n		cin>>acts[i].start>>acts[i].end;\n	}\n	// 把所有活动按开始时间升序进行排列 \n	sort(acts, acts + k, cmp);\n	int max = 0;\n	for (int i = 1; i < k; i++) {\n		int count = 1;\n		for (int j = i - 1; j >= 0; j--) {\n			// 如果两个活动时间有重叠，则需要新开会议 \n			if (acts[i].start < acts[j].end) {\n				count++;\n			}\n		}\n		if (count > max) {\n			max = count;\n		}\n	}\n	cout<<max<<endl;\n	return 0;\n}\n\n----------------------------------------------------------------------------------\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 1e7 + 3;\n\nint cnt[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int k;\n    cin >> k;\n    for (int i = 1; i <= k; i++) {\n        int l, r;\n        cin >> l >> r;\n        cnt[l]++;\n        cnt[r]--;\n    }\n    int ans = 0;\n    for (int i = 1; i < N; i++) {\n    	cnt[i] += cnt[i - 1];\n		ans = max(ans, cnt[i]);\n	}\n    cout << ans << endl;\n    return 0;\n}\n```\n\n## [数位的幂](https://acm.webturing.com/problem.php?cid=1643&pid=2&langmask=262141&puzzle_mask=0)\n\n快速幂 + 模运算\n\n1. (a + b) % p = (a % p + b % p) % p （1）\n2. (a - b) % p = (a % p - b % p ) % p （2）\n3. **(a \\* b) % p = (a % p * b % p) % p （3）**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\n\nlong long fastPower(long long base, long long power) {\n    long long result = 1;\n    while (power > 0) {\n        if (power & 1) {\n            result = result * base % P;\n        }\n        power >>= 1;\n        base = (base * base) % P;\n    }\n    return result;\n}\n\n\nint main() {\n	string s;\n	cin>>s;\n	long long res = 1;\n	for (int i = 0; i < s.size(); i++) {\n		long long x = s[i] - \'0\';\n		res *= fastPower(x, i + 1);\n		res %= P;\n	}\n	cout<<res<<endl;\n    return 0;\n}\n\n--------------------------------------------------------------------------------\n// 优化版本\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst int maxn = 1000001;\n\nll quickpw(ll a, ll b) {\n    ll ans = 1, base = a;\n    while (b != 0) {\n        if (b & 1 != 0)\n            ans = ans * base % mod;\n        base = base * base % mod;\n        b >>= 1;\n    }\n    return ans % mod;\n}\n\nchar c[maxn];\n\nint main() {\n    while (~scanf(\"%s\", c)) {\n        ll a[11];\n        ll ans = 1;\n        memset(a, 0, sizeof(a));\n        int len = strlen(c);\n        for (int i = 0; i < len; i++) {\n            a[c[i] - \'0\'] += (i + 1);\n        }\n        for (int i = 1; i < 10; i++) {\n            if (a[i]) {\n                ans = ans * quickpw(i, a[i]) % mod;\n            }\n        }\n        cout << ans % mod << endl;\n    }\n    return 0;\n}\n```\n\n## [Search - Allocation](https://acm.webturing.com/problem.php?cid=1643&pid=3&langmask=262141&puzzle_mask=0)\n\n二分，最大值最小化\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\nint n, m; // 分m段，则要划出m-1条线\nint money[maxn];\n\nint check(int k) { // k是所有段中的最大值，希望其最小\n	int sum = 0, num = 0;\n	for (int i = 0; i < n; i++) {\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\n		if (sum + money[i] > k) {  \n			sum = money[i];\n			num++; \n		} else {\n			sum += money[i];\n		}\n	} \n	if (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\n		return 0;\n	}\n	return 1;\n}\n\nint main() {\n	cin>>n>>m;\n    // l，r 为左右边界\n	int l = 0, r = 0, ans = 0;\n	for (int i = 0; i < n; i++) {\n	    cin>>money[i];\n		l = max(l, money[i]);\n		r += money[i];\n	}\n	while (l <= r) {\n		int mid = (l + r) >> 1;\n		if (check(mid)) { // 符合，往左走\n			ans = mid;\n			r = mid - 1;  \n		} else { // 不符合，往右走\n			l = mid + 1;\n		}\n	}\n	cout<<ans<<endl;\n	return 0;\n} \n```\n\n## [火柴](https://acm.webturing.com/problem.php?cid=1643&pid=4&langmask=262141&puzzle_mask=0)\n\n贪心\n\n每个数字都有对应的火柴数量，根据输入的数可以确定总的火柴数，因为要用这些火柴拼出最大的数，所以应该从9往前尝试，但是尝试的过程中需要判断是否满足条件。2，7分别是最小、最大能拼出数字的火柴数，通过这可以确定剩余火柴数的范围。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 每个数字对应的火彩数量 \nint hcs[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nint t, n, sum, k;\nchar ch;\n\n// i 剩余的数字数，j剩余的火彩数 \nbool judge(int i, int j)  {\n	// 2 和 7 是数字对应的最小和最大火柴数量 \n	return i * 2 <= j && j <= i * 7;\n}\n\nint main() {\n	cin>>t;\n	while(t--) {\n		char x;\n		sum = 0; // 火柴数量 \n		cin>>n;\n		for (int i = 1; i <= n; i++) {\n			cin>>ch;\n			sum += hcs[ch - \'0\'];  // 总的火柴数 \n		}\n		for (int i = 1; i <= n; i++) {\n			// 重新排列后数要最大，所以要从9开始  \n			k = 9;  \n			// 判断是否是最后一位，如果是最后一位，sum应该和某个数字对应的火彩数相等 \n			if (i == n) {\n				while (sum != hcs[k]) {\n					k--;	\n				}	\n				cout<<k;\n				break;\n			}\n			// 剩下的火柴数量应该在最小最大直接 \n			// 如果不满足条件，就继续往下判断 \n			while (!judge(n - i, sum - hcs[k])) {\n				k--;\n			}\n			sum -= hcs[k];\n			cout<<k;\n		}\n		cout<<endl; \n	}\n	return 0;\n}\n```\n\n## [异或和(xorsum)](https://acm.webturing.com/problem.php?cid=1643&pid=5&langmask=262141&puzzle_mask=0)\n\n[参考链接](https://blog.csdn.net/liupang14159/article/details/115607276)\n\n+ 异或是不进位的加法\n+ 进位加法和不进位加法相等，说明没有发生进位\n+ 如果[l,r]区间的加法不进位，那么以r为右端点，左端点在[l,r]中的(l,r)都可行\n+ 新加入一个右端点，那么有可能会出现进位，往右移动左端点，使之不进位。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	long long n;\n	cin >> n;\n	long long a[n];\n	for (long long i = 0; i <n ; i++) \n		cin >> a[i];\n	long long s = 0, l = 0, ans = 0;\n	// 异或相当于不进位的加法 \n	for (long long i = 0; i < n; i++) {\n		while ((s ^ a[i]) != s + a[i]) {\n			s ^= a[l++];\n		}\n		ans += i - l + 1;\n		s ^= a[i];\n	}\n	cout<<ans<<endl;\n	return 0;\n}\n\n// 前缀和的思想\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\nll sum[N], X[N];\nll a[N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n    	scanf(\"%lld\", &a[i]);\n	}\n    sum[1] = X[1] = a[1];\n    // 求出前缀和，以及前几项的异或结果\n    for (int i = 2; i <= n; i++) {\n    	sum[i] = sum[i - 1] + a[i];\n		X[i] = X[i - 1] ^ a[i];\n	}\n    ll ans = 0;\n    int l = 0;\n    // 遍历依次比较即可\n    for (int r = 1; r <= n; r++) {\n        // sum[r] - sum[l] 为 区间(l, r]的和，左开右闭区间\n        // X[r] ^ X[l]) 为 (l, r]的异或结果\n        while (sum[r] - sum[l] != (X[r] ^ X[l])) {\n        	l++;\n		}\n		ans += r - l;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n\n## [五个数AB_CDE乘积最小](https://acm.webturing.com/problem.php?cid=1643&pid=6&langmask=262141&puzzle_mask=0)\n\n全排列\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\nint a[5];\nint n = 5;\n\nint main() {\n    for (int i = 0; i < n; i++) {\n    	cin >> a[i];\n	}\n    // 注意需要先排序，与next_permutation函数的特性有关\n    sort(a, a + 5);\n    int best = INT_MAX;\n    do {\n        if (a[0] == 0 || a[3] == 0) {\n        	continue;\n		}\n        int cur = (a[0] * 100 + a[1] * 10 + a[2]) * (a[3] * 10 + a[4]);\n        best = min(cur, best);\n        // next_permutation，下一个排列，全排列函数，每次循环对应一个排列，类似与升序\n  // 若：a[3] = {1, 2, 3}，则该函数的结果为{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}\n  // 若：a[3] = {3,1,2}，则该函数的结果为{3,1,2},{3,2,1}，这也是前面升序排序的原因\n  // 与之对应的还有一个prev_permutation函数，前一个排列，对a[3] = {3,1,2}，结果为{3,1,2},{2,3,1},\n        // {2,1,3},{1,3,2},{1,2,3}，类似于降序\n    } while (next_permutation(a, a + n));\n    cout << best << endl;\n    return 0;\n}\n```\n', '2021-05-08 15:50:10', '2021-05-15 21:49:29', 0, 0, 0);
INSERT INTO `tb_article` VALUES (47, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg', '贪心算法刷题记录', '## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\n\n**Description**\n\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\n每天只能卖一个商品.\n现在你要让超市获得最大的利润.\n\n**Input**\n\n多组数据.\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\n\n**Output**\n\n对于每一组数据, 输出当前条件下超市的最大利润\n\n**Sample Input**\n\n4\n50 2\n10 1\n20 2\n30 1\n\n7\n20 1\n2 1\n10 3\n100 2\n8 2\n5 20\n50 10\n\n**Sample Output**\n\n80\n185\n\n**解题思路**\n\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef struct Node {\n	int p;\n	int d;\n} Product;\n\nbool cmp(Product p1, Product p2) {\n	return p1.p > p2.p;\n}\n\nProduct pro[10001];\nint visit[10001]; //标记某天是否卖过商品\n\nint main() {\n	int n, sum;\n	while (cin>>n) {\n		for (int i = 1; i <= n; i++)\n			cin>>pro[i].p>>pro[i].d;\n		// 按利润从高到低排序\n		sort(pro + 1, pro + n + 1, cmp);\n		sum = 0;\n		memset(visit, 0, sizeof(visit));\n         // 先售卖高利润的商品\n		for (int i = 1; i <= n; i++) {\n			if (visit[pro[i].d] == 0) {\n				visit[pro[i].d] = 1;\n				sum += pro[i].p;\n			} else {\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\n				for (int j = pro[i].d - 1; j >= 1; j--) {\n					if (visit[j] == 0) {\n						visit[j] = 1;\n						sum += pro[i].p;\n						break;\n					}\n				}\n			}\n		}\n		cout<<sum<<endl;\n	}\n	return 0;\n}\n```\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\n\n**Problem Description**\n\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\n\n**Input**\n\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\n\n**Output**\n\nFor each test case, you should output the smallest total reduced score, one line per test case.\n\n**Sample Input**\n\n```c++\n3\n3\n3 3 3\n10 5 1\n3\n1 3 1\n6 2 3\n7\n1 4 6 4 2 4 3\n3 2 1 7 6 5 4\n```\n\n**Sample Output**\n\n```c++\n0\n3\n5\n```\n\n**解题思路**\n\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n	int deadline;\n	int score;\n} work[1005];\n\nint T, N;\nint day[1005]; // 标记当天有没有做过作业 \n\nint cmp(Node a, Node b) {\n	return a.score > b.score; \n}\n\nint main() {\n	cin>>T;\n	for (int i = 0; i < T; i++) {\n		int res = 0;\n		memset(day, 0, sizeof(day));\n		cin>>N;\n		for (int j = 0; j < N; j++) {\n			cin>>work[j].deadline;\n		}\n		for (int j = 0; j < N; j++) {\n			cin>>work[j].score;\n		}\n		// 按分数降序排列 \n		sort(work, work + N, cmp);\n		for (int j = 0; j < N; j++) {\n			int d = work[j].deadline;\n			// 若当天没做作业 \n			if (!day[d]) {\n				// 标记做过 \n				day[d] = 1;\n			} else { // 当天做过作业 \n				int flag = 0; // 标记有没有找到 \n				// 往前找到没有做过作业的那天 \n				for (int k = d - 1; k >= 1; k--) {\n					if (!day[k]) { \n						day[k] = 1;\n						flag = 1;\n						break;\n					}\n				} \n				// 没找到，则扣分 \n				if (!flag) {\n					res += work[j].score;\n				}\n			} \n		}\n		cout<<res<<endl;\n	}\n	return 0;\n}\n```\n\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\n\n**Problem Description**\n\n“今年暑假不AC？”\n“是的。”\n“那你干什么呢？”\n“看世界杯呀，笨蛋！”\n“@#$%^&*%...”\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\n\n**Input**\n\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\n\n**Output**\n\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\n\n**Sample Input**\n\n```c++\n12\n1 3\n3 4\n0 7\n3 8\n15 19\n15 20\n10 15\n8 18\n6 12\n5 10\n4 14\n2 9\n0\n```\n\n**Sample Output**\n\n```c++\n5\n```\n\n**解题思路**\n\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n	int tis;\n	int tie;\n} p[105];\n \nint cmp(Node a, Node b) {\n	return a.tie < b.tie;\n}\n\nint main() {\n	int n;\n	while (cin>>n && n) {\n		for (int i = 0; i < n; i++) {\n			cin>>p[i].tis>>p[i].tie;\n		}\n		// 按结束时间升序列 \n		sort(p, p + n, cmp);\n		int res = 1;\n		int pTie = p[0].tie; // 记录上个节目结束的时间 \n		for (int i = 1; i < n; i++) {\n			// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \n			if (p[i].tis >= pTie) {\n				res++;\n				pTie = p[i].tie; // 更新 \n			}\n		}\n		cout<<res<<endl;\n	}\n	return  0;\n}\n```\n\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\n\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \"carbon\"的字串是: \"c\", \"ca\", \"car\", \"carb\", \"carbo\", 和 \"carbon\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \"carbohydrate\" 通常用\"carb\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\n在下面的例子中，\"carbohydrate\" 能被缩略成\"carboh\", 但是不能被缩略成\"carbo\" (或其余更短的前缀) 因为已经有一个单词用\"carbo\"开始\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\"car\"精确匹配单词\"car\". 因此 \"car\" 是 \"car\"的缩略语是没有二义性的 , “car”不会被当成\"carriage\"或者任何在列表中以\"car\"开始的单词.\n\n**Input**\n\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\n\n**Output**\n\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\n\n**Sample Input**\n\n```c++\ncarbohydrate\ncart\ncarburetor\ncaramel\ncaribou\ncarbonic\ncartilage\ncarbon\ncarriage\ncarton\ncar\ncarbonate\n```\n\n**Sample Output**\n\n```c++\ncarbohydrate carboh\ncart cart\ncarburetor carbu\ncaramel cara\ncaribou cari\ncarbonic carboni\ncartilage carti\ncarbon carbon\ncarriage carr\ncarton carto\ncar car\ncarbonate carbona\n```\n\n**解题**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstring ss[1005];\nchar str[25];\n\nint main() {\n	int len = 0;\n	int i, j, k;\n	while (cin>>ss[len]) {\n		len++;\n	}\n	for (i = 0; i < len; i++) {\n		int size = ss[i].length();\n        // 遍历当前字符串的每个字符\n		for (j = 0; j < size; j++) {\n			memset(str, 0, sizeof str); \n            // 前缀\n			for (k = 0; k <= j; k++) {\n				str[k] = ss[i][k];\n			}\n			str[k] = \'\\0\';\n            // 与其他字符串挨个比较\n			for (k = 0; k < len; k++) {\n				if (k != i) {\n					// strstr(a, b):返回b在a中的起始位置，a是b的字串\n					//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \n					if (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\n						break;\n					}\n				}\n			}\n			if (k == len) {\n				cout<<ss[i]<<\" \"<<ss[i].substr(0, j + 1)<<endl;\n				break;\n			}\n		}\n		if (j == size) {\n			cout<<ss[i]<<\" \"<<ss[i]<<endl;\n		}\n	}\n	return 0;\n}\n```\n\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\n\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\n\n**Input**\n\n第一行t, 表示有t组数据；\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\n\n**Output**\n\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\n\n**Sample Input**\n\n```c++\n2\n9128456 2\n1444 3\n```\n\n**Sample Output**\n\n```c++\n12456\n1\n```\n\n**解题思路**\n\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\n\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\n\n```c++\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n	int t, k;\n	cin>>t;\n	while(t--) {\n		string str; \n		cin>>str>>k;\n		int len = str.size();\n		while (k--) {\n			for (int i = 0; i < len; i++) {\n				// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\n				if (str[i] > str[i + 1] || i == len - 1) {\n					str.erase(i, 1);\n					break; \n				}\n			} 	\n		}\n        // 处理一下高位为0的情况\n		int j = 0;\n		int newLen = str.size();\n		while(j < newLen && str[j] == \'0\') {\n			j++;\n		}\n		if (j == newLen) {\n			cout<<0<<endl;\n		} else {\n			cout<<str.substr(j, newLen)<<endl; \n		}\n	}\n}\n```\n\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\n\n**Problem Description**\n\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\n\n**Input**\n\n多组数据。对于每组数据：\n第一行为正整数n，表示菜的数量。n<=1000。\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\nn=0表示数据结束。\n\n**Output**\n\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\n\n**Sample Input**\n\n```c++\n1\n50\n5\n10\n1 2 3 2 1 1 2 3 2 1\n50\n0\n```\n\n**Sample Output**\n\n```c++\n-45\n32\n```\n\n**解题思路**\n\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint v[1005];\nint dp[1005]; \n\nint main() {\n	while (cin>>n && n) {\n		memset(dp, 0, sizeof(dp));\n		for (int i = 0; i < n; i++) {\n			cin>>v[i];\n		}\n		// 升序排列 \n		sort(v, v + n);\n		cin>>m;\n		// 余额小于5直接输出 \n		if (m < 5) {\n			cout<<m<<endl;\n			continue;\n		}\n		// 0/1背包，减5后的余额买最多的菜\n		for (int i = 0; i < n - 1; i++) {\n			for (int j = m - 5; j >= v[i]; j--) {\n				dp[j] = max(dp[j], dp[j - v[i]] + v[i]);\n			}\n		} \n		cout<<m-dp[m-5]-v[n-1]<<endl;\n	}\n	return 0;\n}\n```\n\n## [Task（HDU-4864）](http://acm.hdu.edu.cn/showproblem.php?pid=4864)\n\n**Problem Description**\n\nToday the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500*xi+2*yi) dollars.\nThe company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.\n\n**Input**\n\nThe input contains several test cases.\nThe first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 < =N <= 100000,1<=M<=100000).\nThe following N lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the maximum time the machine can work.yi is the level of the machine.\nThe following M lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the time we need to complete the task.yi is the level of the task.\n\n**Output**\n\nFor each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.\n\n**Sample Input**\n\n```c++\n1 2\n100 3\n100 2\n100 1\n```\n\n**Sample Output**\n\n```c++\n1 50004\n```\n\n**题目大意**：有Ｎ个机器，机器有最大执行时间和等级；有Ｍ个任务，每个任务有执行时间和等级，只有当机器的执行时间和等级均大于等于任务的执行时间和等级时，该台机器才能执行该任务，每执行一个任务能获得500*xi+2*yi的酬劳（xi是任务时长，yi是任务等级），每台机器每天只能使用一次，问一天最多能获得多大的酬劳。(机器的数据范围：0<xi<1440，0=<yi<=100)，(任务的数据范围：0<xi<1440，0=<yi<=100)。\n\n**解题思路**：根据酬劳的计算公式和xi、yi的范围可知，对酬劳大小其决定作用的是执行时长xi，所以对所有机器和任务按执行时长进行降序排列，若时长相等，按等级降序排列。贪心暴力。核心点：**后面的任务必然能够被先前加进来的机器执行完毕，因为任务是按时间降序排列的**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\n\ntypedef struct Node {\n	int x;\n	int y;\n} P;\n\nint cmp(P p1, P p2) {\n	if (p1.x == p2.x) {\n		return p1.y > p2.y;\n	}\n	return p1.x > p2.x;\n}\n\nP m[maxn]; // 机器\nP w[maxn]; // 任务\nint level[105]; // 满足任务时长的对应等级的机器数\nint N, M;\nint main() {\n	while (~scanf(\"%d%d\", &N, &M)) {\n		memset(level, 0, sizeof(level));\n		for (int i = 0; i < N; i++) {\n			scanf(\"%d%d\", &m[i].x, &m[i].y);\n		}\n		for (int i = 0; i < M; i++) {\n			scanf(\"%d%d\", &w[i].x, &w[i].y);\n		}\n		sort(m, m + N, cmp);\n		sort(w, w + M, cmp);\n		long long sum = 0; \n		int count = 0;\n		// 后面的加进来的任务必然能够被先前加进来的机所完毕，因为任务是按时间降序排列的\n		for (int i = 0, j = 0; i < M; i++) {\n			while (j < N && m[j].x >= w[i].x) {\n				level[m[j].y]++;\n				j++;\n			}\n			for (int k = w[i].y; k <= 100; k++) {\n				if (level[k]) {\n					level[k]--;\n					sum += w[i].x * 500 + w[i].y * 2;\n					count++;\n					break;\n				}\n			}\n		} \n		printf(\"%d %lld\\n\", count, sum);\n	}\n	return 0;\n} \n\n---------------------------------------------------------------------------\n// 这种写法会超时\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\n\ntypedef struct Node {\n	int x;\n	int y;\n} P;\n\nint cmp(P p1, P p2) {\n	if (p1.x == p2.x) {\n		return p1.y > p2.y;\n	}\n	return p1.x > p2.x;\n}\n\nP m[maxn];\nP w[maxn];\nint vis[maxn];\nint N, M;\nint main() {\n	while (~scanf(\"%d%d\", &N, &M)) {\n		memset(vis, 0, sizeof(vis));\n		for (int i = 0; i < N; i++) {\n			scanf(\"%d%d\", &m[i].x, &m[i].y);\n		}\n		for (int i = 0; i < M; i++) {\n			scanf(\"%d%d\", &w[i].x, &w[i].y);\n		}\n		sort(m, m + N, cmp);\n		sort(w, w + M, cmp);\n		long long sum = 0; \n		int count = 0;\n		for (int i = 0; i < M; i++) {\n			for (int j = N - 1; j >= 0; j--) {\n				if (vis[j]) {\n					continue;\n				}\n				if (m[j].x >= w[i].x && m[j].y >= w[i].y) {\n					vis[j] = 1;\n					sum += 500 * w[i].x + 2 * w[i].y;\n					count++;\n					break;\n				}\n			}\n		} \n		printf(\"%d %lld\\n\", count, sum);\n	}\n	return 0;\n} \n```\n\n## [Intervals POJ-1089](http://poj.org/problem?id=1089)\n\n**Description**\n\nThere is given the series of n closed intervals [ai; bi], where i=1,2,...,n. The sum of those intervals may be represented as a sum of closed pairwise non−intersecting intervals. The task is to find such representation with the minimal number of intervals. The intervals of this representation should be written in the output file in acceding order. We say that the intervals [a; b] and [c; d] are in ascending order if, and only if a <= b < c <= d.\nTask\nWrite a program which:\nreads from the std input the description of the series of intervals,\ncomputes pairwise non−intersecting intervals satisfying the conditions given above,\nwrites the computed intervals in ascending order into std output\n\n**Input**\n\nIn the first line of input there is one integer n, 3 <= n <= 50000. This is the number of intervals. In the (i+1)−st line, 1 <= i <= n, there is a description of the interval [ai; bi] in the form of two integers ai and bi separated by a single space, which are respectively the beginning and the end of the interval,1 <= ai <= bi <= 1000000.\n\n**Output**\n\nThe output should contain descriptions of all computed pairwise non−intersecting intervals. In each line should be written a description of one interval. It should be composed of two integers, separated by a single space, the beginning and the end of the interval respectively. The intervals should be written into the output in ascending order.\n\n**Sample Input**\n\n```c++\n5\n5 6\n1 4\n10 10\n6 9\n8 10\n```\n\n**Sample Output**\n\n```c++\n1 4\n5 10\n```\n\n**题目大意**：输入n个区间，求出最大的区间覆盖\n\n**解题思路**：对所有区间按左端点升序排列，遍历所有区间， 如果当前区间的左端点大于上一区间的右端点，则形成新的区间，否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 50005;\n\nstruct Node {\n	int x;\n	int y;\n} p[maxn], r[maxn]; \n\n// 按左端点大小升序排列 \nint cmp(Node a, Node b) {\n	return a.x < b.x;\n}\n\nint n;\nint main() {\n	while (cin>>n) {\n		for (int i = 0; i < n; i++) {\n			cin>>p[i].x>>p[i].y;\n		}\n		sort(p, p + n, cmp);\n		int cnt = 0;\n		r[0].x = p[0].x;\n		r[0].y = p[0].y; \n		for (int i = 1; i < n; i++) {\n			// 如果当前区间的左端点大于上一区间的右端点，则形成新的区间 \n			if (p[i].x > r[cnt].y) {\n				cnt++;\n				r[cnt].x = p[i].x;\n				r[cnt].y = p[i].y;\n             // 否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \n			} else if (p[i].y > r[cnt].y ) { \n				r[cnt].y = p[i].y;\n			}\n		}\n		for (int i = 0; i <= cnt; i++) {\n			cout<<r[i].x<<\" \"<<r[i].y<<endl;\n		}\n	}\n	return 0;\n} \n```\n\n', '2021-05-08 16:49:02', '2021-05-20 22:31:58', 1, 0, 0);
INSERT INTO `tb_article` VALUES (48, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657093616.jpg', '线性表的顺序存储', '## 线性表的顺序存储\n\n### 1、顺序表的原理\n\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\n\n### 2、顺序表的特点\n\n1、空间是连续的；\n\n2、支持随机访问；\n\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\n\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\n\n### 3、基本存储结构\n\n```c++\n#define MAXSIZE 100 // 线性表的最大长度 \ntypedef int DataType;\n\ntypedef struct Node {\n	DataType data[MAXSIZE]; // 线性表占用的数组空间 \n	int length; // 线性表的实际长度 \n} SeqList;\n```\n\n### 4、基本功能\n\n- 顺序表的初始化功能       **void InitList(SeqList * L)**	\n- 顺序表的判空     **int ListEmpty(SeqList L)**\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList * L, int i, int e)**\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList * L, int i, int * e)**\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList * Lc)**\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList * Lc)**\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \n\n#### 1、顺序表的初始化\n\n将顺序表所有元素置为0，顺序表的实际长度置为0。\n\n```c++\n// 初始化顺序表 \nvoid InitList(SeqList *L) {\n	for (int i = 0; i < MAXSIZE; i++) {\n		L->data[i] = 0;\n	}\n	L->length = 0;\n}\n```\n\n#### 2、顺序表的判空\n\n判断顺序表的实际长度是否等于0即可\n\n```c++\n// 判断顺序表是否为空 \nint ListEmpty(SeqList L) {\n    return L.length == 0;\n}\n```\n\n#### 3、获取指定位置的元素\n\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\n\n```c++\n// 获取某个位置对应元素的值\nint GetElement(SeqList L, int i) {\n	if (L.length == 0 || i < 1 || i > L.length) {\n		return 0;\n	}\n	return L.data[i-1];\n}\n```\n\n#### 4、在指定位置插入元素\n\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\n+ 若没满足条件，即插入失败，返回0；\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\n\n```c++\n// 在某个位置插入元素 e \nint InsertList(SeqList *L, int i, int e) {\n	if (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\n		return 0;\n	}\n	for (int k = L->length; k >= i; k--) {\n		L->data[k] = L->data[k-1];\n	}\n	L->data[i-1] = e;\n	L->length++;\n	return 1;\n}\n```\n\n#### 5、删除指定位置的元素\n\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\n\n```c++\n// 删除指定位置的元素 \nint DeleteList(SeqList *L, int i, int *e)\n{\n	if (i < 1 || i > L->length) {\n		return 0;\n	}\n	*e = L->data[i-1];\n	for (int k = i - 1; k < L->length - 1; k++) {\n		L->data[k] = L->data[k+1];\n	}\n	L->length--;\n	return 1;\n}\n```\n\n#### 6、返回元素的位置\n\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\n\n```c++\n// 返回指定元素在顺序表中的位置 \nint LocateElement(SeqList L, int e) {\n	for (int i = 0; i < L.length; i++) {\n		if (L.data[i] == e) {\n			return i + 1;\n		}\n	}\n	return 0;\n}\n```\n\n#### 7、合并顺序表\n\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\n\n```c++\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\n	int i = 0, j = 0;\n	Lc->length = La.length + Lb.length;//初始化Lc\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\n             return;\n        }\n	int k = 0;\n	while (i < La.length && j < Lb.length) {\n		if (La.data[i] <= Lb.data[j]) {\n			Lc->data[k++] = La.data[i]++;\n		} else {\n			Lc->data[k++] = Lb.data[j++];\n		}\n	}\n	while (i < La.length){\n		Lc->data[k++] = La.data[i++];\n	}\n	while (j < Lb.length) {\n		Lc->data[k++] = Lb.data[j++];	\n	}\n}\n```\n\n#### 8、两个顺序表的union操作（取并集，即要去重）\n\n```c++\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\n	for(int i = 0; i < La.length; i++) {\n		DataType e = La.data[i];\n		if (!LocateElement(*Lc, e)) {   \n			InsertList(Lc, Lc->length + 1, e);\n		}\n	}\n	for(int i = 0; i < Lb.length; i++) {\n		DataType e = Lb.data[i];\n		if (!LocateElement(*Lc, e)) {   \n			InsertList(Lc, Lc->length + 1, e);\n		}\n	}\n}\n```\n\n#### 9、遍历顺序表所有元素\n\n```c++\n// 遍历输出顺序表所有元素 \nvoid PrintList(SeqList L) {\n    for (int i = 0; i < L.length; i++) {\n        printf(\"%d \", L.data[i]);\n    }\n    printf(\"\\n\");\n}\n```\n\n### 5、完整代码和测试\n\n```c++\n#include<stdio.h>\n#define MAXSIZE 100 // 线性表的最大长度 \n\ntypedef int DataType;\n\ntypedef struct Node {\n	DataType data[MAXSIZE]; // 线性表占用的数组空间 \n	int length; // 线性表的实际长度 \n} SeqList;\n\n// 初始化顺序表 \nvoid InitList(SeqList *L) {\n	for (int i = 0; i < MAXSIZE; i++) {\n		L->data[i] = 0;\n	}\n	L->length = 0;\n}\n\n// 判断顺序表是否为空 \nint ListEmpty(SeqList L) {\n    return L.length == 0;\n}\n\n// 获取某个位置对应元素的值\nint GetElement(SeqList L, int i) {\n	if (L.length == 0 || i < 1 || i > L.length) {\n		return 0;\n	}\n	return L.data[i-1];\n}\n\n// 在某个位置插入元素 e \nint InsertList(SeqList *L, int i, int e) {\n	if (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\n		return 0;\n	}\n	for (int k = L->length; k >= i; k--) {\n		L->data[k] = L->data[k-1];\n	}\n	L->data[i-1] = e;\n	L->length++;\n	return 1;\n}\n\n// 删除指定位置的元素 \nint DeleteList(SeqList *L, int i, int *e)\n{\n	if (i < 1 || i > L->length) {\n		return 0;\n	}\n	*e = L->data[i-1];\n	for (int k = i - 1; k < L->length - 1; k++) {\n		L->data[k] = L->data[k+1];\n	}\n	L->length--;\n	return 1;\n}\n\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\n// Lc中的数据元素仍然按值非递减有序排列\n\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\n	int i = 0, j = 0;\n	Lc->length = La.length + Lb.length;//初始化Lc\n	int k = 0;\n	while (i < La.length && j < Lb.length) {\n		if (La.data[i] <= Lb.data[j]) {\n			Lc->data[k++] = La.data[i++];\n		} else {\n			Lc->data[k++] = Lb.data[j++];\n		}\n	}\n	while (i < La.length){\n		Lc->data[k++] = La.data[i++];\n	}\n	while (j < Lb.length) {\n		Lc->data[k++] = Lb.data[j++];	\n	}\n}\n\n// 返回指定元素在顺序表中的位置 \nint LocateElement(SeqList L, int e) {\n	for (int i = 0; i < L.length; i++) {\n		if (L.data[i] == e) {\n			return i + 1;\n		}\n	}\n	return 0;\n}\n\n// 并集 \nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\n	for(int i = 0; i < La.length; i++) {\n		DataType e = La.data[i];\n		if (!LocateElement(*Lc, e)) {   \n			InsertList(Lc, Lc->length + 1, e);\n		}\n	}\n	for(int i = 0; i < Lb.length; i++) {\n		DataType e = Lb.data[i];\n		if (!LocateElement(*Lc, e)) {   \n			InsertList(Lc, Lc->length + 1, e);\n		}\n	}\n}\n\n// 遍历输出顺序表所有元素 \nvoid PrintList(SeqList L) {\n    for (int i = 0; i < L.length; i++) {\n        printf(\"%d \", L.data[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int i, n;\n    SeqList L;\n\n    InitList(&L);\n\n    for (i = 0; i < 10; i++) {\n        L.data[i] = i;\n        L.length++;\n    }\n    printf(\"遍历默认创建好的顺序表：\\n\");\n    PrintList(L);\n\n	printf(\"在顺序表第4个位置插入元素11后：\\n\");\n    InsertList(&L, 4, 11);\n    PrintList(L);\n\n    DeleteList(&L, 5, &n);\n    printf(\"删除顺序表中第5个元素，删除的元素为：%d\\n\", n);\n    printf(\"删除过后的顺序表：\\n\"); \n    PrintList(L);\n\n    printf(\"顺序表中第6个元素：%d\\n\", GetElement(L, 6));\n    \n    printf(\"8在顺序表的位置：%d\\n\", LocateElement(L, 8));\n    \n    SeqList La, Lb, Lc;\n\n    InitList(&La);\n    InitList(&Lb);\n    InitList(&Lc);\n    int j = 1;\n    for (i = 1; i < 10; i += 2) {\n    	InsertList(&La, j++, i);\n	}\n	printf(\"顺序表La:\\n\");\n	PrintList(La);\n	j = 1;\n	for (i = 0; i < 10; i += 2) {\n		InsertList(&Lb, j++, i);\n	}\n	InsertList(&Lb, j++, 9);\n	printf(\"顺序表Lb:\\n\");\n	PrintList(Lb);\n	\n	MergeList(La, Lb, &Lc);\n	printf(\"合并之后的顺序表Lc:\\n\");\n	PrintList(Lc);\n	\n	InitList(&Lc);\n	UnionList(La, Lb, &Lc);\n	printf(\"顺序表La和顺序表Lb的并集：\\n\");\n	PrintList(Lc);\n	\n    return 0;\n}\n```\n![QQ截图20200809152139.png]( https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657507455.png)\n\n### 6、另附指针实现的动态顺序表\n\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType * elem**，利用**malloc**进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用**realloc**函数重新分配内存大小。\n\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\ntypedef int ElemType;\n\ntypedef struct Node {\n    ElemType *elem;  // 指向顺序表的首地址\n    int length; // 顺序表的实际长度\n    int listSize; // 顺序表的最大长度\n} SqList;\n\n// 初始化\nvoid InitList(SqList *L) {\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\n    if (!L->elem) {\n        exit(0);\n    }\n    L->length = 0;\n    L->listSize = LIST_INIT_SIZE;\n}\n\n// 插入元素\nvoid InsertList(SqList *L, int i, ElemType e) {\n    ElemType *q, *p;\n    if (i < 1 || i > L->length + 1) {\n        return;\n    }\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\n        if (!L->elem) {\n            exit(0);\n        }\n        L->listSize += LISTINCREMENT;\n    }\n\n    q = L->elem + i - 1;\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\n        *p = *(p - 1);\n    }\n    *q = e;\n    L->length++;\n}\n\n// 删除元素\nvoid ListDelete(SqList *L, int i, ElemType *e) {\n    ElemType *p, *q;\n    if (i < 1 || i > L->length) {\n        return;\n    }\n    p = L->elem + i - 1;\n    *e = *p;\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\n        *q = *(q + 1);\n    }\n    L->length--;\n}\n\n// 获取元素\nvoid GetElement(SqList *L, int i, int *e) {\n    if (i < 1 || i > L->length) {\n        return;\n    }\n    *e = *(L->elem + i - 1);\n}\n\n// 遍历元素\nvoid ListTraverse(SqList *L) {\n    ElemType *p;\n    if (L->length == 0) {\n        printf(\"List NULL!\\n\");\n        return;\n    }\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\n        printf(\"%d \", *p);\n    }\n    printf(\"\\n\");\n}\n\n// 销毁顺序表\nvoid DestroyList(SqList *L) {\n    free(L->elem);\n    L->elem = NULL;\n    L->length = 0;\n    L->listSize = 0;\n}\n\n// 合并两个顺序表\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\n\n    pa = La->elem;\n    pb = Lb->elem;\n    Lc->listSize = Lc->length = La->length + Lb->length;\n\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\n    if (!pc) {\n        exit(0);\n    }\n    pa_last = La->elem + La->length - 1;\n    pb_last = Lb->elem + Lb->length - 1;\n\n    while (pa <= pa_last && pb <= pb_last) {\n        if (*pa <= *pb) {\n            *pc++ = *pa++;\n        } else {\n            *pc++ = *pb++;\n        }\n    }\n    while (pa <= pa_last) {\n        *pc++ = *pa++;\n    }\n    while (pb <= pb_last) {\n        *pc++ = *pb++;\n    }\n}\n\nint main() {\n    SqList la, lb, lc;\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\n    ElemType e;\n    int i;\n\n    InitList(La);\n    InitList(Lb);\n    InitList(Lc);\n\n    ElemType *pa = La->elem, *pb = Lb->elem;\n\n    for (i = 0; i < 10; i = i + 2) {\n        *pa++ = i;\n        La->length++;\n    }\n    printf(\"The List a is:\\n\");\n    ListTraverse(La);\n\n    for (i = 1; i < 10; i = i + 2) {\n        *pb++ = i;\n        Lb->length++;\n    }\n    printf(\"The List b is:\\n\");\n    ListTraverse(Lb);\n\n    InsertList(La, 3, 100);\n    printf(\"After inserting, the new list a is:\\n\");\n    ListTraverse(La);\n    ListDelete(La, 3, &e);\n    printf(\"The deleted number is: \");\n    printf(\"%d\\n\", e);\n    printf(\"After deleting, the new list a is:\\n\");\n    ListTraverse(La);\n\n    InsertList(Lb, 3, 99);\n    printf(\"After inserting, the new list b is:\\n\");\n    ListTraverse(Lb);\n    ListDelete(Lb, 3, &e);\n    printf(\"The deleted number is: \");\n    printf(\"%d\\n\", e);\n    printf(\"After deleting, the new list a is:\\n\");\n    ListTraverse(Lb);\n\n    MergeList(La, Lb, Lc);\n    printf(\"The list c is:\\n\");\n    ListTraverse(Lc);\n\n    DestroyList(La);\n    DestroyList(Lb);\n\n    ListTraverse(La);\n    ListTraverse(Lb);\n\n    return 0;\n}\n```\n![QQ截图20200808232536.png]( https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657604480.png)\n\n### 7、注意\n\n本篇代码中函数参数中，顺序表的传参有两种写法：\n\n**SeqList L**（结构体变量），**SeqList * L** （结构体指针）\n\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList * L**，则使用**L->length**', '2022-01-15 22:28:30', '2021-05-10 22:40:06', 0, 0, 0);
INSERT INTO `tb_article` VALUES (49, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658155146.jpg', '单链表基本操作的c语言实现', '\n## 1、存储结构\n\n```c\ntypedef int DataType;  // 数据类型\ntypedef struct Node {\n    DataType data;   // 结点数据\n    struct Node *next; // 指向下一个结点的指针\n} Node, *LinkList;\n```\n\n## 2、基本功能\n\n+ 头插法创建单链表   **void CreateListHead(LinkList &head)**\n+ 尾插法创建单链表     **void CreateListTail(LinkList &head)**\n+ 获取指定位置的元素   **int GetElement(LinkList head, int i, DataType &e)**\n+ 获取指定元素的位置   **int LocateElement(LinkList head, int e)**\n+ 在指定位置插入元素  **int InsertList(LinkList head, int i, DataType e)**\n+ 删除指定位置的元素   **int DeleteList(LinkList head, int i, DataType &e)**\n+ 获取单链表的长度       **int LengthLinkList(LinkList head)**\n+ 合并两个非递减的单链表  **void MergeList(LinkList La, LinkList Lb, LinkList &Lc)**\n+ 销毁链表                      **void Destroy(LinkList &L)**\n+ 遍历打印单链表中的所有元素   **void PrintList(LinkList head)**\n\n### 1、头插法创建单链表\n\n每次新增的结点能放在头结点后面的第1号位置，所以创建好的单链表中的元素的顺序是输入元素的逆序。\n\n```c\n/**\n * 头插法创建单链表，输入以-1结束\n */\nvoid CreateListHead(LinkList &head) {\n    DataType x;\n    LinkList p;\n\n    head = (LinkList)malloc(LEN);\n    head->next = NULL;\n    scanf(\"%d\", &x);\n    while (x != -1) {\n        p = (LinkList)malloc(LEN);\n        p->data = x;\n        p->next = head->next; // 新增的结点指向头结点的下一个结点\n        head->next = p;  // 头结点指向新增的结点\n        scanf(\"%d\", &x);\n    }\n}\n```\n\n### 2、尾插法创建单链表\n\n每次新增的结点都放在单链表的尾部，所以顺序和输入顺序保持一致。\n\n```c\n/**\n * 尾插法创建单链表，输入以-1结束\n */\nvoid CreateListTail(LinkList &head) {\n    LinkList p, q;\n    DataType x;\n\n    head = (LinkList)malloc(LEN);\n    q = head;\n  	scanf(\"%d\", &x);\n    while (x != -1) {\n        p = (LinkList)malloc(LEN);\n        p->data = x;\n        q->next = p;\n        q = p;\n        scanf(\"%d\", &x);\n    }\n    q->next = NULL;\n}\n```\n\n### 3、获取指定位置的元素  \n\n```c\n/**\n * 获取指定位置的元素\n * @param head 指向单链表头结点的指针（头指针）\n * @param i 位置\n * @param e 用来存放对应位置的元素值\n * @return 0：获取失败；1：获取成功\n */\nint GetElement(LinkList head, int i, DataType &e) {\n    LinkList p = head->next;\n    int j = 1;\n\n    while (p && j < i) { // 依次后移，直至为空或到达位置\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) { // p为空表示位置超过最大位置，j > i表示位置不合法(i < 1)\n        return 0;\n    }\n    e = p->data;\n    return 1;\n}\n```\n\n### 4、获取指定元素的位置 \n\n```c\n/**\n * 获取某个元素的位置\n * @param head 头指针\n * @param e 元素\n * @return 元素的位置\n */\nint LocateElement(LinkList head, int e) {\n    LinkList p = head->next;\n    int j = 1;\n\n    while (p && p->data != e) { // 挨个遍历，依次比较\n        p = p->next;\n        j++;\n    }\n    if (!p) {  // 查找不到该元素\n        return 0;\n    }\n    return j;\n}\n```\n\n### 5、在指定位置插入元素 \n\n```c\n/**\n * 在单链表插入元素到位置i\n * @param head 单链表的头指针\n * @param i 插入位置\n * @param e 插入元素\n * @return 1：插入成功，0：插入失败\n */\nint InsertList(LinkList head, int i, DataType e) {\n    LinkList p = head; // 从头结点开始\n    int j = 1;\n\n    while (p && j < i) { // 找到插入位置的前一个结点\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) { // p为空或i < 1，插入位置不合法\n        return 0;\n    }\n    LinkList q = (LinkList)malloc(LEN); // 创建新结点\n    q->data = e;\n    q->next = p->next; // 将新结点指向前一个结点的后一个结点\n    p->next = q; // 前一个结点指向新结点\n    // 执行上述两个操作后，达到的效果是新结点插入到了前一个结点的后面\n}\n```\n\n### 6、删除指定位置的元素  \n\n```c\n/**\n * 删除指定位置的元素\n * @param head\n * @param i 位置\n * @param e 被删除的元素的值存放在e中\n * @return 1：删除成功，0：删除失败\n */\nint DeleteList(LinkList head, int i, DataType &e) {\n    LinkList p = head;\n    int j = 1;\n\n    while (p && j < i) {  // 找到位置的前一个结点\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) {\n        return 0;\n    }\n    LinkList s = p->next;\n    e = s->data;\n    p->next = s->next; // 改变前一个结点的指向，使其指向删除结点的后一个结点\n    free(s); \n    return 1;\n}\n```\n\n### 7、获取单链表的长度      \n\n```c\n/**\n * 获取单链表的长度\n * @param head\n * @return 单链表的长度\n */\nint LengthLinkList(LinkList head) {\n    LinkList p = head->next;\n    int count = 0;\n\n    while (p) {\n        count++;\n        p = p->next;\n    }\n    return count;\n}\n```\n\n### 8、合并两个非递减的单链表 \n\n合并两个非递减的单链表，新链表仍然保持非递减\n\n```c\n/**\n * 合并两个非递减的单链表，新的链表仍然非递减\n * @param La\n * @param Lb\n * @param Lc\n */\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\n    LinkList pa, pb, pc;\n\n    pa = La->next;\n    pb = Lb->next;\n    pc = Lc = (LinkList)malloc(LEN);\n\n    while (pa && pb) {\n        if (pa->data <= pb->data) {\n            pc->next = pa;\n            pc = pa;\n            pa = pa->next;\n        } else {\n            pc->next = pb;\n            pc = pb;\n            pb = pb->next;\n        }\n    }\n    pc->next = pa ? pa : pb;\n    free(Lb);\n}\n```\n\n### 9、销毁链表  \n\n```c\n/**\n * 销毁链表\n */\nvoid Destroy(LinkList &L) {\n    LinkList p, q;\n    p = L;\n    while (p) { // 遍历所有结点，释放内存\n        q = p;\n        p = p->next;\n        free(q);\n    }\n    L = NULL; // L置为NULL\n}\n```\n\n### 10、遍历打印单链表\n\n```c\n/**\n * 遍历打印单链表的所有元素\n */\nvoid PrintList(LinkList head) {\n    LinkList p = head->next;\n\n    if (p == NULL) {\n        cout << \"List is NULL!\" <<endl;\n    } else {\n        while (p != NULL) {\n            printf(\"%d \", p->data);\n            p = p->next;\n        }\n        printf(\"\\n\");\n    }\n}\n```\n\n## 3、完整代码及测试\n\n```c\n#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\n#define LEN sizeof(Node)\n\ntypedef int DataType;\n\ntypedef struct Node {\n    DataType data;\n    struct Node *next;\n} Node, *LinkList;\n\n/**\n * 头插法创建单链表\n * @param head\n */\nvoid CreateListHead(LinkList &head) {\n    DataType x;\n    LinkList p;\n\n    head = (LinkList)malloc(LEN);\n    head->next = NULL;\n    scanf(\"%d\", &x);\n    while (x != -1) {\n        p = (LinkList)malloc(LEN);\n        p->data = x;\n        p->next = head->next;\n        head->next = p;\n        scanf(\"%d\", &x);\n    }\n}\n\n/**\n * 尾插法创建单链表\n * @param head\n */\nvoid CreateListTail(LinkList &head) {\n    LinkList p, q;\n    DataType x;\n\n    head = (LinkList)malloc(LEN);\n    q = head;\n  	scanf(\"%d\", &x);\n    while (x != -1) {\n        p = (LinkList)malloc(LEN);\n        p->data = x;\n        q->next = p;\n        q = p;\n        scanf(\"%d\", &x);\n    }\n    q->next = NULL;\n}\n\n/**\n * 获取指定位置的元素\n * @param head 单链表头指针\n * @param i 位置\n * @param e 获取的元素赋值该参数\n * @return 0：获取失败；1：获取成功\n */\nint GetElement(LinkList head, int i, DataType &e) {\n    LinkList p = head->next;\n    int j = 1;\n\n    while (p && j < i) {\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) {\n        return 0;\n    }\n    e = p->data;\n    return 1;\n}\n\n/**\n * 获取某个元素的位置\n * @param head\n * @param e\n * @return 元素的位置\n */\nint LocateElement(LinkList head, int e) {\n    LinkList p = head->next;\n    int j = 1;\n\n    while (p && p->data != e) {\n        p = p->next;\n        j++;\n    }\n    if (!p) {\n        return 0;\n    }\n    return j;\n}\n\n/**\n * 在单链表插入元素到位置i\n * @param head 单链表的头指针\n * @param i 插入位置\n * @param e 插入元素\n * @return 1：插入成功，0：插入失败\n */\nint InsertList(LinkList head, int i, DataType e) {\n    LinkList p = head;\n    int j = 1;\n\n    while (p && j < i) {\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) {\n        return 0;\n    }\n    LinkList q = (LinkList)malloc(LEN);\n    q->data = e;\n    q->next = p->next;\n    p->next = q;\n}\n\n/**\n * 删除指定位置的元素\n * @param head\n * @param i 位置\n * @param e 被删除的元素的值存放在e中\n * @return 1：删除成功，0：删除失败\n */\nint DeleteList(LinkList head, int i, DataType &e) {\n    LinkList p = head;\n    int j = 1;\n\n    while (p && j < i) {\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) {\n        return 0;\n    }\n    LinkList s = p->next;\n    e = s->data;\n    p->next = s->next;\n    free(s);\n    return 1;\n}\n\n/**\n * 获取单链表的长度\n * @param head\n * @return\n */\nint LengthLinkList(LinkList head) {\n    LinkList p = head->next;\n    int count = 0;\n\n    while (p) {\n        count++;\n        p = p->next;\n    }\n    return count;\n}\n\n/**\n * 合并两个非递减的单链表，新的链表仍然非递减\n * @param La\n * @param Lb\n * @param Lc\n */\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\n    LinkList pa, pb, pc;\n\n    pa = La->next;\n    pb = Lb->next;\n    pc = Lc = (LinkList)malloc(LEN);\n\n    while (pa && pb) {\n        if (pa->data <= pb->data) {\n            pc->next = pa;\n            pc = pa;\n            pa = pa->next;\n        } else {\n            pc->next = pb;\n            pc = pb;\n            pb = pb->next;\n        }\n    }\n    pc->next = pa ? pa : pb;\n    free(Lb);\n}\n\n/**\n * 销毁链表\n * @param L\n */\nvoid Destroy(LinkList &L) {\n    LinkList p, q;\n    p = L;\n    while (p) {\n        q = p;\n        p = p->next;\n        free(q);\n    }\n    L = NULL;\n}\n\n/**\n * 遍历打印单链表的所有元素\n * @param head\n */\nvoid PrintList(LinkList head) {\n    LinkList p = head->next;\n\n    if (p == NULL) {\n        cout << \"List is NULL!\" <<endl;\n    } else {\n        while (p != NULL) {\n            printf(\"%d \", p->data);\n            p = p->next;\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    LinkList L;\n\n    printf(\"头插法创建单链表：（输入以-1结束）\\n\");\n    CreateListHead(L);\n    PrintList(L);\n\n    printf(\"尾插法创建单链表：（输入以-1结束）\\n\");\n    CreateListTail(L);\n    PrintList(L);\n\n    InsertList(L, 1, 100);\n    printf(\"在1号位置插入100后，单链表如下：\\n\");\n    PrintList(L);\n\n    DataType e;\n    DeleteList(L, 1, e); \n    printf(\"删除1号位置的元素，被删除的元素为：\\n\");\n    printf(\"删除后的单链表为：\\n\"); \n    PrintList(L);\n\n    printf(\"单链表的长度为：%d\\n\", LengthLinkList(L));\n    \n    GetElement(L, 1, e);\n    printf(\"1号位置的元素为：%d\\n\");\n    \n    printf(\"元素4在单链表中的位置为：%d\\n\", LocateElement(L, 4));\n\n	cout << endl;\n    LinkList La, Lb, Lc;\n    printf(\"尾插法创建单链表La：\\n\");\n    CreateListTail(La);\n    PrintList(La);\n    printf(\"尾插法创建单链表Lb：\\n\");\n    CreateListTail(Lb);\n    PrintList(Lb);\n    MergeList(La, Lb, Lc);\n    printf(\"合并单链表La和Lb后的新单链表Lc如下：\\n\");\n    PrintList(Lc);\n\n    return 0;\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081022033553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n\n\n**注意：**\n\n上述函数采用了 C++ 引用参数的写法，**LinkList &head**，C语言下不支持这种写法，需要在 C++ 环境下使用，即.cpp文件。**下面附上C语言的写法：**\n\n```c\n/**\n * LinkList 本身已经是结构体指针，参数再使用LinkList *的形式\n * 可以理解为要想改变一个结构体指针，则需要取指针的指针。\n * 类似于改变int a，则需要使用 int *a，这里要改变LinkList head，则需要使用LinkList *head\n */\nvoid CreatListTail(LinkList *head) {\n    int x;\n    LinkList *p, *q;\n\n    *head = (LinkList *) malloc(LEN);\n    q = *head;\n\n    scanf(\"%d\", &x);\n    while (x != -1) {\n        p = (LinkList *) malloc(LEN);\n        p->data = x;\n        q->next = p;\n        q = p;\n        scanf(\"%d\", &x);\n    }\n    q->next = NULL;\n}\n\n\n// 可以不传参，函数里面定义头指针，创建链表，然后把头指针返回，主函数用结构体指针接收即可\nLinkList CreateListhead() {\n    int x;\n    LinkList *head, *p;\n\n    head = (LinkList *) malloc(LEN);\n    head->next = NULL;\n\n    scanf(\"%d\", &x);\n    while (x != -1) {\n        p = (LinkList *) malloc(LEN);\n        p->data = x;\n        p->next = head->next;\n        head->next = p;\n    }\n    return head;\n}\n```', '2021-05-01 22:49:28', '2021-05-11 15:25:19', 0, 0, 0);
INSERT INTO `tb_article` VALUES (51, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658675963.jpeg', '顺序栈基本操作的C语言实现', '\n### 1、存储结构\n\n```c\n#define Stack_Init_Size 100\n#define StackIncrement 10\ntypedef int ElemType;\ntypedef int Status;\n\n// 方式一（本文采取）\ntypedef struct {\n    ElemType *base; // 栈底指针\n    ElemType *top; // 栈顶指针\n    int stacksize; // 栈的最大容量\n} SqStack;\n\n// 方式二\ntypedef struct {\n    int data[MaxSize];\n    int top;\n} SeqStack;\n```\n\n### 2、函数列表\n\n+ **Status InitStack(SqStack * S)**  初始化栈\n+ **Status GetTopStack(SqStack * S, ElemType * e)**  获取栈顶元素，参数e存放栈顶元素的值\n+ **Status PushStack(SqStack * S, ElemType e)**   进栈，将元素e入栈\n+ **Status PopStack(SqStack * S, ElemType * e)**   出栈，出栈的元素存放在参数e中\n+ **Status EmptyStack(SqStack * S)**  判断栈是否为空\n+ **Status LengthStack(SqStack * S)** 获取栈的实际长度\n+ **Status DestroyStack(SqStack * S)** 销毁栈\n+ **Status StackTraverse(SqStack * S)** 遍历栈，打印每个元素\n\n### 3、完整代码\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define Stack_Init_Size 10 // 初始化栈的最大长度\n#define StackIncrement 10 // 若栈最大空间不够时，需要增加的长度\ntypedef int ElemType;\ntypedef int Status;\n\ntypedef struct {\n    ElemType *base; // 栈底指针\n    ElemType *top; // 栈顶指针\n    int stack_size; // 栈的最大长度\n} SqStack;\n\n// 初始化栈\nStatus InitStack(SqStack *S) {\n    // 分配初始空间\n    S->base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType));\n    if (!S->base) {\n        exit(0);\n    }\n    S->top = S->base; /// 栈顶与栈底相同\n    S->stack_size = Stack_Init_Size; // 栈的最大长度等于初始长度\n    return 1;\n}\n\n// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可\nStatus EmptyStack(SqStack *S) {\n    return S->base == S->top;\n}\n\n// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度\nStatus LengthStack(SqStack *S) {\n    if (S->top == S->base) {\n        return 0;\n    }\n    return (Status) (S->top - S->base);\n}\n\n// 获取栈顶的元素，参数e用来存放栈顶的元素\nStatus GetTopStack(SqStack *S, ElemType *e) {\n    if (S->top == S->base) {\n        return 0;\n    } \n    *e = *(S->top - 1);\n    return 1;\n}\n\n// 进栈，参数e是要进栈的元素\nStatus PushStack(SqStack *S, ElemType e) {\n    // 若栈的最大长度不会够用时，重新开辟，增大长度\n    if (S->top - S->base >= S->stack_size) {\n        S->base = (ElemType *)realloc(S->base, (S->stack_size + StackIncrement) * sizeof(ElemType));\n        if (!S->base) {\n            return 0;\n        }\n        // 栈顶指针为栈底指针加上栈之前的最大长度\n        S->top = S->base + S->stack_size;\n        // 栈当前的最大长度等于栈之前的最大长度与增加的长度之和\n        S->stack_size += StackIncrement;\n    }\n    *S->top++ = e; // 先赋值，后栈顶指针上移\n    return 1;\n}\n\n// 出栈，参数e用来存放出栈的元素\nStatus PopStack(SqStack *S, ElemType *e) {\n    if (S->base == S->top) {\n        return 0;\n    }\n    *e = *--S->top; // 栈顶指针先下移，后赋值\n    return 1;\n}\n\n// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0\nStatus DestroyStack(SqStack *S) {\n    free(S->base);\n    S->base = S->top = NULL;\n    S->stack_size = 0;\n    return 1;\n}\n\n// 遍历栈，依次打印每个元素\nStatus StackTraverse(SqStack *S) {\n    ElemType *p;\n\n    if (S->top == S->base) {\n        printf(\"Stack is NULL.\\n\");\n        return 0;\n    }\n    p = S->top;\n    // 由栈顶依次向下遍历\n    while (p > S->base) {\n        p--;\n        printf(\"%d \", *p);\n    }\n    printf(\"\\n\");\n    return 1;\n}\n\nint main() {\n    SqStack q, *S;\n    S = &q;\n\n    int i, n, e;\n\n    printf(\"Creat a NULL Stack :\\n\");\n    InitStack(S);\n\n    printf(\"input the length of the Stack :\\n\");\n    scanf(\"%d\", &n);\n\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d\", &e);\n        PushStack(S, e);\n    }\n    printf(\"Is the stack NULL?\\n\");\n\n    if (EmptyStack(S)) {\n        printf(\"Yes!\\n\");\n    } else {\n        printf(\"No!\\n\");\n    }\n    printf(\"The length of stack is %d.\\n\", LengthStack(S));\n\n    printf(\"The stack is :\\n\");\n    StackTraverse(S);\n\n    e = GetTopStack(S, &e);\n    printf(\"The top data is %d.\\n\", e);\n\n    printf(\"input the data to the stack :\\n\");\n    scanf(\"%d\", &e);\n    PushStack(S, e);\n    printf(\"The new stack is :\\n\");\n    StackTraverse(S);\n\n    printf(\"Delete the top data : \");\n    e = PopStack(S, &e);\n    printf(\"%d\\n\", e);\n\n    printf(\"The new stack is :\\n\");\n    StackTraverse(S);\n\n    printf(\"Destroy the stack :\\n\");\n    DestroyStack(S);\n    StackTraverse(S);\n\n    return 0;\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819094841609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n', '2021-05-10 22:58:02', NULL, 1, 0, 0);
INSERT INTO `tb_article` VALUES (52, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620745608171.jpg', '链栈基本操作的C语言实现', '\n```c\n#include<stdio.h>\n#include<stdlib.h>\n\n// 链表中的结点结构 \ntypedef struct Node {\n    int data;  // 数据元素 \n    struct Node *next; // 指向下一个结点 \n} StackNode, *PStackNode;\n\ntypedef struct {\n    PStackNode top; // 指向栈顶结点 \n    int count; //  栈的大小 \n} LinkStack, *PLinkStack;\n\n// 初始化链栈，栈顶指针置为NULL，栈的大小置为0 \nPLinkStack Init_LinkStack() {\n    PLinkStack S;\n\n    S = (PLinkStack)malloc(sizeof(LinkStack));\n    if (!S) {\n        return NULL;\n    }\n    S->top = NULL;\n    S->count = 0;\n\n    return S;\n}\n\n// 判断栈是否为空 \nint Empty_LinkStack(PLinkStack S) {\n    return (S->top == NULL);\n}\n\n// 入栈，参数e为入栈的元素 \nvoid Push_LinkStack(PLinkStack S, int e) {\n    PStackNode p;\n\n    p = (PStackNode)malloc(sizeof(StackNode)); // 创建新的结点 \n    if (!p) {\n        return;\n    }\n    p->data = e; // 赋值元素e \n    p->next = S->top; // 新的结点next指向栈顶结点 \n    S->top = p; // 更新栈顶结点为新的结点 \n    S->count++; // 栈的大小加一 \n}\n\n// 出栈，出栈的元素存放在参数e中 \nint Pop_LinkStack(PLinkStack S, int *e) {\n    PStackNode p;\n	\n    if (Empty_LinkStack(S)) { // 判断栈是否为空 \n        printf(\"Stack NULL!\\n\");\n        return 0;\n    }\n    *e = S->top->data; // 将栈顶元素赋值给参数e \n    p = S->top; // 临时存储久的栈顶结点 \n    S->top = S->top->next; // 将栈顶结点更新为久的栈顶结点的下一个结点 \n    free(p); // 释放久的栈顶结点 \n    S->count--; // 栈的大小减一 \n\n    return 1;\n}\n\n// 获取栈顶的元素，存放在参数e中 \nint GetTop_LinkStack(PLinkStack S, int *e) {\n    if (Empty_LinkStack(S)) {\n        printf(\"Stack NULL!\\n\");\n        return 0;\n    }\n    *e = S->top->data;\n\n    return 1;\n}\n\n// 遍历打印栈的所有元素 \nvoid Print_LinkStack(PLinkStack S) {\n    PStackNode p;\n\n    if (Empty_LinkStack(S)) {\n        printf(\"Stack NULL!\\n\");\n        return;\n    }\n    p = S->top;\n    while (p) {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\n// 清空栈 \nvoid Clear_LinkStack(PLinkStack S) {\n    if (Empty_LinkStack(S)) {\n        return;\n    }\n    while (S->count) {\n        PStackNode p = S->top;\n        S->top = p->next;\n        free(p);\n        S->count--;\n    }\n}\n\n// 返回栈的大小 \nint Length_LinkStack(PLinkStack S) {\n    if (!S) {\n        return 0;\n    }\n    return S->count;\n}\n\nint main() {\n    PLinkStack S;\n    int n, e, i;\n\n    printf(\"input the number of datas :\\n\");\n    scanf(\"%d\", &n);\n\n    S = Init_LinkStack();\n    printf(\"input datas :\\n\");\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &e);\n        Push_LinkStack(S, e);\n    }\n    printf(\"The Stack is :\\n\");\n    Print_LinkStack(S);\n\n    Pop_LinkStack(S, &e);\n    printf(\"The pop data is %d.\\n\", e);\n\n    GetTop_LinkStack(S, &e);\n    printf(\"The top data is %d.\\n\", e);\n\n    printf(\"The new stack is :\\n\");\n    Print_LinkStack(S);\n\n    printf(\"The length of stack is %d.\\n\", Length_LinkStack(S));\n\n    printf(\"Clear the stack :\\n\");\n    Clear_LinkStack(S);\n    Print_LinkStack(S);\n\n    printf(\"The new stack length is %d.\\n\", Length_LinkStack(S));\n\n    return 0;\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819225512569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n', '2021-05-11 23:04:08', '2021-05-11 23:06:53', 0, 0, 0);
INSERT INTO `tb_article` VALUES (53, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621001632134.png', '2018年安徽省程序设计竞赛题解', '## [问题 A: 数7](https://acm.webturing.com/problem.php?cid=1323&pid=0&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n求整数序列A 中位置L 到R中间一共有多少个7，（每一个位上的7和能被7整除的次数）    \n\n**输入**\n\n第一行是T(T<=50)\n然后是T行 L R (L<R<1e5)\n\n**输出**\n\n输出7的个数\n\n**样例输入**\n\n```c++\n2\n1 10\n47 50\n```\n\n**样例输出**\n\n```c++\n2\n3\n```\n\n**提示**\n\n第二组数据解释  47 中含有一个7， 49含有2个7 所以输出3\n\n**题解**：直接暴力求解即可。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint count7(int x) {\n	int y = x, ans = 0;\n	while (x != 0) {\n		if (x%10 == 7) {\n			ans++;\n		}\n		x /= 10;\n	}\n	while (y % 7 == 0) {\n		ans++;\n		y /= 7;\n	}\n	return ans;\n}\n\nint main() {\n	int T, L, R;\n	scanf(\"%d\", &T);\n	while (T--) {\n		scanf(\"%d%d\", &L, &R);\n		int sum = 0;\n		for (int i = L; i <= R; i++) {\n			sum += count7(i);\n		}	\n		printf(\"%d\\n\", sum);\n	}\n	return 0;\n}\n```\n\n## [问题 B: 编译错误](https://acm.webturing.com/problem.php?cid=1323&pid=1&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n​ 在程序员编写程序的时候，通常会引用其他文件，而引用的文件也会引用其它的头文件。但是出现循环引用的现象编译时便会报错。例如A引用了B，B引用了C，C引用了A，那么就产生了循环引用（Circular reference）。考虑另外一个情况，A引用了B和C，B引用D，C引用D，虽然D被引用了两次，但是没有出现循环引用 。\n\n**输入**\n\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是一个整数n，代表有多少个引用关系。接下来n行每行有2个字符串a,b，用空格分隔，代表a引用了b。其中T<=50, n<=10^5，每个字符串的长度不超过100。\n\n**输出**\n\n​ 共T行。若不会产生编译错误则输出Passed，否则输出Failed。\n\n**样例输入**\n\n```c++\n2\n8\nclient.cpp client.h\nclient.h server.h\nserver.cpp server.h\nserver.h common.h\nclient.h common.h\ncommon.cpp common.h\ncommon.h gtest.h\ncommon.h glog.h\n4\nwork.cpp client.cpp\nclient.cpp server.cpp\nserver.cpp adhoc.cpp\nadhoc.cpp work.cpp\n```\n\n**样例输出**\n\n```c++\nPassed\nFailed\n```\n\n**解题思路**：利用拓扑排序进行求解，若能够进行拓扑排序则说明不会出现编译错误，否则说明出现了循环应用。为了方便使用拓扑排序，先对字符串进行处理，将每个字符串分配唯一的序号。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nvector<int> g[maxn]; // 图\nint degree[maxn], n, T, m, cnt; // degree入度\nmap<string, int> mp; // 存储字符串及其序号 \nchar a[50], b[50];\n\n// 拓扑排序\nbool topoSort() {				\n	cnt = 0;\n	queue<int> q;\n	for (int i = 1; i <= n; i++) {\n		if (!degree[i])\n			q.push(i);\n	}\n	while (!q.empty()) {\n		int x = q.front();\n		q.pop();\n		cnt++;\n		for (int i = 0; i < g[x].size(); i++) {\n			int t = g[x][i];\n			degree[t]--;\n			if (!degree[t])\n				q.push(t);\n		}\n	}\n	if (cnt == n)\n		return 1;\n	return 0;\n}\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) { \n		int total = 0, u, v; // 利用total为字符串分配序号，u，v是对应字符串的序号 \n		mp.clear();\n		memset(degree, 0, sizeof(degree));\n		scanf(\"%d\", &n);\n		for (int i = 0; i < n; i++) {\n			g[i].clear();\n		}\n		for (int i = 0; i < n; i++) {\n			scanf(\"%s%s\", a, b);\n			// 判断 a 是否已经存在 \n			if (mp.find(a) == mp.end()) {\n				// 不存在，存入 map，分配序号 \n				mp.insert(pair<string,int>(a, ++total));\n				// 获取该字符串对应的序号 \n				u = total;\n			} else {\n				u = mp[a];\n			}\n			// 判断 b 是否已经存在 \n			if (mp.find(b) == mp.end()) {\n				mp.insert(pair<string,int>(b, ++total));\n				v = total;\n			} else {\n				v = mp[b];	\n			}\n			// 存入图中 \n			g[u].push_back(v);\n			degree[v]++;\n		}\n		// 拓扑排序判断 \n		if (topoSort()) {\n			printf(\"Passed\\n\");\n		} else {\n			printf(\"Failed\\n\");\n		}\n	}\n	return 0;\n}\n```\n\n## [问题 C: 做操的时候要排好队](https://acm.webturing.com/problem.php?cid=1323&pid=2&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n同学们在做早操时，应该按照身高从低到高排好队。但是总是有人不好好排队，老师在审查时会对没有排好的队伍扣除一定的分数。扣的分数被定义为，找到三个人Ai,Aj,Ak，其中i<j<k，分数为max(0,(Ai-Aj))+max(0,(Aj-Ak))。找到一组i,j,k使这个分数最大即是扣除的分数。\n\n**输入**\n\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是一个整数n，代表有一共有多少个人。第二行共有n个整数，代表n个人的身高。其中1<=T<=50,3<=n<=10^6 每个数的大小不超过1000。\n\n**输出**\n​ 共T行。扣除的分数。\n\n**样例输入**\n\n```c++\n2\n4\n150 160 170 180\n4\n160 150 170 180\n```\n\n**样例输出**\n\n```c++\n0\n10\n```\n\n**题解：**\n\n该题是寻找一个 i , j , k 满足（i < j < k）但 i , j , k 并不一定连续,如果我们枚举中间数 j , 从 2 到 n - 2 , 对于每一次枚举，我们都需要对 i，k 分别枚举，时间复杂度为 **O(n2),** 肯定不能通过。我们其实在枚举过程中重复了很多计算，对于每一个 j, 我们的目的是寻找 i < j 的 a[i] 最大值，k > j 的 a[k] 最小值。\n\n​ 我们可以预先处理，用两个数组 maxx[i], minx[i],  maxx[i] 表示i之前 a[i] 的最大值（不包括 a[i]）, minx[i] 表示以 i 之后a[i] 的最小值。然后我们直接枚举 max(maxx[i] - a[i], 0) + max(a[i] - minx[i])，时间复杂度为 **O(n);**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e6 + 5;\nint T, n;\nint a[maxn], minx[maxn], maxx[maxn];\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		scanf(\"%d\", &n);\n		a[0] = 0;\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n		}\n		maxx[1] = a[1];\n        // i 之前的最大值\n		for (int i = 2; i <= n - 1; i++) {\n			maxx[i] = max(maxx[i-1], a[i-1]);\n		}\n		minx[n] = a[n];\n        // i 之后的最小值\n		for (int i = n - 1; i >= 2; i--) {\n			minx[i] = min(a[i+1], minx[i+1]);\n		}\n		int res = 0;\n        // 最后结果\n		for (int i = 2; i <= n - 1; i++) {\n			res = max(res, max(0, maxx[i] - a[i]) + max(0, a[i] - minx[i]));\n		}\n		printf(\"%d\\n\", res);\n	}\n	return 0;\n}\n```\n\n## [问题 D: 判重](https://acm.webturing.com/problem.php?cid=1323&pid=3&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n小七初始有n个数的样本集。现在又新加了m个数，他想知道这m个数是否已经在这n个数之中了。但是他判断是否有重复的方式和常人有些不同。对于样本集内的任意一个数x，他先将x二进制的第2, 5, 7, 10, 13, 14, 17, 18位取反，生成新的8个数。例如x是7（00111），那么第一个数就是5（00101），第二个数是23（10111）…依次类推。然后将他表格上这8个数的位置全部变为1（初始整个表格全部为0）。判断重复时，若一个数x产生的8个数，在表格内全部为1，就认为这个数x和样本集内的数有重复，否则认为没有重复\n\n**输入**\n\n输入T，代表T组数据。每组数据初始输入n, m。代表n个样本以及m个需要判断的数。接下来两行，第一行是n个样本，第二行m个需要判断的数，样本在前。对于这m个数，每个数输出yes 或者 no。m组数据相互独立，即这m个数都不会新加入到样本集内。其中T<=50 ,n,m<1e5 。\n\n**输出**\n\n输出一行，共m个字符串，重复输出yes，否则输出no，空格隔开\n\n**样例输入**\n\n```c++\n1\n2 2\n2 1\n3 2\n```\n\n**样例输出**\n\n```c++\nno yes\n```\n\n**解题思路：** 利用 STL 的 set 进行判重，将每个数按位异或放进 set 中，判重时，查询对应的数在不咋 set 中即可。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint a[] = {2, 5, 7, 10, 13, 14, 17, 18};\nint T, n, m;\nset<int> s;\n\nint main() {\n	int x;\n	scanf(\"%d\", &T);\n	while (T--) {\n		scanf(\"%d%d\", &n, &m);\n		s.clear();\n		for (int i = 0; i < n; i++) {\n			scanf(\"%d\", &x);\n			for (int j = 0; j < 8; j++) {\n                // 按位取反，1^1 = 0, 1^0 = 1\n				int y = x^(1 << (a[j] - 1));\n                // 存进 set \n				s.insert(y);\n			}\n		}\n		for (int i = 0; i < m; i++) {\n			scanf(\"%d\", &x);\n			int flag = 1;\n			for (int j = 0; j < 8; j++) {\n                // 按位取反后，查询 set 集合即可\n				int y = x^(1 << (a[j] - 1));\n				if (s.find(y) == s.end()) {\n					flag = 0;\n					break;\n				}\n			}\n			if (flag) {\n				printf(\"yes \");\n			} else {\n				printf(\"no \");\n			}\n		} \n	}\n	return 0;\n}\n```\n\n## [问题 E: 最长上升字串](https://acm.webturing.com/problem.php?cid=1323&pid=4&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n给定n个整数，对其进行m次查询。每次查询是一个范围l到r，求出l到r的最长上升连续子串。上升连续子串的定义为一个连续的子串且严格递增。\n\n**输入**\n\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是一个整数n,m，代表有一共有n个人，m个查询。第二行共有n个整数，接下来m行是m次查询，每行两个整数l,r。\n\n**输出**\n\n共T行，每行m个整数，代表最长上升连续字串。其中T<=50,n,m<1e5,每个数的大小不超过1e9。\n\n**样例输入**\n\n```c++\n1\n4 2\n3 2 4 5\n1 3\n1 4\n```\n\n**样例输出**\n\n```c++\n2 3\n```\n\n**解题思路：**\n\n最长连续上升字串，直接求解的话很容易。但本题数据量太大，有 m 次查询，时间复杂度有点高，可能会超时。涉及到区间查询，可以想到用线段树进行求解，而且本题没有更新操作。\n\n线段树结点维护三个值，lv 是区间左端点开始的最长上升连续值，rv 是以区间右端点结束的最长上升连续值，mv是该区间的最长上升连续值，pushup 时分类讨论，当 a[mid] < a[mid+1] 时，该区间中间两个点是递增的，需要进行线段树的区间合并操作。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\n\nstruct Tree {\n	int l, r;\n	int lv, mv, rv;\n} tree[maxn<<2];\n\nint T, n, m; \nint a[maxn];\n\nvoid pushup(int l, int r, int rt) {\n	tree[rt].lv = tree[rt<<1].lv;\n	tree[rt].rv = tree[rt<<1|1].rv;\n	tree[rt].mv = max(tree[rt].mv, tree[rt].mv);\n	int mid = (l + r) >> 1;\n	// 合并区间 \n	if (a[mid] < a[mid+1]) {\n		// 以左区间的左端点开始的最长上升字串的长度等于左区间的长度，则可以合并 \n		if (tree[rt<<1].lv == mid - l + 1) {\n			// 左区间的左端点和右区间的左端点合并 \n			tree[rt].lv = tree[rt<<1].lv + tree[rt<<1|1].lv;\n		}\n		// 以右区间的右端点结束的最长上升字串的长度等于右区间的长度，则可以合并 \n		if (tree[rt<<1|1].r == r - mid) {\n			// 左区间的右端点和右区间的右端点合并 \n			tree[rt].rv = tree[rt<<1].rv + tree[rt<<1|1].rv;\n		}\n		// 更新区间的最大值，与合并后的比较，左区间右端点和右区间左端点合并 \n		tree[rt].mv = max(tree[rt].mv, tree[rt<<1].rv + tree[rt<<1|1].lv);\n	}\n}\n\nvoid build(int l, int r, int rt) {\n	tree[rt].l = l;\n	tree[rt].r = r;\n	if (l == r) {\n		tree[rt].lv = tree[rt].mv = tree[rt].rv = 1;\n		return;\n	}\n	int mid = (l + r) >> 1;\n	build(l, mid, rt<<1);\n	build(mid + 1, r, rt<<1|1);\n	pushup(l, r, rt);\n}\n\nint query(int l, int r, int rt) {\n	if (tree[rt].l >= l && tree[rt].r <= r) {\n		return tree[rt].mv;\n	}\n	int mid = (tree[rt].l + tree[rt].r) >> 1;\n	int ans = 0;\n	if (l <= mid) {\n		ans = max(ans, query(l, r, rt<<1));\n	} \n	if (r > mid) {\n		ans = max(ans, query(l, r, rt<<1|1));\n	}\n	if (a[mid] < a[mid+1]) {\n		ans = max(ans, min(tree[rt<<1].rv, mid-l+1) + min(tree[rt<<1|1].lv, r-mid));\n	}\n}\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n		}\n		build(1, n, 1);\n		for (int i = 1; i <= m; i++) {\n			int x, y;\n			scanf(\"%d%d\", &x, &y);\n			printf(\"%d \", query(x, y, 1));\n		}\n	}\n	return 0;\n}\n```\n\n不用线段树直接进行求解，发现也能 AC，可能数据比较菜。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\n\nint T, n, m; \nint a[maxn];\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n		}\n		for (int i = 1; i <= m; i++) {\n			int x, y;\n			scanf(\"%d%d\", &x, &y);\n			int res = 1, len = 1;\n			for (int j = x + 1; j <= y; j++) {\n                // 后一个比前一个大，l长度增加\n				if (a[j] > a[j-1]) {\n					len++;\n				} else {\n                    // 否则，长度置为1，因为是连续字串\n					len = 1;\n				}\n				res = max(len, res);\n			}\n			printf(\"%d\\n\", res);\n		}\n	}\n	return 0;\n}\n```\n\n## [问题 F: 雄伟的城堡](https://acm.webturing.com/problem.php?cid=1323&pid=5&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n在一个群岛上，有一个富可敌国的大富翁。他打算在这个群岛上建造一个最大城堡，也就是群岛上最大的岛屿。\n\n**输入** \n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是两个整数n,m，代表地图的大小。接下来n行每行共m个整数。0代表海洋，1代表陆地。其中T<=50,n,m<=200 。\n\n**输出**\n共T行，最大的面积。\n\n**样例输入**\n\n```c++\n1\n5 5\n0 1 1 0 0\n1 1 0 0 0\n0 0 1 1 0\n0 1 1 1 1 \n0 0 1 1 0\n```\n\n**样例输出**\n\n```c++\n8\n```\n\n**解题思路：** dfs 或 bfs 求最大连通块。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 205;\nint T, n, m;\nint a[maxn][maxn];\nint vis[maxn][maxn];\nint area, ans;\n\nvoid dfs(int x, int y) {\n	if (x < 0 || y < 0 || x >= n || y >= n || vis[x][y] || !a[x][y]) {\n		return;\n	}\n	vis[x][y] = 1;\n	area++;\n	dfs(x-1, y);\n	dfs(x+1, y);\n	dfs(x, y-1);\n	dfs(x, y+1);\n}\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		ans = 0;\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				scanf(\"%d\", &a[i][j]);\n			}\n		}\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				if (a[i][j] && !vis[i][j]) {\n					area = 0;\n					dfs(i, j);\n					ans = max(area, ans);\n				}\n			}\n		}\n		printf(\"%d\\n\", ans);\n	}\n	return 0;\n}\n\n----------------------------------------------------------------------------------------\n\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 205;\nint T, n, m;\nint a[maxn][maxn];\nint vis[maxn][maxn];\nint dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\nint area, ans;\n\nstruct Node {\n    int x, y;\n    Node():x(),y(){} // 空构造函数\n    Node(int xx, int yy):x(xx),y(yy){} // 带参构造函数\n};\n\nvoid bfs(int i, int j) {\n	queue<Node> q;\n	q.push(Node(i, j));\n	vis[i][j] = 1;\n	while (!q.empty()) {\n		area++;\n		Node now = q.front();\n		q.pop();\n		for (int k = 0; k < 4; k++) {\n			int x = now.x + dir[k][0];\n			int y = now.y + dir[k][1];\n			if (x >= 0 && y >= 0 && x < n && y < n && !vis[x][y] && a[x][y]) {\n				vis[x][y] = 1;\n				q.push(Node(x, y));\n			}\n		}\n	}\n}\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		ans = 0;\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				scanf(\"%d\", &a[i][j]);\n			}\n		}\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				if (a[i][j] && !vis[i][j]) {\n					area = 0;\n					bfs(i, j);\n					ans = max(area, ans);\n				}\n			}\n		}\n		printf(\"%d\\n\", ans);\n	}\n	return 0;\n}\n```\n\n## [问题 J: 数列分段](https://acm.webturing.com/problem.php?cid=1323&pid=9&langmask=262141&puzzle_mask=0)\n\n**题目描述** \n\n有n个整数，分成m段。使每一段的和的最小值尽可能的大。\n\n**输入**\n\n第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有两个整数n，m，接下来一行是n个整数。其中T<=50,n,m<1e5 。\n\n**输出**\n尽可能的大的每一段的和的最小值。\n\n**样例输入**\n\n```c++\n1\n5 3\n4 5 4 5 1\n```\n\n**样例输出**\n\n```c++\n4\n```\n\n**解题思路：** 二分，最大化最小值\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nint T, n, m;\nint a[maxn];\n\nint check(int k) {\n	int num = 0, sum = 0;\n	for (int i = 1; i <= n; i++) {\n		if (sum + a[i] >= k) {\n			num++;\n			sum = 0;\n		} else {\n			sum += a[i];\n		}\n	} \n	if (num >= m) {\n		return 1;\n	}\n	return 0;\n}\n\nint main() {\n	scanf(\"%d\", &T);\n	while (T--) {\n		int r = 0;\n		int l = 0x3f3f3f3f;\n		int ans = 0;\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n			r += a[i];\n			l = min(l, a[i]);\n		}\n		while (l <= r) {\n			int mid = (l + r) >> 1;\n			if (check(mid)) {\n				ans = mid;\n				l = mid + 1;\n			} else {\n				r = mid - 1;\n			}\n		}\n		printf(\"%d\\n\", ans);\n	}\n	return 0;\n}\n```\n\n## [问题 K: 数数字](https://acm.webturing.com/problem.php?cid=1323&pid=10&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\nAlice和Bob进行一款质数游戏，Alice先说一个质数或者1，Bob再加上一个质数或者1。不能超过目标数字，谁先喊道目标数字就获胜。Alice和Bob都足够聪明，都会采用最优策略。\n\n**输入**\n\n第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有一个整数n，代表目标数字。\n\nT<=20,n<1e18\n\n**输出**\n\n共T行，输出Alice win或者Bob win。\n\n**样例输入**\n\n```c++\n2\n4\n6\n```\n\n**样例输出**\n\n```c++\nBob win\nAlice win\n```\n\n**解题思路：** 首先，我们需要知道一个定理：**一切大于2的质数，一定是形如4n+1或4n-1的数。**\n\n由于我们每次给的数可以是1，2，3+（大于2的）质数。那么无论谁先讲，后手的一定可以加成4n。所以说，只\n\n要给的数能够被4整除，Bob必胜。反之，Alice必胜。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	int T, n;\n	scanf(\"%d\", &T);\n	while (T--) {\n		scanf(\"%d\", &n);\n		if (n % 4 == 0) {\n			printf(\"Bob win\\n\");\n		} else {\n			printf(\"Alice win\\n\");\n		}\n	}\n	return 0;\n}\n```\n\n**参考链接：**[https://blog.csdn.net/weixin_43773540/article/details/104943915](https://blog.csdn.net/weixin_43773540/article/details/104943915)', '2021-05-14 22:14:02', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (54, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621084758493.jpg', '2021校赛题解', '## [知识竞赛](http://210.45.175.76/home/problem.php?cid=1059&pid=0)\n\n**问题描述**\n\n最近学校组织了党史知识竞答比赛，比赛采用扣分制方法评分，即扣分越高，名次越低。当比赛结束时，要在现场按照选手的出场顺序宣布最后扣分和最后名次，扣除相同分数的选手具有相同的名次，名次连续编号，不用考虑同名次的选手人数。 例如： 选手序号：1 2 3 4 5 6 选手扣分：5 3 4 7 3 5 输出名次：3 1 2 4 1 3\n\n**输入描述**\n\n共N+1行，第一行为选手的个数N（1 < N ≤ 50），下面N行按选手序号给出每个选手的扣分，扣分在0~100之间，其中第i行表示序号为i-1的选手的扣分。\n\n**输出描述**\n\nN行，按序号给出每个选手的名次，第i行表示序号为i的选手的名次。\n\n**样例输入**\n\n```c++\n6\n5\n3\n4\n7\n3\n5\n```\n\n**样例输出**\n\n```c++\n3\n1\n2\n4\n1\n3\n```\n\n**解题思路**\n\n用结构体把扣分情况和序号绑定在一起，先按扣分情况从小到大排序，按扣分情况得出具体排名后再按序号从小到大排序，再输出即可。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n	int id, score, rank;\n} Stu[51];\n\nbool cmp(Node a, Node b) {    //按扣分从小到大排 \n	return a.score < b.score;  \n}\n\nbool cmp2(Node a, Node b) {   //按序号从小到大排 \n	return a.id < b.id;\n}\n\nint main() {\n	int n;\n	cin>>n;\n	for (int i = 0; i < n; i++) {\n		Stu[i].id = i;\n		cin>>Stu[i].score;\n	}\n	sort(Stu, Stu + n, cmp);        //按扣分情况从小到大排序 \n	int pre = Stu[0].score;\n	int rank = 1;\n	Stu[0].rank = 1;\n	for (int i = 1; i < n; i++) {	//如果用相同的扣分则使其排名相同 \n		if (pre == Stu[i].score) {\n			Stu[i].rank = rank;\n		} else {\n			Stu[i].rank = ++rank;\n			pre = Stu[i].score;\n		}\n	}\n	sort(Stu, Stu + n, cmp2);       //按序号从小到大排序 \n	for (int i = 0; i < n; i++) {\n		cout<<Stu[i].rank<<endl;\n	}\n	return 0;\n}\n\n-----------------------------------------------------------------------\n/*\n	方法二，用一个大小 101的数组，记录分数的排名，分数是下标，值是排名，再求前缀和即可\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, s;\nint rk[101];\nint score[51];\n\nint main() {\n	std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    \n	cin>>n;\n	for (int i = 0; i < n; i++) {\n		cin>>score[i];\n		rk[score[i]] = 1;\n	}\n	for (int i = 1; i < 101; i++) {\n		rk[i] += rk[i - 1];\n	}\n	for (int i = 0; i < n; i++) {\n		if (rk[score[i]]) {\n			cout<<rk[score[i]]<<endl;\n		}\n	}\n	return 0;\n}\n```\n\n## [螺旋拐弯](http://210.45.175.76/home/problem.php?cid=1059&pid=1)\n\n**问题描述**\n\n螺旋拐弯是由数字和连线按照顺时针方向画出的图形，如下图所示： 在拐弯时不能与已画出的图形发生碰撞，并且能拐弯时就一定要拐。由图可知，前4次拐弯分别发生在数字2、3、5、7这4个位置。 输入N，计算第N次拐弯发生在哪个数字处？\n\n**输入描述**\n\n输入只有一行，包括一个整数N (1 ≤ N ≤ 10000)\n\n**输出描述**\n\n输出第N个弯处的数字。\n\n**样例输入**\n\n```c++\n5                 \n```\n\n**样例输出**\n\n```c++\n10\n```\n\n直接根据图中拐弯处的数值求出规律，然后根据规律求出第n个拐弯处的值。规律为每两个拐弯处的相差的值为一个定值，后两个拐弯处的数相差的值比前两个拐弯处相差的值多1。如：前两个为1->2,2->3。后两个为3->5,5->7。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	int n;\n	cin>>n;\n	\n	int x = 1;\n	int step = 1;					//统计每两个拐弯处相差的个数 \n	int cnt = 0;					//统计拐弯处的个数 \n	for (int i = 0; i < n; i++) {	\n		if (cnt == 2) {				//每处理了两个拐弯处后使个数加一且cnt重新计数。 \n			cnt = 0;\n			step += 1;\n		}\n		x += step;\n		cnt++;\n	}\n	cout<<x<<endl;\n	return 0;\n}\n```\n\n## [文件加密](http://210.45.175.76/home/problem.php?cid=1059&pid=2)\n\n**问题描述**\n\n为了提高信息传输的安全性，我们常常需要对信息进行加密。人们发明了各种各样的加密方式，其中一种方式是，对文中单词进行逆序处理。请你写一个程序，对输入的已加密的文本进行解密。\n\n**输入描述**\n\n第一行是一个正整数N(1 ≤ N ≤ 1000)，表示后面将有N行已加密的信息。接下来的N行，每行一个不超过1000个字符的字符串，每个字符串中只有英文小写字母和空格组成。注意：可以有空行（即该行无字符出现）和空格行。\n\n**输出描述**\n\n共N行，每行对应输出解密后的文本。\n\n**样例输入**\n\n```c++\n2\ni ekil siht emag\n eno  owt   eerht               \n```\n\n**样例输出**\n\n```c++\ni like this game\n one  two   three               \n```\n\n把每个单词反转即可，注意空格。设置两个指针 l, r，l位单词的开始位置，r位单词的结束位置\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring str;\nchar cs[1005];\n\nvoid reverse(char cs[], int i, int j) {\n    while (i < j) {\n        char c = cs[i];\n        cs[i] = cs[j];\n        cs[j] = c;\n        i++;\n        j--;\n    }\n}\n\nint main() {\n	int j = 0;\n	cin>>n;\n	getchar();\n	for (int i = 0; i < n; i++) {\n		// 这种方式可以输入空格 \n		getline(cin, str);\n		int len = str.length();\n		// 转化成字符数组便于反转 \n		for (j = 0; j <= len; j++) {\n			cs[j] = str[j];\n		}\n		cs[j] = \'\\0\';\n		int l = 0, r = 0;\n		// 先忽略前面的空格 \n		while (cs[l] == \' \' && l < len) {\n			l++;\n			r++;\n		}\n        while (l < len) {\n        	// 单词刚好结束的结束 \n            if (cs[r] == \' \' && cs[r - 1] != \' \') {\n                reverse(cs, l, r - 1);\n                r++;\n                l = r;\n                // l移动到非空格位置，即下一个单词的开始位置 \n                while (cs[l] == \' \') {\n                	l++;\n				}\n            }\n            if (r == len - 1) {\n                reverse(cs, l, r);\n                break;\n            }\n            r++;\n        }\n        cout<<cs;\n        if (i != n - 1) {\n        	cout<<endl; \n		}\n	}\n	return 0;\n}\n```\n\n## [化简比例](http://210.45.175.76/home/problem.php?cid=1059&pid=3)\n\n**问题描述**\n\n在互联网时代，我们经常会在网上看到有针对某个人或某个观点进行投票进行民意调查，投票的结果有若干人赞成，也会有若干人反对。比如，对某一观点表示赞成的有1498人，反对的有902人，则赞同与反对的比例可以简单记为1498:902。 一般情况下，直接把调查结果以实际的比例呈现出来，往往这个比例的数值太大，难以一眼看出它们的关系，大多数民众也不会满意。对上面的例子，如果把赞同与反对的比例记为5:3，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时看起来也比较直观。 现给出赞成人数X，反对人数Y，以及一个上界L，请你编程实现将X:Y化简为X’:Y’，要求在X’和Y’均不大于L且X’与Y’互质（即两个整数的最大公约数是1）的前提下，X/Y≤X’/Y’且X’/Y’-X/Y的值尽可能小。\n\n**输入描述**\n\n输入共一行，包含三个整数X、Y和L（1 ≤ X ≤ 1000000，1 ≤ Y ≤ 1000000，1 ≤ L ≤ 100），每两个整数之间用一个空格隔开，分别表示赞成人数、反对人数和上界。\n\n**输出描述**\n\n输出共一行，包含两个整数X’和Y’，中间用一个空格隔开，表示化简后比例。\n\n**样例输入**\n\n```c++\n1498 902 10                 \n```\n\n**样例输出**\n\n```c++\n5 3     \n```\n\n暴力，直接根据给定L的范围，依次尝试，与X/Y最接近的就是答案\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	double a, b, l, x, y;\n	cin>>a>>b>>l;\n	double min = 1000000.0, t, k = 1.0*a/b; // k算出a和b的比值作为精确度。 \n	for (int i = 1; i <= l; i++) {      \n		for (int j = 1; j <= l; j++) {         \n			t = 1.0*i/j - k;			  // t为每次两个数的比值与精确度相差的大小。 \n             // 如果 这次t比上次的小，证明这次的精确度更高，保留此次数据。 \n			if (t < min && t >= 0) {		  \n				x = i;\n				y = j;\n				min = t;\n			}\n		}\n	}\n	cout<<x<<\" \"<<y<<endl;\n	return 0; \n}\n```\n\n## [布匹裁剪](http://210.45.175.76/home/problem.php?cid=1059&pid=4)\n\n**问题描述**\n\n布厂有一批布匹，现在想把这些布匹裁剪成一些长度相同的小段布料（布料有可能有剩余），需要得到的小段的数目是给定的。当然，我们希望得到的小段布料越长越好，你的任务是计算能够得到的小段布料的最大长度。布料长度的单位是cm。布匹的长度都是正整数，我们要求切割得到的小段布料的长度也是正整数。 例如有两段布匹长度分别为11和23，要求切割成到等长的6段，很明显能切割出来的小段布料长度最长为5。\n\n**输入描述**\n\n第一行是两个正整数N和K(1 ≤ N ≤ 100000，1 ≤ K ≤ 100000000)，N是布匹的数目，K是需要得到的小段的数目。接下来的N行，每行有一个1到100000000之间的正整数，表示一段布匹的长度。\n\n**输出描述**\n\n能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。\n\n**样例输入**\n\n```c++\n3 7\n232\n124\n456        \n```\n\n**样例输出**\n\n```c++\n114\n```\n\n算出一个布段的取值范围，再使用二分慢慢的逼近符合情况的最大值。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100001;\nint a[maxn];\nint k;\nint n;\n\nint check(long long len) {        // 算出当前长度能剪出的布段数量，与所需的布段数量k比较 \n	long long num = 0;\n	for (int i = 0; i < n; i++) {\n		num += a[i] / len;   \n	}\n	if (num >= k) {              //若大于k返回1，小于k返回0 \n		return 1;\n	}\n	return 0;\n}\n\nint main() {\n	cin>>n>>k;                      \n	int l = 100000001;\n	long long r = 0;\n	for (int i = 0; i < n; i++) {\n		scanf(\"%d\", &a[i]);           \n		r += a[i];               // r为布段总长度       \n		l = min(l, a[i]);        // l为最小的布段长度     \n	}\n     // 因为布段最小为1cm，所以当布段总长小于需要的布段数时，切不出来，输出0 \n	if (r < k) {                \n		printf(\"0\\n\");\n		return 0;\n	}\n	l = l / k;  				 //二分的最小值	\n	r = r / k;					 //二分的最大值	\n	if (r == 1) {				 //特殊情况单独讨论，不然后面二分会出现除数为0\n		printf(\"1\\n\");\n		return 0;\n	}\n	int ans = 0;\n	while (l <= r) {             //使用二分慢慢逼近最大长度 \n		long long mid = (l + r) >> 1; \n		if (check(mid)) {		 				\n			ans = mid;   \n			l = mid + 1; 		 \n		} else {\n			r = mid - 1;\n		}\n	}\n	printf(\"%d\\n\", ans);\n	return 0;\n}\n```\n\n## [蝈蝈赛马](http://210.45.175.76/home/problem.php?cid=1059&pid=5)\n\n**问题描述**\n\n卢宝嚣张着要和蝈蝈赛马，并且为了增加难度，卢宝在自己的每匹马上都设置了一个币值，如果卢宝这匹马赢了，那么蝈蝈就要付给卢宝相应的币，同样的，如果蝈蝈赢了卢宝这匹马，卢宝也要给蝈蝈相应的币。每匹马还有一个速度值，速度快的马会获得胜利，速度相同则平局，平局的话蝈蝈也要付给卢宝币。现在卢宝已经安排好了马的上场顺序，以及按照顺序的每匹马的币值。蝈蝈想知道，该怎么安排自己的上场顺序，才能赢得最多的钱或者怎样才能输最少的钱？（如果最后是输钱就输出负数）\n\n**输入描述**\n\n第一行一个t，代表t组数据（1 ≤ t ≤ 10），每种数据包含四行： 第一行为一个整数n，代表马的数量（1 ≤ n ≤ 1000） 第二行n个数a[i]，代表卢宝各匹马的速度，并且这就是卢宝的上场顺序（1 ≤ a[i] ≤ 100000） 第三行n个数b[i]，代表卢宝各匹马的币值，与速度值一一对应（1 ≤ b[i] ≤ 10000） 第四行n个数c[i]，代表蝈蝈各匹马的速度（1 ≤ c[i] ≤ 100000）\n\n**输出描述**\n\n每组数据输出一行一个整数，表示蝈蝈可以赢的最多的币（输出非负数），或者输的最少的币（输出负数）。\n\n**样例输入**\n\n```c++\n2\n3\n40 30 20\n1 2 3\n20 30 50\n5\n25 25 50 60 10\n10 50 5 100 30\n70 5 30 25 40                 \n```\n\n**样例输出**\n\n```c++\n4\n185\n```\n\n贪心算法，把卢宝的马按金钱从大到小排，蝈蝈的马按速度从大到小排，然后从前往后依次拿出卢宝的马，再从后向前拿蝈蝈的马比较速度，这样就能保证蝈蝈速度比卢宝大的马都是正好比他大的。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\n\nstruct Node {					//卢宝的马 \n	int speed, money;\n} Ho[maxn];\n\nint b[maxn];                    //蝈蝈的马 \nint t, n;\n\nbool cmp1(Node a, Node b) {     //按金钱从大到小排序 \n	return a.money > b.money;\n}\n\nbool cmp2(int a, int b) {		//从大到小排序 \n	return a > b;\n}\n\nint  vis[maxn];                //蝈蝈的马的标记数组 \n\nint main() {\n	cin>>t;\n	for (int i = 0; i < t; i++) {\n		cin>>n;\n		for (int j = 0; j < n; j++) {\n			cin>>Ho[j].speed;\n		}\n		for (int j = 0; j < n; j++) {\n			cin>>Ho[j].money;\n		}\n		for (int j = 0; j < n; j++) {\n			cin>>b[j];\n		}\n		sort(Ho, Ho + n, cmp1); //让卢宝的马按金钱从大到小排序 \n		sort(b, b + n, cmp2);   //让蝈蝈的马按速度从大到小排序 \n		int sum = 0;\n		memset(vis, 0, sizeof(vis));//每一组数据都要初始化标记数组 \n		int len = n - 1;			  //蝈蝈的马的数组的下标，因为从0开始所以先减一 \n		for (int j = 0; j < n; j++) {\n			int flag = 0;             //标记，若找到了为1，为找到为0\n			for (int k = len; k >= 0; k--) {  //从后往前找蝈蝈的马，找到比卢宝马速度大的最小值。 \n				if (b[k] > Ho[j].speed && !vis[k]) {//找到了后标记flag且加上相应的金钱 \n					sum += Ho[j].money;\n					vis[k] = 1;\n					flag = 1;\n					break;\n				}\n			}\n			if (!flag) {					//未找到则减去相应的金钱 \n				// vis[len--] = 1;	\n				sum -= Ho[j].money;\n			}\n		}\n		cout<<sum<<endl;\n	}\n	return 0;\n}\n```\n\n## [笔迹鉴别](http://210.45.175.76/home/problem.php?cid=1059&pid=6)\n\n**问题描述**\n\n最近柯南收到了一则来自怪盗基德的预告函，上面写着：“今晚8点，我将前来取走‘命运的宝石’”。然而上一周怪盗基德也发出了一张预告函，写着：“在10周年纪念之时，我将取走 the 8148”。柯南感到很奇怪，因为怪盗基德很少如此频繁地连续作案。于是他仔细比对这两封预告函。柯南发现，上一周的预告函中出现了两次“8”，这次预告函也有一个“8”，但是笔迹并不相同。如图所示，左边两个“8”字均来源于上一周的预告函，右上角留了一个开口；而右边的“8”字来源于本周的预告函，右上角是闭合的。 真 真 假 因此，柯南判断，这次收到的预告函并不是真正的怪盗基德发出的，而是一封伪造的预告函。最终，柯南抓住了伪造预告函的假基德。 现在，请聪明的你也来鉴别一下笔迹图像，判别这些“8”字笔迹的真伪。\n\n**输入描述**\n\n首先是一个正整数T（T ≤ 10），表示数据组数。对于每一组数据： 第一行，两个正整数m和n（m，n ≤ 1000）分别表示图像的高和宽。接下来有m行，每行，每n个字符，只可能为0 或者1。0表示黑色字迹，1表示白色背景。数据保证每张图像为白底黑字，且含有唯一一个完整的“8”字，不会有缺失，也不存在空白图像或者含有其它内容的数据。 注意，“8”字有可能是歪的或者倒过来的。\n\n**输出描述**\n\n对于每一组数据，输出Yes或No，代表笔迹真伪。\n\n**样例输入**\n\n```c++\n1\n9 8\n1 1 1 1 1 1 1 1 \n1 1 1 0 0 1 1 1 \n1 1 0 1 1 0 1 1 \n1 1 0 0 1 0 1 1 \n1 1 1 0 0 1 1 1 \n1 1 0 1 1 0 1 1 \n1 1 0 1 1 0 1 1 \n1 1 1 0 0 1 1 1 \n1 1 1 1 1 1 1 1                \n```\n\n**样例输出**\n\n```c++\nNo\n```\n\n此题使用深搜解决，如果8的右上角有开口，则只有两个封闭的区域，如果没有封口，则有三个封闭的区域。为了避免数字8可能与矩阵边缘接触（会导致划分的封闭区域不确定），在矩阵外围包上一层1。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint a[1005][1005];\nint cnt, flag;\nint t, m, n;\nint dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};  //上下左右四种情况 \nint vis[1005][1005]; //标记数组 \n\nvoid dfs(int x, int y) {\n	vis[x][y] = 1;                //走过了此处就标记为1 \n	for (int i = 0; i < 4; i++) {\n		int xx = x + dir[i][0];\n		int yy = y + dir[i][1];\n		if (a[xx][yy] == 1 && xx >= 0 && xx <= m + 1 && yy >= 0 && yy <= n + 1 && !vis[xx][yy]) {\n			dfs(xx, yy);\n		}\n	}\n}\n\nint main() {\n	cin>>t;\n	for (int i = 0; i < t; i++) {\n		cin>>m>>n;\n		cnt = 0;\n		memset(vis, 0, sizeof(vis));  //每一组数据都要重新初始化标记数组 \n		for (int j = 1; j <= m; j++) { //将图像从（1，1）开始输入，防止图像出现在边上 \n			for (int k = 1; k <= n; k++) {\n				cin>>a[j][k];\n			}\n		}\n		for (int j = 0; j <= n + 1; j++) { //将最外围一圈赋值为1 \n			a[0][j] = 1;\n			a[m + 1][j] = 1;\n		}\n		for (int j = 0; j <= m + 1; j++) {\n			a[j][0] = 1;\n			a[j][n + 1] = 1;\n		}\n		for (int j = 0; j <= m + 1; j++) {\n			for (int k = 0; k <= n + 1; k++) {\n				if (a[j][k] == 1 && !vis[j][k]) { //如果此处为1且没被走过则开始深搜 \n					dfs(j, k);    \n					cnt++;                        //记录下能深搜区域的个数。 \n				}\n			}\n		}\n		if (cnt == 2) {                           //区域的个数为2则为yes,否则为no \n			cout<<\"Yes\"<<endl;\n		} else {\n			cout<<\"No\"<<endl;\n		}\n	}\n	return 0;\n}\n```\n\n## [减肥](http://210.45.175.76/home/problem.php?cid=1059&pid=7)\n\n**问题描述**\n\n已知在接下来的几天里赛文斯要吃n顿饭，第i顿饭要吃ai的食物，现在赛文斯想减肥，想要节食，所以他有时会不吃饭，但是赛文斯不能连续两顿不吃饭。所以他想知道，在保证不能连续两顿不吃饭前提下，这n顿中，他最少要吃多少食物。\n\n**输入描述**\n\n第一行是一个整数n，代表接下来有n顿饭（n ≤ 100,000） 第二行有n个数字，a1,a2,……an,代表第i顿饭要吃ai的食物（1 ≤ ai ≤ 100）\n\n**输出描述**\n\n输出一个整数，代表赛文斯最少要吃多少食物。\n\n**样例输入**\n\n```c++\n5\n3 40 1 6 100                  \n```\n\n**样例输出**\n\n```c++\n10\n```\n\n动规，两个状态，吃饭和没吃饭\n\ndp0[i]：表示第 i 天没有吃饭时的最小食物\n\ndp1[i]:   表示第 i 天吃饭时的最小食物\n\n状态转移方程：\n\n**dp0[i] = dp1[i - 1];**\n\n**dp1[i] = min(dp0[i - 1] + a[i], dp1[i - 1] + a[i]);**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\nint n;\nint a[maxn];\nint dp0[maxn]; // 当天没有吃饭 \nint dp1[maxn]; // 当天吃饭 \n\nint main() {\n	cin>>n;\n	for (int i = 0; i < n; i++) {\n		cin>>a[i];\n	}\n	dp0[0] = 0;\n	dp1[0] = a[0];\n	for (int i = 1; i < n; i++) {\n		// 今天没吃饭，昨天必须吃饭 \n		dp0[i] = dp1[i - 1];\n		// 今天吃饭，昨天可以吃饭，也可以不吃饭，取最小值 \n		dp1[i] = min(dp0[i - 1] + a[i], dp1[i - 1] + a[i]);\n	}\n	cout<<min(dp0[n - 1], dp1[n - 1])<<endl;\n	return 0; \n}\n\n----------------------------------------------------------------------------------\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\nint n;\nint a[maxn];\n\nint main() {\n	cin>>n;\n	for (int i = 0; i < n; i++) {\n		cin>>a[i];\n	}\n	int dp0 = 0;            //第一天不吃 \n	int dp1 = a[0];			//第一天吃 \n	for (int i = 1; i < n; i++) {\n		int temp = dp1;     //因为可以空一天不吃，记录下dp1的值 \n		dp1 = min(dp0 + a[i], dp1 + a[i]); //求出前一天吃和前一天不吃性价比最高的选择 \n		dp0 = temp;         //dp0为这一天不吃的值。 \n	}\n	cout<<min(dp0, dp1)<<endl;  //输出两者的最小值 \n	return 0; \n} \n```\n\n## [最大收益](http://210.45.175.76/home/problem.php?cid=1059&pid=8)\n\n**问题描述**\n\n商店里有n种商品和k个按顺序给出的订单。每种商品给定名称、收益和库存。每个订单给出需求商品和需求数量。编程判断是否能依序满足所有的订单，如果可以，输出收益；否则，输出“-X\"，X表示第一个无法满足的订单编号。\n\n**输入描述**\n\n第1行2个整数n和k, k ≤ n ≤ 10^5。 下面的n行，每行表示一种商品的名称、收益和库存3种信息。 再下面的若干行，每行表示一个订单的需求商品和需求数量两种信息。每种商品的个数保证在int范围内，保证每个订单中都不会出现没有的商品，商品名的长度≤ 20，具体格式参见输入样例。\n\n**输出描述**\n\n一行一个整数，表示收益，或者\"-X\"，X表示第一个无法满足的订单编号。\n\n**样例输入**\n\n```c++\n3 5\napple 1 100\npear 5 90\nfootball 30 10\npear 24\napple 18\nfootball 4\npear 1\nfootball 6            \n```\n\n**样例输出**\n\n```c++\n443                  \n```\n\n依次将订单编号的需求与对应商品的库存比较即可。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\n\nstruct Node {   //将商品价值和库存放在一个结构体中 \n	int val;\n	int num;\n} P[maxn];\n\nint main() {\n	int n, k;\n	string name;\n	map<string, Node> pmap;	//定义一个一对一的映射，每个商品的名字和他的价值和库存一对一对应。 \n	cin>>n>>k;\n	for (int i = 0; i < n; i++) {\n		cin>>name>>P[i].val>>P[i].num;\n		pmap.insert(make_pair(name, P[i]));\n	}\n	int cnt;\n	long long sum = 0;\n	for (int i = 0; i < k; i++) {\n		cin>>name>>cnt;\n		Node p = pmap[name];  //调出名称为name的映射结构体。 \n		if (p.num >= cnt) {   //如果库存够的话则计算收益，且刷新库存 \n			sum += cnt * p.val;\n			p.num -= cnt;\n			pmap[name] = p;\n		} else {              //如果库存不够的话则输出-X（X为订单编号） \n			cout<<\"-\"<<i + 1<<endl;\n			return 0;\n		}\n	}\n	cout<<sum<<endl;\n	return 0;\n}\n```\n\n## [穿越侏罗纪](http://210.45.175.76/home/problem.php?cid=1059&pid=9)\n\n**问题描述**\n\n小明来到侏罗纪公园游玩，他对穿越侏罗纪这个虚拟现实的游戏很感兴趣。该游戏在一处开阔的平地上，平地面积为n×n。最开始，小明站在起点处(1,1)，最终赢得游戏要达到终点(n,n)，小明每秒可以向东南西北四个方向移动一步。但是该游戏的难度在于，每秒结束时，天上会掉落一块陨石在(x,y)处，小明不能走在陨石上。假如小明已经知道哪些时刻会在哪些点掉落陨石。所以现在你需要判断，小明能否成功走到(n,n)。 保证数据足够弱：也就是说，无需考虑“走到某处被一块陨石砸死”的情况，因为答案不会出现此类情况。\n\n**输入描述**\n\n首先是一个正整数T（T ≤ 10），表示数据组数。对于每一组数据： 第一行，一个正整数n（n ≤ 1000）。 接下来2n-2行，每行两个正整数x和y，意义是在那一秒结束后，(x,y)将被出现一块陨石。\n\n**输出描述**\n\n对于每一组数据，输出Yes或No，回答小明能否顺利走到终点。\n\n**样例输入**\n\n```c++\n2\n2\n1 1\n2 2\n5\n3 3\n3 2\n3 1\n1 2\n1 3\n1 4\n1 5\n2 2                  \n```\n\n**样例输出**\n\n```c++\nYes\nYes\n```\n\n**思路一**\n\nBFS，输入时，用数组把每秒对应的路障的位置记录下来，索引是秒，值是坐标。在搜索的过程中，每秒结束后，把该秒对应的路障标记出来。（tx[i]，ty[i]，i 是秒，tx[i] 、ty[i] 是坐标）\n\n**思路二**\n\nBFS，输入时，用 一个二维数组把路障出现的秒记录下来，搜索时，若该坐标有路障，则比较时间判断是否可以进入。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1005;\n\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nint vis[maxn][maxn];\nint t, n, flag;\nint tx[2*maxn], ty[2*maxn];\n\nstruct Node {\n	int x, y, time;\n	Node():x(),y(),time(){} // 空构造函数\n    Node(int x, int y, int time):x(x),y(y),time(time){} // 带参构造函数\n}; \n\nvoid bfs(int i, int j) {\n	queue<Node> q;\n	q.push(Node(i, j, 1));\n	vis[i][j] = 1;\n	while (!q.empty()) {\n		Node now = q.front();\n		q.pop();\n		if (now.x == n && now.y == n) {\n			flag = 1;\n			return;\n		}\n		vis[tx[now.time-1]][ty[now.time-1]] = 1;\n		for (int k = 0; k < 4; k++) {\n			int x = now.x + dir[k][0];\n			int y = now.y + dir[k][1];\n			if (x >= 1 && y >= 1 && x <= n && y <= n && !vis[x][y]) {\n				vis[x][y] = 1;\n				q.push(Node(x, y, now.time + 1));\n			}\n		}\n	}\n}\n\nint main() {\n	int x, y;\n	cin>>t;\n	for (int i = 0; i < t; i++) {\n		memset(vis, 0, sizeof(vis));\n		memset(tx, 0, sizeof(tx));\n		memset(ty, 0, sizeof(ty));\n		flag = 0;\n		cin>>n;\n		for (int j = 1; j <= 2 * n - 2; j++) {\n			cin>>tx[j]>>ty[j];\n		}\n		bfs(1, 1); \n		if (flag) {\n			cout<<\"Yes\"<<endl;\n		} else {\n			cout<<\"No\"<<endl;\n		}\n	}\n	return 0;\n}\n\n--------------------------------------------------------------------------------------\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1005;\n\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nint vis[maxn][maxn];\nint t, n, flag;\nint tt[maxn][maxn];\n\nstruct Node {\n	int x, y, time;\n	Node():x(),y(),time(){} // 空构造函数\n    Node(int x, int y, int time):x(x),y(y),time(time){} // 带参构造函数\n}; \n\nvoid bfs(int i, int j) {\n	queue<Node> q;\n	q.push(Node(i, j, 1));\n	vis[i][j] = 1;\n	while (!q.empty()) {\n		Node now = q.front();\n		q.pop();\n		if (now.x == n && now.y == n) {\n			flag = 1;\n			return;\n		}\n		for (int k = 0; k < 4; k++) {\n			int x = now.x + dir[k][0];\n			int y = now.y + dir[k][1];\n			if (x >= 1 && y >= 1 && x <= n && y <= n && !vis[x][y] && (!tt[x][y] || tt[x][y] >= now.time)) {\n				vis[x][y] = 1;\n				q.push(Node(x, y, now.time + 1));\n			}\n		}\n	}\n}\n\nint main() {\n	int x, y;\n	cin>>t;\n	for (int i = 0; i < t; i++) {\n		memset(vis, 0, sizeof(vis));\n		memset(tt, 0, sizeof(tt));\n		flag = 0;\n		cin>>n;\n		for (int j = 1; j <= 2 * n - 2; j++) {\n			cin>>x>>y;\n			tt[x][y] = j;\n		}\n		bfs(1, 1); \n		if (flag) {\n			cout<<\"Yes\"<<endl;\n		} else {\n			cout<<\"No\"<<endl;\n		}\n	}\n	return 0;\n}\n```\n\n', '2021-05-15 21:19:25', '2021-05-15 21:20:36', 0, 0, 0);
INSERT INTO `tb_article` VALUES (55, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621154837870.jpg', '线段树刷题记录', '### [HDU-1166 敌兵布阵](http://acm.hdu.edu.cn/showproblem.php?pid=1166): 区间求和、单点修改、区间查询\n\n**Problem Description**\n\nC国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。\n中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:\"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：\"我知错了。。。\"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.\n\n**Input**\n\n第一行一个整数T，表示有T组数据。\n每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。\n接下来每行有一条命令，命令有4种形式：\n(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）\n(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;\n(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数;\n(4)End 表示结束，这条命令在每组数据最后出现;\n每组数据最多有40000条命令\n\n**Output**\n\n对第i组数据,首先输出“Case i:”和回车,\n对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。\n\n**Sample Input**\n\n```C++\n1\n10\n1 2 3 4 5 6 7 8 9 10\nQuery 1 3\nAdd 3 6\nQuery 2 7\nSub 10 2\nAdd 6 3\nQuery 3 10\nEnd \n```\n\n**Sample Output**\n\n```c++\nCase 1:\n6\n33\n59\n```\n\n **题解**：模板题\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 50005;\nint a[maxn], t[maxn<<2];\nint ans, T, n;\n\nvoid pushup(int i) {\n	t[i] = t[i<<1] + t[i<<1|1];\n}\n\nvoid build(int left, int right, int index) {\n	if (left == right) {\n		t[index] = a[left];\n		return;\n	}\n	int mid = left + ((right - left) >> 1);\n	build(left, mid, index<<1);\n	build(mid + 1, right, index<<1|1);\n	pushup(index);\n}\n\nvoid update(int p, int v, int left, int right, int index) {\n	if (left == right) {\n		t[index] += v;\n	} else {\n		int mid = left + ((right - left) >> 1);\n		if (p <= mid) {\n			update(p, v, left, mid, index << 1);\n		} else {\n			update(p, v, mid + 1, right, index<<1|1);\n		}\n		pushup(index);\n	}\n}\n\nint query(int index, int L, int R, int l, int r) {\n	if (l >= L && r <= R) {\n		return t[index];\n	}\n	int s = 0;\n	int mid = l + ((r - l) >> 1);\n	if (L <= mid) {\n		s += query(index<<1, L, R, l, mid);\n	} \n	if (R > mid) {\n		s += query(index<<1|1, L, R, mid + 1, r);\n	}\n	return s;\n}\n\nint main() {\n	int x, y;\n	scanf(\"%d\", &T);\n	for (int k = 1; k <= T; k++) {\n		printf(\"Case %d:\\n\", k);\n		cin>>n;\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n		}\n		build(1, n, 1);\n		char str[20];\n		while (scanf(\"%s\", str) && str[0] != \'E\') {\n			scanf(\"%d%d\", &x, &y);\n			if (str[0] == \'Q\') {\n				cout<<query(1, x, y, 1, n)<<endl;\n			}\n			if (str[0] == \'A\') {\n				update(x, y, 1, n, 1);\n			}\n			if (str[0] == \'S\') {\n				update(x, -y, 1, n, 1);\n			}\n		}\n	}\n	return 0;\n}\n```\n\n### [HDU-1754 I Hate It](http://acm.hdu.edu.cn/showproblem.php?pid=1754): 区间最值、单点修改、区间查询\n\n**Problem Description**\n\n很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。\n这让很多学生很反感。\n不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\n\n**Input**\n\n本题目包含多组测试，请处理到文件结束。\n在每个测试的第一行，有两个正整数 N 和 M ( 0<N<=200000,0<M<5000 )，分别代表学生的数目和操作的数目。\n学生ID编号分别从1编到N。\n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。\n接下来有M行。每一行有一个字符 C (只取\'Q\'或\'U\') ，和两个正整数A，B。\n当C为\'Q\'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。\n当C为\'U\'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。\n\n**Output**\n\n对于每一次询问操作，在一行里面输出最高成绩。\n\n**Sample Input**\n\n```C++\n5 6\n1 2 3 4 5\nQ 1 5\nU 3 6\nQ 3 4\nQ 4 5\nU 2 9\nQ 1 5\n```\n\n**Sample Output**\n\n```C++\n5\n6\n5\n9\n\nHint\nHuge input,the C function scanf() will work better than cin\n```\n\n**题解**：模板题\n\n```c++\n// 最值-单点更新，批量查询\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int INF = 1e8;\nconst int maxn = 2000005;\nint a[maxn], t[maxn<<2];\n\nvoid pushup(int i) {\n	t[i] = max(t[i<<1], t[i<<1|1]);\n}\n\nvoid build(int left, int right, int index) {\n	if (left == right) {\n		t[index] = a[left];\n		return;\n	}\n	int mid = left + ((right - left) >> 1);\n	build(left, mid, index<<1);\n	build(mid + 1, right, index<<1|1);\n	pushup(index);\n}\n\nvoid update(int p, int v, int left, int right, int index) {\n	if (left == right) {\n		t[index] = v;\n	} else {\n		int mid = left + ((right - left) >> 1);\n		if (p <= mid) {\n			update(p, v, left, mid, index << 1);\n		} else {\n			update(p, v, mid + 1, right, index<<1|1);\n		}\n		pushup(index);\n	}\n}\n\nint query(int index, int L, int R, int l, int r) {\n	if (l >= L && r <= R) {\n		return t[index];\n	}\n	int smax = -INF;\n	int mid = l + ((r - l) >> 1);\n	if (L <= mid) {\n		smax = max(smax, query(index<<1, L, R, l, mid));\n	} \n	if (R > mid) {\n		smax = max(smax, query(index<<1|1, L, R, mid + 1, r));\n	}\n	return smax;\n}\n\nint n, m;\nint main() {\n	while (~scanf(\"%d%d\", &n, &m)) {\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n		}\n		build(1, n, 1);\n		char c;\n		int x, y;\n		for (int i = 1; i <= m; i++) {\n			scanf(\" %c%d%d\", &c, &x, &y);\n			if (c == \'Q\') {\n				printf(\"%d\\n\", query(1, x, y, 1, n));\n			} else if (c == \'U\') {\n				update(x, y, 1, n, 1);\n			}\n		}\n	}\n	return 0;\n}\n```\n\n### [HDU-2795 Billboard](http://acm.hdu.edu.cn/showproblem.php?pid=2795): 区间最值、单点更新、区间查询\n\n**Problem Description**\n\nAt the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.\nOn September 1, the billboard was empty. One by one, the announcements started being put on the billboard.\nEach announcement is a stripe of paper of unit height. More specifically, the i-th announcement is a rectangle of size 1 * wi.\nWhen someone puts a new announcement on the billboard, she would always choose the topmost possible position for the announcement. Among all possible topmost positions she would always choose the leftmost one.\nIf there is no valid location for a new announcement, it is not put on the billboard (that\'s why some programming contests have no participants from this university).\nGiven the sizes of the billboard and the announcements, your task is to find the numbers of rows in which the announcements are placed.\n\n**Input**\n\nThere are multiple cases (no more than 40 cases).\nThe first line of the input file contains three integer numbers, h, w, and n (1 <= h,w <= 10^9; 1 <= n <= 200,000) - the dimensions of the billboard and the number of announcements.\nEach of the next n lines contains an integer number wi (1 <= wi <= 10^9) - the width of i-th announcement.\n\n**Output**\n\nFor each announcement (in the order they are given in the input file) output one number - the number of the row in which this announcement is placed. Rows are numbered from 1 to h, starting with the top row. If an announcement can\'t be put on the billboard, output \"-1\" for this announcement.\n\n**Sample Input**\n\n```C++\n3 5 5\n2\n4\n3\n3\n3\n```\n\n**Sample Output**\n\n```C++\n1\n2\n1\n3\n-1\n```\n\n**题解：**\n\n​        该题的大意就是在一块广告牌上张贴公告，广告牌有高宽限制，公告默认高度为1，输入广告牌的高度、宽度、公告的数量及每个公告的宽度，输出公告张贴的行号。（广告张贴高度优先，从高往低贴，高度一致，尽量贴左侧）\n\n​	用线段树的每个结点存储对应区间内最大的那一行的剩余宽度，只要维护好每个区间的最大值就行了。输入每一个公告的宽度，与树根比较，如果大于树根对应的最大宽度，直接输出-1，否则，与左子树比较，若比它小，就查询左子树，否则查询右子树。查询到之后再减去相应的宽度。\n\n​	如果广告牌的高度大于公告的数量时，即 h > n，令 h = n 。高出的部分没有意义。每行只能贴一个公告。\n\n```c++\n// 最值-单点更新、批量查询\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define maxn 200005\nint tree[maxn<<2]; //每个结点存储的是宽度的最大值，区间为高度的区间 \nint n, h, w, x;\n\nvoid pushup(int root) {\n	tree[root] = max(tree[root<<1], tree[root<<1|1]);\n}\n\nvoid build(int l, int r, int root) {\n    if (l == r) {\n        tree[root] = w; //初始高度均为w \n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(l, mid, root<<1);\n    build(mid + 1, r, root<<1|1);\n    pushup(root);\n}\n\nint query(int val, int l, int r, int root) {\n    if (l == r) { //查询到合适的高度 \n        tree[root] -= val; //对应的宽度减少val \n        return l; //返回行号 \n    }\n    int mid = (l + r) >> 1;\n    int ans;\n    if (tree[root<<1] >= val) { //如果左子树的宽度最大值大于val，则去左子树查询 \n    	ans = query(val, l, mid, root<<1);\n	} else { //否则，去右子树查询 \n		ans = query(val, mid + 1, r, root<<1|1);	\n	}  \n    pushup(root);\n    return ans;\n}\n\nint main() {\n    while (~scanf(\"%d%d%d\", &h, &w, &n)) {\n        if (h > n) { //如果高度超过了广告牌的个数，高度置为个数，每层只能放一个广告牌 \n        	h = n;	\n		}  \n        build(1, h, 1);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &x);\n            if (x > tree[1]) { //如果宽度大于最大宽度，则输出-1 \n            	printf(\"%d\\n\", -1);\n			} else { //否则，在线段树中查询 \n				printf(\"%d\\n\", query(x, 1, h, 1));\n			}     \n        }\n    }\n    return 0;\n}\n```\n\n### [POJ-2828 Buy Tickets](http://poj.org/problem?id=2828): 排队、区间求和、单点更新\n\n**Description**\n\n*Railway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…*\n\nThe Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.\n\nIt was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!\n\nPeople kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.\n\n**Input**\n\nThere will be several test cases in the input. Each test case consists of *N* + 1 lines where *N* (1 ≤ *N* ≤ 200,000) is given in the first line of the test case. The next *N* lines contain the pairs of values *Posi* and *Vali* in the increasing order of *i* (1 ≤ *i* ≤ *N*). For each *i*, the ranges and meanings of *Posi* and *Vali* are as follows:\n\n- *Posi* ∈ [0, *i* − 1] — The *i*-th person came to the queue and stood right behind the *Posi*-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.\n- *Vali* ∈ [0, 32767] — The *i*-th person was assigned the value *Vali*.\n\nThere no blank lines between test cases. Proceed to the end of input.\n\n**Output**\n\nFor each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.\n\n**Sample Input**\n\n```C++\n4\n0 77\n1 51\n1 33\n2 69\n4\n0 20523\n1 19243\n1 3890\n0 31492\n```\n\n**Sample Output**\n\n```C++\n77 33 69 51\n31492 20523 3890 19243\n```\n\n**Hint**  \n\n​      The figure below shows how the Little Cat found out the final order of people in the queue described in the first test case of the sample input.\n\n![img](http://poj.org/images/2828.gif)\n\n**题解：**\n\n​	题目大意，插队的问题，每个案例给出 n ，代表有 n 个插队的，每个给出 p, v，意思是代号为 v 的人插在了第 p 个人的后面，问最后的队伍的排列。\n\n​	一开始的队列是空的，如果输入i，j：代表代号为 j 的人插在代号为 i 的人的后面，也就是说他前面一定有了 i 个人，而他是第 i + 1 个人。\n\n​	所以从后往前推导，最后的人选定的位置是不会变的，同样，在第 i 个人后面插队，他的前面一定要留下 i 个空位。用线段树的每个结点存储对应区间的空位数的和。建树时叶子结点默认的空位为 1，每次输入 p 和 v 时，更新位数和为 p + 1 的结点，对应的位数和减 1，用数组记录对应的位置和序号。\n\n```c++\n// 排队，求和-单点更新 \n// 从后往前进行 \n#include<iostream>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nint sum[maxn<<2], b[maxn]; //sum中的每个结点存储对应区间中的空位数，b用来记录排队序列 \n\nstruct node {\n	int p;\n	int num;\n} a[maxn];\n\nvoid pushup(int i) {\n	sum[i] = sum[i<<1] + sum[i<<1|1];\n}\n\nvoid build(int l, int r, int i) {\n	if (l == r) {\n		sum[i] = 1;\n		return;\n	}\n	int mid = (l + r) >> 1;\n	build(l, mid, i<<1);\n	build(mid + 1, r, i<<1|1);\n	pushup(i);\n}\n\nvoid update(int p, int num, int l, int r, int i) {\n	if (l == r) {\n		sum[i]--;\n		b[l] = num;\n		return;\n	}\n	int mid = (l + r) >> 1;\n	if (sum[i<<1] >= p) {\n		update(p, num, l, mid, i<<1); \n	} else {\n	// p-sum[i<<1]，从后往前推导，在第p个人后插队，他的前面一定要有p个空位，所以要减去左边的空位数 \n		update(p - sum[i<<1], num, mid + 1, r, i<<1|1);\n	}\n	pushup(i);\n} \n\nint main() {\n	int n;\n	while (scanf(\"%d\", &n) != EOF) {\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d%d\", &a[i].p, &a[i].num);\n			a[i].p++; //开始把位置都加1，更新时只需找到sum为p的结点\n		}\n		build(1, n, 1);\n        // 从后往前推\n		for (int i = n; i > 0; i--) {\n			update(a[i].p, a[i].num, 1, n, 1);\n		}\n		for (int i = 1; i <= n; i++) {\n			printf(\"%d \", b[i]);\n		}\n		printf(\"\\n\");\n	}\n	return 0;\n} \n```\n\n### [HDU-1698 Just a Hook](http://acm.hdu.edu.cn/showproblem.php?pid=1698): 区间修改、延迟标记、区间求和\n\n**Problem Description**\n\nIn the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.\n![img](http://acm.hdu.edu.cn/data/images/C116-1010-1.JPG)\nNow Pudge wants to do some operations on the hook.\nLet us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.\nThe total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:\nFor each cupreous stick, the value is 1.\nFor each silver stick, the value is 2.\nFor each golden stick, the value is 3.\nPudge wants to know the total value of the hook after performing the operations.\nYou may consider the original hook is made up of cupreous sticks.\n\n**Input**\n\nThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.\nFor each case, the first line contains an integer N, 1<=N<=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0<=Q<=100,000, which is the number of the operations.\nNext Q lines, each line contains three integers X, Y, 1<=X<=Y<=N, Z, 1<=Z<=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.\n\n**Output**\n\nFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.\n\n**Sample Input**\n\n```C++\n1\n10\n2\n1 5 2\n5 9 3\n```\n\n**Sample Output**\n\n```C++\nCase 1: The total value of the hook is 24.\n```\n\n**题解：**\n\n​	题目大意：有T组样例，每组样例给出n个棍子，开始时每个棍子的价值均为1，给出q个操作，可以把编号[x,y]之间的棍子d的价值改为z（z可以是1，2，3），求最终价值。\n\n​	线段树每个结点存储对应区间的价值和，开始叶子结点默认价值为1。区间修改模板。\n\n```c++\n// 区间染色-区间修改，延迟标记 ，区间求和 \n#include<iostream>\nusing namespace std;\n\nconst int maxn = 100005;\nint lazy[maxn<<2];\nint sum[maxn<<2];\n\nvoid pushup(int i) {\n	sum[i] = sum[i<<1] + sum[i<<1|1];\n}\n\nvoid build(int l, int r, int i) {\n	lazy[i] = 0;\n	if (l == r) {\n		sum[i] = 1; // 初始值为1 \n		return; \n	}\n	int mid = (l + r) >> 1;\n	build(l, mid, i<<1);\n	build(mid + 1, r, i<<1|1);\n	pushup(i);\n}\n\n//更新子树的lazy值\nvoid pushdown(int l, int r, int i) {\n	int mid = (l + r) >> 1;\n	if (lazy[i]) { //如果有lazy标记\n		lazy[i<<1] = lazy[i]; //更新左子树的lazy值 \n		lazy[i<<1|1] = lazy[i]; //更新右子树的lazy值\n		sum[i<<1] = lazy[i<<1] * (mid - l + 1); //更新左子树的和 \n		sum[i<<1|1] = lazy[i<<1|1] * (r - mid); //更新右子树的和 \n		lazy[i] = 0; //取消标记 \n	}\n}\n\nvoid update(int l, int r, int z, int L, int R, int i) {\n	if (l <= L && R <= r) {\n		lazy[i] = z;\n		sum[i] = lazy[i] * (R - L + 1);\n		return;\n	}\n	pushdown(L, R, i); //每次都需要更新子树的lazy标记 \n	int mid = (L + R) >> 1;\n	if (l <= mid) {\n		update(l, r, z, L, mid, i<<1);\n	}\n	if (r > mid) {\n		update(l, r, z, mid + 1, R, i<<1|1);\n	}\n	pushup(i); //更新父结点 \n}\n/*\nint query(int l, int r, int L, int R, int i) {\n	if (l <= L && R <= r) {\n		return sum[i];\n	}\n	int mid = (l + r) >> 1;\n	int res = 0;\n	if (l <= mid) {\n		res += query(l, r, L, mid, i<<1);\n	}\n	if (r > mid) {\n		res += query(l, r, mid + 1, R, i<<1|1);\n	} \n	return res;\n}*/\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    int kase = 0;\n    while(T--) {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        build(1, n, 1);\n        for (int i = 0; i < q; i++) {\n            int x, y, z;\n            scanf(\"%d%d%d\", &x, &y, &z);\n            update(x, y, z, 1, n, 1);\n        }\n        printf(\"Case %d: The total value of the hook is %d.\\n\", ++kase, sum[1]);\n    }\n    return 0;\n}\n```\n\n### [HDU-5023 A Corrupt Mayor\'s Performance Art](http://acm.hdu.edu.cn/showproblem.php?pid=5023): 区间染色、区间更新、区间查询、延迟标记、位运算\n\n**Problem Description**\n\nCorrupt governors always find ways to get dirty money. Paint something, then sell the worthless painting at a high price to someone who wants to bribe him/her on an auction, this seemed a safe way for mayor X to make money.\nBecause a lot of people praised mayor X\'s painting(of course, X was a mayor), mayor X believed more and more that he was a very talented painter. Soon mayor X was not satisfied with only making money. He wanted to be a famous painter. So he joined the local painting associates. Other painters had to elect him as the chairman of the associates. Then his painting sold at better price.\nThe local middle school from which mayor X graduated, wanted to beat mayor X\'s horse fart(In Chinese English, beating one\'s horse fart means flattering one hard). They built a wall, and invited mayor X to paint on it. Mayor X was very happy. But he really had no idea about what to paint because he could only paint very abstract paintings which nobody really understand. Mayor X\'s secretary suggested that he could make this thing not only a painting, but also a performance art work.\nThis was the secretary\'s idea:\nThe wall was divided into N segments and the width of each segment was one cun(cun is a Chinese length unit). All segments were numbered from 1 to N, from left to right. There were 30 kinds of colors mayor X could use to paint the wall. They named those colors as color 1, color 2 .... color 30. The wall\'s original color was color 2. Every time mayor X would paint some consecutive segments with a certain kind of color, and he did this for many times. Trying to make his performance art fancy, mayor X declared that at any moment, if someone asked how many kind of colors were there on any consecutive segments, he could give the number immediately without counting.\nBut mayor X didn\'t know how to give the right answer. Your friend, Mr. W was an secret officer of anti-corruption bureau, he helped mayor X on this problem and gained his trust. Do you know how Mr. Q did this？\n\n**Input**\n\nThere are several test cases.\nFor each test case:\nThe first line contains two integers, N and M ,meaning that the wall is divided into N segments and there are M operations(0 < N <= 1,000,000; 0<M<=100,000)\nThen M lines follow, each representing an operation. There are two kinds of operations, as described below:\n1) P a b c\na, b and c are integers. This operation means that mayor X painted all segments from segment a to segment b with color c ( 0 < a<=b <= N, 0 < c <= 30).\n2) Q a b\na and b are integers. This is a query operation. It means that someone asked that how many kinds of colors were there from segment a to segment b ( 0 < a<=b <= N).\nPlease note that the operations are given in time sequence.\nThe input ends with M = 0 and N = 0.\n\n**Output**\n\nFor each query operation, print all kinds of color on the queried segments. For color 1, print 1, for color 2, print 2 ... etc. And this color sequence must be in ascending order.\n\n**Sample Input**\n\n```C++\n5 10\nP 1 2 3\nP 2 3 4\nQ 2 3\nQ 1 3\nP 3 5 4\nP 1 2 7\nQ 1 3\nQ 3 4\nP 5 5 8\nQ 1 5\n0 0\n```\n\n**Sample Output**\n\n```C++\n4\n3 4\n4 7\n4\n4 7 8\n```\n\n**题解：**\n\n题目大意：有最多30种颜色，一个长度为n的墙。一开始所有墙的颜色都是2。有两种操作：\n\n+ P l r x ：把区间[l,r]中所有的墙的颜色都改为x\n+ Q l r ：询问[l,r]里面的颜色，把颜色升序输出\n\n\n因为颜色种数最大只有30，可以直接用二进制表示是否含有某种颜色。就是利用优美的位运算的性质，初始为1，当有某种颜色时就<<代表此种颜色的数字，最后在每次输出的时候再从1到30种颜色中逐一>>并&1就可以检验是否含有这种颜色！\n\n```c++\n// 区间染色-区间更新-区间查询-延迟标记 \n#include<iostream>\nusing namespace std;\n\nconst int maxn = 1e6+5;\nint sum[maxn<<2];\nint lazy[maxn<<2];\n\nvoid pushup(int i) {\n	sum[i] = sum[i<<1] | sum[i<<1|1]; // 总共的颜色 \n}\n\nvoid pushdown(int i) {\n	if (lazy[i]) {\n		lazy[i<<1] = lazy[i];\n		lazy[i<<1|1] = lazy[i];\n		sum[i<<1] = lazy[i];\n		sum[i<<1|1] = lazy[i];\n		lazy[i] = 0;\n	}\n}\n\nvoid build(int l, int r, int i) {\n	lazy[i] = 0;\n	if (l == r) {\n		sum[i] = 1<<1;//初始颜色为2，即1<<1，左移1为\n		return;\n	}\n	int mid = (l + r) >> 1;\n	build(l, mid, i<<1);\n	build(mid + 1, r, i<<1|1);\n	pushup(i);\n} \n\nvoid update(int L, int R, int c, int l, int r, int i) {\n	if (l >= L && r <= R) {\n		sum[i] = 1<<(c-1);\n		lazy[i] = 1<<(c-1);\n		return;\n	}\n	pushdown(i);\n	int mid = (l + r) >> 1;\n	if (L <= mid) {\n		update(L, R, c, l, mid, i<<1);\n	}\n	if (R > mid) {\n		update(L, R, c, mid + 1, r, i<<1|1);\n	}\n	pushup(i);\n}\n\nint query(int L, int R, int l, int r, int i) {\n	if (l >= L && r <= R) {\n		return sum[i];\n	}\n	pushdown(i);\n	int mid = (l + r) >> 1;\n	int res = 0;\n	if (L <= mid) {\n		res |= query(L, R, l, mid, i<<1);\n	}\n	if (R > mid) {\n		res |= query(L, R, mid + 1, r, i<<1|1);\n	}\n	return res;\n}\n\nint main() {\n	int N, Q;\n    int a, b, c;\n    while (~scanf(\"%d%d\", &N, &Q)) {\n        if (N == 0 && Q == 0) {\n            break;\n		}\n        build(1, N, 1);//建树\n        while (Q--) {\n            char op[2];\n            scanf(\"%s\",op);\n            if (op[0] == \'Q\') {\n                scanf(\"%d%d\", &a, &b);\n                int tt = query(a, b, 1, N, 1);\n                int flag = 0;\n                for (int i = 1; i <= 30; i++) {\n                    //通过右移来判断是否存在i号颜色\n                    if (tt>>(i-1)&1 && flag == 0) { // flag用来控制输出格式 \n                        printf(\"%d\", i);\n                        flag = 1;\n                    } else if (tt>>(i-1)&1) {\n                    	printf(\" %d\", i);\n				   }                      \n                }\n                printf(\"\\n\");\n            } else {\n                scanf(\"%d%d%d\", &a, &b, &c);\n                update(a, b, c, 1, N, 1);\n            }\n        }\n    }\n	return 0;\n} \n\n//普通解法\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 1e6+5;\nint t[maxn<<2];\n\nvoid pushup(int i) {\n	if (t[i<<1] == t[i<<1|1]) { //如果两个儿子的颜色是一样的，说明大区间颜色一样\n		t[i] = t[i<<1];\n	} else { //否则，整个区间颜色不一，大区间改为0\n		t[i] = 0;\n	}\n} \n\nvoid pushdown(int i) {\n	if (!t[i]) { //如果大区间的颜色都是不确定的，没有必要往下传\n		return;\n	}\n	//大区间颜色确定，说明下面所有小区间颜色都是一样的\n	t[i<<1] = t[i];\n	t[i<<1|1] = t[i];\n	t[i] = 0;\n}\n\nvoid build(int l, int r, int i) {\n	if (l == r) {\n		t[i] = 2;\n		return;\n	}\n	int mid = (l + r) >> 1;\n	build(l, mid, i<<1);\n	build(mid + 1, r, i<<1|1);\n	pushup(i);\n}\n\nvoid update(int L, int R, int v, int l, int r, int i) {\n	if (l >= L && r <= R) {\n		t[i] = v; //找到大区间后，把大区间的颜色更改，下面的小区间等要用到的时候更新\n		return;\n	}\n	int mid = (l + r) >> 1;\n	pushdown(i);\n	if (L <= mid) {\n		update(L, R, v, l, mid, i<<1);\n	}\n	if (R > mid) {\n		update(L, R, v, mid + 1, r, i<<1|1);\n	}\n	pushup(i);\n}\n\nint ans[35];\nvoid query(int L, int R, int l, int r, int i) {\n	if (t[i]) { //如果这个大区间的颜色是知道的，那么下面所有的小区间的颜色都一样，不用再找了\n		ans[t[i]] = 1;\n		return;\n	}\n	//大区间颜色不确定，再往下找\n	int mid = (l + r) >> 1;\n	pushdown(i);\n	if (L <= mid) {\n		query(L, R, l, mid, i<<1);\n	}\n	if (R > mid) {\n		query(L, R, mid + 1, r, i<<1|1);\n	}\n}\n\nint main() {\n	int n, m;\n	while (~scanf(\"%d%d\", &n, &m)) {\n        if (!n && !m) {\n        	break;\n		}\n        build(1, n, 1);\n        char o[2];\n        int x, y, z;\n        for (int i = 1; i <= m; i++) {\n            scanf(\"%s\",o);\n            if (o[0] == \'P\') {\n                scanf(\"%d%d%d\", &x, &y, &z);\n                update(x, y, z, 1, n, 1);\n            } else if (o[0] == \'Q\') {\n                scanf(\"%d%d\", &x, &y);\n                memset(ans, 0, sizeof(ans));//预置为0\n                query(x, y, 1, n, 1);\n                bool fir = false;//注意行尾空格\n                for (int i = 1; i <= 30; i++) {\n                    if (ans[i]) {\n                        if (!fir) {\n                            printf(\"%d\", i);\n                            fir = true;\n                        } else {\n                            printf(\" %d\", i);\n                        }  \n                    }\n                }\n                printf(\"\\n\");\n            }\n        }\n    }\n	return 0;\n}\n```\n### [HDU-3308 LCIS](http://acm.hdu.edu.cn/showproblem.php?pid=3308): 区间合并、区间最值、单点更新、区间查询\n\n**Problem Description**\n\nGiven n integers.\nYou have two operations:\nU A B: replace the Ath number by B. (index counting from 0)\nQ A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].\n\n**Input**\n\nT in the first line, indicating the case number.\nEach case starts with two integers n , m(0<n,m<=105).\nThe next line has n integers(0<=val<=105).\nThe next m lines each has an operation:\nU A B(0<=A,n , 0<=B=105)\nOR\nQ A B(0<=A<=B< n).\n\n**Output**\n\nFor each Q, output the answer.\n\n**Sample Input**\n\n```C++\n1\n10 10\n7 7 3 3 5 9 9 8 1 8 \nQ 6 6\nU 3 4\nQ 0 1\nQ 0 5\nQ 4 7\nQ 3 5\nQ 0 2\nQ 4 6\nU 6 10\nQ 0 9\n```\n\n**Sample Output**\n\n```C++\n1\n1\n4\n2\n3\n1\n2\n5\n```\n\n**题解：**\n\n题目大意：给你n个数，m个操作。操作有两种：1.U x y 将数组第x位变为y   2. Q x y 问数组第x位到第y位连续最长子序列的长度。对于每次询问，输出一结果。\n\n分析：线段树单点修改区间合并。线段树维护三个值，lv是区间左端点开始的最长上升连续值，rv是以区间右端点结束的最长上升连续值，mv是该区间的最长上升连续值，pushup时分类讨论，当a[mid]<a[mid+1]时，可以知道该区间中间两个点是递增的。这需要合并操作，具体细节看代码注释：\n\n```c++\n// 区间合并、单点更新、区间查询、区间最值 \n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nstruct Tree {\n	int l, r;\n	//lv是区间左端点开始的最长上升连续值\n    //rv是以区间右端点结束的最长上升连续值\n    //mv是该区间的最长上升连续值\n	int lv, rv, mv; \n} tree[maxn<<2];\nint a[maxn];\nint n, m, t;\n\nvoid pushup(int l, int r, int rt) {\n	tree[rt].lv = tree[rt<<1].lv; //默认为左子树的lv \n	tree[rt].rv = tree[rt<<1|1].rv;//默认为右子树的rv \n	tree[rt].mv = max(tree[rt<<1].mv, tree[rt<<1|1].mv);//默认为左右子树mv的较大值 \n	int mid = (l + r) >> 1;\n	if (a[mid] < a[mid + 1]) { //左右可以合并 \n		if (tree[rt<<1].lv == mid - l + 1) { //左子树的lv长度等于区间长度 \n			tree[rt].lv = tree[rt<<1].lv + tree[rt<<1|1].lv;\n		}\n		if (tree[rt<<1|1].rv == r - mid) { //右子树的lv长度等于区间长度 \n			tree[rt].rv = tree[rt<<1].rv + tree[rt<<1|1].rv; \n		}\n        // 更新区间的最大值，与合并后的比较，左区间右端点和右区间左端点合并\n		tree[rt].mv = max(tree[rt].mv, tree[rt<<1].rv + tree[rt<<1|1].lv);\n	}\n}\n\nvoid build(int l, int r, int rt) {\n	tree[rt].l = l;\n	tree[rt].r = r;\n	if (l == r) {\n		tree[rt].lv = tree[rt].rv = tree[rt].mv = 1;\n		return;\n	} \n	int mid = (l + r) >> 1;\n	build(l, mid, rt<<1);\n	build(mid + 1, r, rt<<1|1);\n	pushup(l, r, rt);\n}\n\n//单点更新 \nvoid update(int l, int r, int p, int rt) {\n    if (l == r) {\n        return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) {\n    	update(l, mid, p, rt<<1);\n	} else {\n		update(mid + 1, r, p, rt<<1|1);\n	}\n    pushup(l, r, rt);\n}\n\n//区间查询 \nint query(int l, int r, int rt) {\n	if (tree[rt].l >= l && tree[rt].r <= r) {\n        return tree[rt].mv;\n    }\n    int mid = (tree[rt].l + tree[rt].r) >> 1;\n    int ans = 0;\n    //分别在左子区间和右子区间查找，结果分别为x,y,如果左右两个区间不能延续，\n    //那肯定是在x,y中找一个最大值\n    if (l <= mid) {\n    	ans = max(ans, query(l, r, rt<<1)); //x \n	} \n	if (r > mid) {\n		ans = max(ans, query(l, r, rt<<1|1)); //y\n	}\n //如果能够延续,设两端延续区间长度为z,那么肯定是在 x,y,z找最大值，另外，对于左区间,我们要保证\n //向左延续的区间(rv)肯定是在[l,mid]中的(不然超过我们要查询的区间了),所以长度必须要在 mid - l+1之内\n    //向右亦如此.\n	if (a[mid] < a[mid+1]) {\n        ans = max(ans, min(mid-l+1, tree[rt<<1].rv) + min(r-mid, tree[rt<<1|1].lv));\n    }\n   	return ans;\n}\n\nint main() {\n	scanf(\"%d\", &t);\n	while (t--) {\n		scanf(\"%d%d\", &n, &m);\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%d\", &a[i]);\n		}\n		build(1, n, 1);\n		while (m--) {\n	        char s[5];\n	        scanf(\"%s\", s);\n            if (s[0] == \'U\'){\n                int b, c;\n                scanf(\"%d%d\", &b, &c);\n                a[++b] = c;  //由于题目下标从0开始，所以++\n                update(1, n, b, 1);\n            } else {\n                int b, c;\n                scanf(\"%d%d\", &b, &c);\n                b++;\n			   c++;\n                printf(\"%d\\n\", query(b, c, 1));\n            }\n	    }\n	}\n	return 0;\n}\n```\n\n', '2021-05-16 16:44:05', '2021-05-20 22:28:21', 1, 0, 0);
INSERT INTO `tb_article` VALUES (57, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621519670084.jpg', '博弈论基础', '## 巴什博弈（Bash Game）\n\n​    一堆n个物品，两个人轮流从中取出1~m个，最后取光者胜（不能继续取的人输）。\n\n​    同余定理：n=k∗(m+1)+rn = k∗(m+1)+r，先者拿走rr个，那么后者无论拿走1 m1 m个先者只要的数目使和为m+1m+1，那么先手必赢。反之若n=k∗(m+1)n=k∗(m+1)，那么先手无论怎样都会输。\n\n```c++\nif (n % (m + 1))  return false;\nelse  return true;\n```\n### [Brave Game](http://acm.hdu.edu.cn/showproblem.php?pid=1846)\n\n**Problem Description**\n\n十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。\n今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。\n当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~\n各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：\n1、  本游戏是一个二人游戏;\n2、  有一堆石子一共有n个；\n3、  两人轮流进行;\n4、  每走一步可以取走1…m个石子；\n5、  最先取光石子的一方为胜；\n如果游戏的双方使用的都是最优策略，请输出哪个人能赢。\n\n**Input**\n\n输入数据首先包含一个正整数C(C<=100)，表示有C组测试数据。\n每组测试数据占一行，包含两个整数n和m（1<=n,m<=1000），n和m的含义见题目描述。\n\n**Output**\n\n如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。\n\n**Sample Input**\n\n```c++\n2\n23 2\n4 3\n```\n\n**Sample Output**\n\n```c++\nfirst\nsecond \n```\n\n 巴什博弈\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 巴什博弈 \nint c, n, m;\nint main() {\n	cin>>c;\n	while (c--) {\n		cin>>n>>m;\n		if (n % (m + 1)) {\n			cout<<\"first\"<<endl;\n		} else {\n			cout<<\"second\"<<endl; \n		}\n	}\n	return 0;\n}\n```\n\n### [选拔志愿者](http://acm.hdu.edu.cn/showproblem.php?pid=2188)\n\n**Problem Description**\n\n对于四川同胞遭受的灾难，全国人民纷纷伸出援助之手，几乎每个省市都派出了大量的救援人员，这其中包括抢险救灾的武警部队，治疗和防疫的医护人员，以及进行心理疏导的心理学专家。根据要求，我校也有一个奔赴灾区救灾的名额，由于广大师生报名踊跃，学校不得不进行选拔来决定最后的人选。经过多轮的考核，形势逐渐明朗，最后的名额将在“林队”和“徐队”之间产生。但是很巧合，2个人的简历几乎一模一样，这让主持选拔的8600很是为难。无奈，他决定通过捐款来决定两人谁能入选。\n选拔规则如下：\n1、最初的捐款箱是空的；\n2、两人轮流捐款，每次捐款额必须为正整数，并且每人每次捐款最多不超过m元(1<=m<=10)。\n3、最先使得总捐款额达到或者超过n元（0<n<10000）的一方为胜者，则其可以亲赴灾区服务。\n我们知道，两人都很想入选志愿者名单，并且都是非常聪明的人，假设林队先捐，请你判断谁能入选最后的名单？\n\n**Input**\n\n输入数据首先包含一个正整数C，表示包含C组测试用例，然后是C行数据，每行包含两个正整数n，m，n和m的含义参见上面提到的规则。\n\n**Output**\n\n对于每组测试数据，如果林队能入选，请输出字符串\"Grass\"， 如果徐队能入选，请输出字符串\"Rabbit\"，每个实例的输出占一行。\n\n**Sample Input**\n\n```c++\n2\n8 10\n11 10\n```\n\n**Sample Output**\n\n```c++\nGrass\nRabbit\n```\n\n巴什博弈模板\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint c, n, m;\n\nint main() {\n	cin>>c;\n	while (c--) {\n		cin>>n>>m;\n		// 如果 n % (m + 1) == 1，则先手必输，否则先手必赢（巴什博弈） \n		if (n % (m + 1)) {\n			cout<<\"Grass\"<<endl;\n		} else {\n			cout<<\"Rabbit\"<<endl;\n		}\n	}\n	return 0;\n}\n```\n\n### [Public Sale](http://acm.hdu.edu.cn/showproblem.php?pid=2149)\n\n**Problem Description**\n\n虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。\n要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。\n后来发现，整个拍卖会只有Lele和他的死对头Yueyue。\n通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。\nLele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。\n由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候，\nLele要出多少才能保证自己买得到这块地呢？\n\n**Input**\n\n本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。\n每组测试包含两个整数M和N(含义见题目描述，0<N，M<1100)\n\n**Output**\n\n对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。\n如果Lele在第一次无论如何出价都无法买到这块土地，就输出\"none\"。\n\n**Sample Input**\n\n```c++\n4 2\n3 2\n3 5\n```\n\n**Sample Output**\n\n```c++\n1\nnone\n3 4 5\n```\n\n巴什博弈\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 巴什博弈\nint M, N;\nint main() {\n	while (cin>>M>>N) {\n		if (M % (N + 1) == 0) {\n			cout<<\"none\"<<endl;\n		} else {\n			if (M <= N) {\n				for (int i = M; i <= N - 1; i++) {\n					cout<<i<<\" \";\n				}\n				cout<<N<<endl;\n			} else {\n				cout<<M % (N + 1)<<endl;\n			}\n		}\n	}\n	return 0;\n} \n```\n\n## 威佐夫博弈（Wythoff Game）\n\n​    有两堆各若干物品，两个人轮流从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。\n\n​    这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数，ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...ak=[k∗(1+5)/2], bk=ak+k, k=0,1,2,3...。\n\n​    所以，先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\n\n```c++\ndouble r = (sqrt(5) + 1) / 2;\nint d = abs(a - b) * r;\nif (d != min(a, b))  return true;\nelse  false;\n```\n\n注：如果a,b的值非常大的话，需要高精度来计算这个double类型的r。\n\n### [取石子游戏 POJ-1067](http://poj.org/problem?id=1067)\n\n**Description**\n\n有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。\n\n**Input**\n\n输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。\n\n**Output**\n\n输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。\n\n**Sample Input**\n\n```c++\n2 1\n8 4\n4 7\n```\n\n**Sample Output**\n\n```c++\n0\n1\n0\n```\n\n威佐夫博弈\n\n```c++\n#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n// 威佐夫博弈\n// 先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\nint main() {\n	int a, b;\n	while (cin>>a>>b) {\n		double r = (sqrt(5.0) + 1) / 2.0;\n		int d = abs(a - b) * r;\n		if (d != min(a, b)) {\n			cout<<1<<endl;\n		} else {\n			cout<<0<<endl;\n		}\n	}\n	return 0;\n}\n```\n\n## 斐波那契博弈（Fibonacci Nim Game）\n\n​    一堆石子有n个，两人轮流取，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。\n\n​    同样是一个规律：先手胜当且仅当n不是斐波那契数。\n\n```c++\nf[0] = f[1] = 1;\nfor (int i = 0; f[i - 1] < n; i++)\n{\n    f[i] = f[i - 1] + f[i - 2];\n    if (f[i] == n)  return true;\n}\nreturn false;\n```\n\n### [取石子游戏 HDU-2516](http://acm.hdu.edu.cn/showproblem.php?pid=2516)\n\n**Problem Description**\n\n1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出\"Second win\".先取者胜输出\"First win\".\n\n**Input**\n\n输入有多组.每组第1行是2<=n<2^31. n=0退出.\n\n**Output**\n\n先取者负输出\"Second win\". 先取者胜输出\"First win\".\n参看Sample Output.\n\n**Sample Input**\n\n```c++\n2\n13\n10000\n0\n```\n\n**Sample Output**\n\n```c++\nSecond win\nSecond win\nFirst win\n```\n\n斐波那契博弈\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// 斐波那契博弈，先手胜当且仅当n不是斐波那契数。 \nint main() {\n    int fib[44];\n    fib[0] = 2, fib[1] = 3;\n    for (int i = 2; i < 44; i++) {\n    	fib[i] = fib[i - 1] + fib[i - 2];\n	}  \n    int n;\n    while (~scanf(\"%d\", &n) && n) {\n        if (binary_search(fib, fib + 44, n)) {\n        	printf(\"Second win\\n\");\n		} else {\n			printf(\"First win\\n\");\n		}\n    }\n    return 0;\n}\n\n```\n\n\n## 尼姆博弈（Nimm Game）\n\n​    有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜。\n\n​    假如有3堆物品(a,b,c)\n  （0，0，0）状态时先手是一个必输局势因为没有东西可取，(0,n,n) 状态时也是必输局势只要后者在另一堆取得物品与前者一样多时那么前者也就是必输局势。慢分析(1,2,3)也是一个必输局势。如果我们将其转化为二进制形式并通过异或运算(^)我们会发现：\n\n```c++\n 0001^0010^0011=0000\n```\n\n通过验证所有的堆数量累^后只要为0就都是必输局势，所以我们就只要记住这个规则：将n堆物品数量全部异或后结果为0先手必败，否则必胜。\n\n```c++\nint res = 0;\nfor (int i = 1; i <= n; i++)\n    res ^= arr[i];\nif (res)  return true;\nelse  return false;\n```\n\n### [Matches Game](http://poj.org/problem?id=2234)\n\n**Description**\n\nHere is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a player’s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not.\n\n**Input**\n\nThe input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 <= M <=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.\n\n**Output**\n\nFor each test case, output \"Yes\" in a single line, if the player who play first will win, otherwise output \"No\".\n\n**Sample Input**\n\n```c++\n2 45 45\n3 3 6 9\n```\n\n**Sample Output**\n\n```c++\nNo\nYes\n```\n\n题目大意：两个玩家，可以选择一个堆并从堆中除去任意数量的火柴（当然，被除去的火柴数不能为零，并且不能大于所选堆中的火柴数）。如果在一个玩家回合之后没有剩余比赛，则该玩家为获胜者。假设两个参与者都非常清楚。您的工作是告诉最先玩的玩家是否可以赢得比赛。\n\nn 堆物品数量，尼姆博弈\n\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// 尼姆博弈，将n堆物品数量全部异或后结果为0先手必败，否则必胜。 \nint main() {\n	int M;\n	while (cin>>M) {\n		int res = 0, x;\n		for (int i = 0; i < M; i++) {\n			cin>>x;\n			res ^= x;\n		}\n		if (res) {\n			cout<<\"Yes\"<<endl;\n		} else {\n			cout<<\"No\"<<endl;\n		}\n	}\n	return 0;\n} \n```', '2021-05-20 22:05:02', '2021-05-20 22:08:05', 0, 0, 0);
INSERT INTO `tb_article` VALUES (59, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621520468622.jpg', '线性表的静态链表实现（游标）', '\n**静态链表**：用数组来实现链式存储结构。\n\n#### 原理：\n\n+ 定义一个结构体数组，结构体包含一个data域和一个cur指针域\n+ data域用来存放数据，cur用来指向下一个结点对应的数组下标\n+ 把数组分为两个链表，数据链表（已经使用的结点）和备用链表（可分配的结点）\n+ 数组0下标对应的cur指向备用链表，插入时通过它获取可分配的结点\n+ 释放结点时，把被释放的结点插入到0下标对应结点的下一个结点\n\n#### 具体代码实现：\n\n```c\n#include <stdio.h>\n\n#define SpaceSize 20\n\nstruct Node {\n    int data; // 数据域\n    int cur; // 指向下一个结点的指针\n} CursorSpace[SpaceSize];\n\n/**\n * 初始化静态链表\n */\nvoid InitializeCursorSpace() {\n    int i;\n\n    for (i = 0; i < SpaceSize - 1; i++) {\n        CursorSpace[i].cur = i + 1; // 都指向下一个位置\n    }\n    CursorSpace[SpaceSize - 1].cur = 0; // 最后一个结点指向0\n}\n\n/**\n * 分配结点，返回分配结点的下标\n */\nint CursorAlloc() {\n    int p = CursorSpace[0].cur;  // 0号位置指向的是备用链表，即可分配的结点\n\n    if (p) { // 不为空，即可以分配，把下一个结点用来做备用\n        CursorSpace[0].cur = CursorSpace[p].cur;\n    }\n    return p; // 返回分配的结点\n}\n\n/**\n * 释放结点，将p结点放回备用链表中\n */\nvoid CursorFree(int p) {\n    // 0号结点指向的是备用链表，即可分配的第一个结点\n    // 把要释放的结点指向0号结点指向的可分配的结点\n    CursorSpace[p].cur = CursorSpace[0].cur;\n    // 再把0号结点指向要释放的结点\n    // 这两步操作把要释放的结点p插入到了0号结点与0号结点指向的可分配的结点之间\n    // 所以，p结点可以通过0号结点重新分配给新的结点\n    CursorSpace[0].cur = p;\n}\n\n/**\n * 判断静态链表是否为空\n */\nint Empty(int head) {\n    return CursorSpace[head].cur == 0;\n}\n\n/**\n * 判断当前结点是否为最后一个结点\n */\nint IsLast(int p) {\n    return CursorSpace[p].cur == 0;\n}\n\n/**\n * 返回静态链表的长度\n */\nint ListLength(int head) {\n    int j = 0;\n    int i = CursorSpace[head].cur;\n\n    while (i) {\n        i = CursorSpace[i].cur;\n        j++;\n    }\n    return j;\n}\n\n/**\n * 查找某元素在静态链表中的位置\n * @param e 查找的元素\n * @param head 静态链表的头指针\n * @return 元素在静态链表中的位置，查找不到，返回0\n */\nint Find(int e, int head) {\n    int p, k = 1;\n\n    p = CursorSpace[head].cur;\n    while (p && CursorSpace[p].data != e) {\n        p = CursorSpace[p].cur;\n        k++;\n    }\n    if (p)\n        return k;\n    return 0;\n}\n\n/**\n * 查找某元素在静态链表中的前一个结点的下标\n * @param e 查找元素\n * @param head 头指针\n * @return 前一个结点的下标\n */\nint FindPrecious(int e, int head) {\n    int p = head;\n\n    while (CursorSpace[p].cur && CursorSpace[CursorSpace[p].cur].data != e) {\n        p = CursorSpace[p].cur;\n    }\n    return p;\n}\n\n/**\n * 删除静态链表中的元素\n * @param e 要被删除的元素\n * @param head\n */\nvoid Delete(int e, int head) {\n    int p, TmpCell;\n\n    p = FindPrecious(e, head); // 找到被删除元素的前一个结点\n    if (!IsLast(p)) { // 如果该节点不是最后一个结点\n        TmpCell = CursorSpace[p].cur;\n        CursorSpace[p].cur = CursorSpace[TmpCell].cur;\n        CursorFree(TmpCell); // 释放删除元素对应的节点\n    }\n}\n\n/**\n * 删除某个位置的结点\n * @param head\n * @param p 要删除的位置\n */\nvoid Delete_position(int head, int p) {\n    int j, k;\n\n    if (p < 1 || p > ListLength(head)) {\n        return;\n    }\n    k = head;\n\n    for (j = 1; j <= p - 1; j++) {\n        k = CursorSpace[k].cur;\n    }\n    j = CursorSpace[k].cur;\n    CursorSpace[k].cur = CursorSpace[j].cur;\n    CursorFree(j);\n}\n\n/**\n * 在指定的下标插入元素\n * @param e 插入的元素\n * @param p 插入的下标\n */\nvoid Insert(int e, int p) {\n    int TmpCell;\n\n    TmpCell = CursorAlloc();\n    if (TmpCell == 0) {\n        printf(\"List out of space!\\n\");\n    } else {\n        CursorSpace[TmpCell].data = e;\n        CursorSpace[TmpCell].cur = CursorSpace[p].cur;\n        CursorSpace[p].cur = TmpCell;\n    }\n}\n\n/**\n * 在指定的位置插入元素\n * @param head\n * @param e 插入的元素\n * @param i 插入的位置\n */\nvoid InsertList(int head, int e, int i) {\n    int j, k, l;\n\n    k = head;\n\n    if (i < 1 || i > ListLength(head) + 1) {\n        return;\n    }\n    j = CursorAlloc();\n\n    if (j) {\n        CursorSpace[j].data = e;\n        for (l = 1; l <= i - 1; l++) {\n            k = CursorSpace[l].cur;\n        }\n        CursorSpace[j].cur = CursorSpace[k].cur;\n        CursorSpace[k].cur = j;\n    }\n}\n\n/**\n * 清空静态链表\n */\nvoid Delete_List(int head) {\n    int p, Tem;\n\n    p = CursorSpace[head].cur;\n    CursorSpace[head].cur = 0;\n\n    while (p) {\n        Tem = CursorSpace[p].cur;\n        CursorFree(p);\n        p = Tem;\n    }\n}\n\n/**\n * 打印静态链表的所有元素\n */\nvoid Print_List(int head) {\n    int p = CursorSpace[head].cur;\n\n    if (Empty(head)) {\n        printf(\"Empty!\\n\");\n    } else {\n        while (p) {\n            printf(\"%d \", CursorSpace[p].data);\n            p = CursorSpace[p].cur;\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n\n    int i, m, data_find, data_delete, p_delete, n_insert;\n    int p, head, t;\n	// 初始化\n    InitializeCursorSpace();\n    // 创建头结点，类似于单链表的头结点，方便插入和删除操作\n    head = CursorAlloc();\n\n    printf(\"The position of head is %d\\n\", head);\n    p = head;\n\n    printf(\"Please input the number of data :\\n\");\n    scanf(\"%d\", &m);\n\n    printf(\"The original input is as follows :\\n\");\n\n    for (i = 1; i <= m; i++) {\n        t = CursorAlloc();\n        scanf(\"%d\", &CursorSpace[t].data);\n        CursorSpace[p].cur = t;\n        p = t;\n    }\n    CursorSpace[p].cur = 0;\n\n    Print_List(head);\n\n    printf(\"input the data to find :\\n\");\n    scanf(\"%d\", &data_find);\n    p = Find(data_find, head);\n    printf(\"The position of data is %d\\n\", p);\n\n    printf(\"input the data to delete :\\n\");\n    scanf(\"%d\", &data_delete);\n    Delete(data_delete, head);\n    Print_List(head);\n\n    printf(\"input the position to delete :\\n\");\n    scanf(\"%d\", &p_delete);\n    Delete_position(head, p_delete);\n    Print_List(head);\n\n    printf(\"input the inserted number :\\n\");\n    scanf(\"%d\", &n_insert);\n    printf(\"input the inserted position :\\n\");\n    scanf(\"%d\", &p);\n    InsertList(head, n_insert, p);\n    Print_List(head);\n\n    printf(\"Now , the ListLength is %d.\\n\", ListLength(head));\n    Delete_List(head);\n    printf(\"After clearing , now the list is :\\n\");\n    Print_List(head);\n\n    return 0;\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081221275976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n', '2021-05-20 22:22:43', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (61, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621521586845.jpg', '循环队列的C语言实现', '\n这里队列的判满方法，采用的是少用一个元素空间的方法，即 (**rear + 1) % MaxSize == front** 时，队列满。\n\n**代码**\n\n```c++\n#include<stdio.h>\n#include<malloc.h>\n\n#define MaxSize 100  // 队列的最大长度为 100-1=99\n\ntypedef struct {\n    int data[MaxSize];\n    int front; // 头指针指向队首元素 \n	int rear; // 尾指针指向队尾元素的下一个元素 \n} SeqQueue, *PSeqQueue;\n\n// 初始化队列 \nPSeqQueue Init_SeqQueue() {\n    PSeqQueue Q;\n\n    Q = (PSeqQueue)malloc(sizeof(SeqQueue));\n    if (!Q) {\n        return NULL;\n    }\n    // 将队头和队尾指针置为0 \n    Q->front = 0;\n    Q->rear = 0;\n    return Q;\n}\n\n// 返回队列的实际长度 = (rear - front + maxSize) % maxSize \nint Length_SeqQueue(PSeqQueue Q) {\n    return ((Q->rear - Q->front + MaxSize) % MaxSize);\n}\n\n// 判断队列是否为空，队首和队尾指针相等时为空 \nint Empty_SeqQueue(PSeqQueue Q) {\n    return Q->front == Q->rear;\n}\n\n// 入队操作，参数x为入队元素 \nvoid In_SeqQueue(PSeqQueue Q, int x) {\n	// 判断队列是否已满，这里通过少用一个元素空间来判断队列是否已满 \n    if ((Q->rear + 1) % MaxSize == Q->front) {\n        printf(\"Queue is full!\\n\");\n        return;\n    }\n    Q->data[Q->rear] = x; // 对应元素入队 \n    Q->rear = (Q->rear + 1) % MaxSize; // 队尾指针后移  \n}\n\n// 出队操作，参数e用来存储出队的元素 \nvoid Out_SeqQueue(PSeqQueue Q, int *e) {\n    if (Empty_SeqQueue(Q)) { // 判断队列是否为空 \n        printf(\"Queue NULL!\\n\");\n        return;\n    }\n    *e = Q->data[Q->front]; // 出队元素的赋值 \n    Q->front = (Q->front + 1) % MaxSize; // 队首元素后移 \n}\n\n// 获取队首元素，存放在参数e中 \nint Front_SeqQueue(PSeqQueue Q, int *e) {\n    if (Empty_SeqQueue(Q)) {\n        printf(\"Queue NULL!\\n\");\n        return 0;\n    }\n    *e = Q->data[Q->front];\n    return 1;\n}\n\n// 遍历打印队列中的元素 \nvoid Print_SeqQueue(PSeqQueue Q) {\n    int i;\n\n    if (Empty_SeqQueue(Q)) {\n        printf(\"Queue NULL!\\n\");\n    } else {\n        i = Q->front;\n        while (i != Q->rear) {\n            printf(\"%d \", Q->data[i]);\n            i = (i + 1) % MaxSize;\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    PSeqQueue Q;\n    int e, n, i;\n\n    printf(\"input the number of data :\\n\");\n    scanf(\"%d\", &n);\n\n    Q = Init_SeqQueue();\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &e);\n        In_SeqQueue(Q, e);\n    }\n    printf(\"The Queue is :\\n\");\n    Print_SeqQueue(Q);\n\n    printf(\"The length of Queue is %d.\\n\", Length_SeqQueue(Q));\n    Out_SeqQueue(Q, &e);\n    printf(\"The out data is %d.\\n\", e);\n\n    Front_SeqQueue(Q, &e);\n    printf(\"The front data is %d.\\n\", e);\n\n    printf(\"Now , the queue is :\\n\");\n    Print_SeqQueue(Q);\n\n    printf(\"The length of the new Queue is %d.\\n\", Length_SeqQueue(Q));\n\n    return 0;\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082021454422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n', '2021-05-20 22:37:18', '2021-05-20 22:53:38', 0, 0, 0);
INSERT INTO `tb_article` VALUES (62, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621522019040.jpg', '链队C语言实现', '### **用带头结点的单链表来实现队列**\n\n+ 队头指针始终指向头结点，队尾指针指向最后一个结点（队尾结点）。\n+ 空链队的队头指针和队尾指针均指向头结点\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823165353245.png#pic_center)\n\n### 完整代码\n\n```c++\n#include<stdio.h>\n#include<malloc.h>\n\n/*\n	用带头结点的单链表来实现队列 \n*/\ntypedef struct Node { // 结点结构 \n    int data; // 数据域 \n    struct Node *next; // 指向下一个结点的指针 \n} QNode, *PQNode;\n\ntypedef struct {\n    PQNode front, rear;  // 队头、队尾指针 \n} LinkQueue, *PLinkQueue;\n\n// 初始化队列 \nvoid Init_LinkQueue(PLinkQueue Q) {\n    Q->front = Q->rear = (PQNode)malloc(sizeof(QNode)); // 开辟头结点，队头、队尾指针都指向头结点 \n\n    if (!Q->front) {\n        return;\n    }\n    Q->front->next = NULL; // 头结点的next指针指向NULL \n}\n\n// 进队操作，参数e是进队的元素 \nvoid In_LinkQueue(PLinkQueue Q, int e) {\n    PQNode p;\n\n    p = (PQNode)malloc(sizeof(QNode));	// 开辟新的结点 \n    if (p == NULL) {\n        return;\n    } \n    p->data = e; // 赋值元素 \n    p->next = NULL; // 新结点指向NULL \n    Q->rear->next = p; // 尾结点的next指针指向新结点 \n    Q->rear = p; // 尾指针置为新节点 \n}\n\n// 出队操作，参数e用来存放出队元素 \nvoid Out_LinkQueue(PLinkQueue Q, int *e) {\n    PQNode p;\n    \n    if (Q->front == Q->rear) { // 为空直接返回 \n        return;\n    }\n    p = Q->front->next; // 获取队头结点，即头结点的下一个结点 \n    *e = p->data; // 获取对应元素 \n    Q->front->next = p->next; // 将队头结点置为队头的下一个结点，为删除队头结点做准备 \n\n    if (Q->rear == p) { // 如果队尾结点与要删除的队头结点相同\n        Q->rear = Q->front; // 将队尾指针置为头结点 \n    }\n    free(p); // 释放队头结点 \n}\n\n// 获取队头元素 \nint GetFront_LinkQueue(PLinkQueue Q) {\n    PQNode p;\n\n    if (Q->front == Q->rear) {\n        printf(\"Queue NULL!\\n\");\n    } else {\n        p = Q->front->next;\n        return p->data;\n    }\n}\n\n// 获取队列的长度 \nint Length_LinkQueue(PLinkQueue Q) {\n    int count = 0;\n    PQNode p;\n\n    p = Q->front->next;\n    while (p != NULL) {\n        count++;\n        p = p->next;\n    }\n    return count;\n}\n\n// 依次遍历打印队列中的元素 \nvoid Print_LinkQueue(PLinkQueue Q) {\n    PQNode p;\n\n    p = Q->front->next;\n    if (p == NULL) {\n        printf(\"Queue NULL!\\n\");\n    } else {\n        while (p != NULL) {\n            printf(\"%d \", p->data);\n            p = p->next;\n        }\n        printf(\"\\n\");\n    }\n}\n\n// 销毁队列 \nvoid Destroy_LinkQueue(PLinkQueue Q) {\n    while (Q->front) {\n        Q->rear = Q->front->next;\n        free(Q->front);\n        Q->front = Q->rear;\n    }\n}\n\nint main() {\n    LinkQueue q;\n    PLinkQueue Q = &q;\n    int n, e, i;\n\n    Init_LinkQueue(Q);\n    printf(\"input the number of data :\\n\");\n    scanf(\"%d\", &n);\n\n    printf(\"input Queue :\\n\");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &e);\n        In_LinkQueue(Q, e);\n    }\n    printf(\"The Queue is :\\n\");\n    Print_LinkQueue(Q);\n\n    printf(\"The length of Queue is %d.\\n\", Length_LinkQueue(Q));\n\n    Out_LinkQueue(Q, &e);\n    printf(\"The out data is %d.\\n\", e);\n\n    printf(\"The front data is %d.\\n\", GetFront_LinkQueue(Q));\n\n    printf(\"Now , the new Queue is :\\n\");\n    Print_LinkQueue(Q);\n\n    printf(\"The length of Queue is %d.\\n\", Length_LinkQueue(Q));\n\n    Destroy_LinkQueue(Q);\n\n    return 0;\n} ![](QQ截图20200823165218.png)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823165406449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n', '2021-05-20 22:47:53', '2021-05-20 22:53:19', 0, 0, 0);
INSERT INTO `tb_article` VALUES (63, 1, 16, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621522256214.jpg', '二叉树遍历递归及非递归完整代码实现', '### 二叉树的四种遍历方式\n\n+ 先序遍历   根左右\n+ 中序遍历   左根右\n+ 后序遍历   左右根\n+ 层次遍历   从第一层依次向下遍历每一层（使用队列实现）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200827094951548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n\n\n### 递归实现\n\n```c++\n#include<iostream>\n#include<queue>\n#include<cstdlib>\n\nusing namespace std;\n\ntypedef char ElemType;\n\n// 二叉树结点的结构 \ntypedef struct BiTNode {\n	ElemType data; // 数据库 \n	struct BiTNode *lchild, *rchild; // 左右孩子的指针 \n} BiTNode, *BiTree;\n\n// 先序创建二叉树\nvoid CreateBiTree(BiTree *T) {\n	ElemType data;\n	\n	scanf(\"%c\", &data);\n	if (data == \' \') {\n		*T = NULL;\n	} else {\n		*T = (BiTree)malloc(sizeof(BiTNode));\n		(*T)->data = data;\n		CreateBiTree(&(*T)->lchild);\n		CreateBiTree(&(*T)->rchild);\n	}\n} \n\n// 输出二叉树结点\nvoid visit(BiTree T) {\n	if (T->data != \' \') {\n		printf(\"%c\", T->data);\n	}\n} \n\n// 线序遍历二叉树\nvoid PreOrderTraverse(BiTree T) {\n	if (T) {\n		visit(T);\n		PreOrderTraverse(T->lchild);\n		PreOrderTraverse(T->rchild);\n	}\n} \n\n// 中序遍历二叉树\nvoid InOrderTraverse(BiTree T) {\n	if (T) {\n		InOrderTraverse(T->lchild);\n		visit(T);\n		InOrderTraverse(T->rchild);\n	}\n}\n\n// 后序遍历二叉树\nvoid PostOrderTraverse(BiTree T) {\n	if (T) {\n		PostOrderTraverse(T->lchild);\n		PostOrderTraverse(T->rchild);\n		visit(T);\n	}\n} \n\n// 层次遍历，队列实现\nvoid LevelOrderTraverse(BiTree T) {\n	queue<BiTNode*> q;\n	BiTree p;\n	q.push(T);\n	while (!q.empty()) {\n		p = q.front();\n		q.pop();\n		visit(p);\n		if (p->lchild) {\n			q.push(p->lchild);\n		}\n		if (p->rchild) {\n			q.push(p->rchild);\n		}\n	}\n} \n```\n\n### 非递归实现\n[后序遍历方式3参考博客](http://blog.csdn.net/zhangxiangdavaid/article/details/37115355)\n```c++\n/* 非递归实现 */\n// 先序遍历 \nvoid PreOrderByStack(BiTree T) {\n	stack<BiTree> s;\n	BiTree p = T;\n	\n	while (p || !s.empty()) { // 栈不为空或p不为空时循环 \n		if (p != NULL) {\n			s.push(p); // 存入栈中 \n			visit(p); // 输出结点元素 \n			p = p->lchild; // 遍历左子树 \n		} else {\n			p = s.top(); // 栈顶结点 \n			s.pop(); // 出栈 \n			p = p->rchild; // 遍历右子树 \n		} \n	}\n	printf(\"\\n\");\n} \n\n// 中序遍历 \nvoid InOrderByStack(BiTree T) {\n	stack<BiTree> s;\n	BiTree p = T;\n	\n	while (p || !s.empty()) {\n		if (p != NULL) { \n			s.push(p); // 入栈 \n			p = p->lchild; // 遍历左子树 \n		} else {\n			p = s.top(); // 栈顶结点 \n			s.pop(); // 出栈 \n			visit(p); // 访问结点 \n			p = p->rchild; // 遍历右子树 \n		}\n	}\n	printf(\"\\n\");\n} \n\n/*\n	后序遍历1：\n	后序遍历：左右根，可以看作根右左的逆序输出\n	所以可以利用两个栈：\n	1. push第一个结点进栈 s 中\n	2. 从 s 中pop一个结点temp，存入栈output中\n	3. 然后push temp结点的左孩子和右孩子到 s 中\n	4. 重复过程2,3，直到栈s为空\n	5. 完成后，所有的结点已经push到栈output中，且按照后序遍历二点逆序存放，直接依次pop并输出即位后序遍历的结果 \n*/ \nvoid PostOrderByStack1(BiTree T) {\n	stack<BiTree> s, output;\n	BiTree temp = NULL;\n	\n	s.push(T);\n	while (!s.empty()) {\n		temp = s.top();\n		s.pop();\n		output.push(temp);\n		if (temp->lchild) {\n			s.push(temp->lchild);\n		}\n		if (temp->rchild) {\n			s.push(temp->rchild);\n		}\n	}\n	while (!output.empty()) {\n		printf(\"%c\", output.top()->data);\n		output.pop();\n	}\n	printf(\"\\n\");\n} \n\n// 后序遍历2\nvoid PostOrderByStack2(BiTree T) {\n	stack<BiTree> s;\n	BiTree p = T, r = NULL;\n	\n	while (p || !s.empty()) {\n		if (p) { // 入栈左孩子 \n			s.push(p);\n			p = p->lchild;\n		} else {\n			p = s.top();\n			if (p->rchild && p->rchild != r) { // 当前结点有右孩子并且没有访问过，继续往下走 \n			 // 下面p位置NULL后，下次会来到改代码块，p更新为栈顶结点，而此时，该结点的右孩子已经访问过\n				p = p->rchild;\n			} else {\n				s.pop(); // 出栈 \n				visit(p); // 访问节点 \n				r = p; // 记录该节点 \n				p = NULL; // 置为NULL，使程序能进入到外层的else里面 \n			}\n		}\n	}\n	printf(\"\\n\");\n} \n\n// 后序遍历3\nvoid PostOrderByStack3(BiTree root)\n{\n	if (root == NULL) {\n		return;\n	}\n	stack<BiTree> s;\n	// pCur:当前访问节点，pLastVisit:上次访问节点\n	BiTree pCur, pLastVisit;\n	// pCur = root;\n	pCur = root;\n	pLastVisit = NULL;\n	// 先把pCur移动到左子树最下边\n	while (pCur) {\n		s.push(pCur);\n		pCur = pCur->lchild;\n	}\n	while (!s.empty())	{\n		// 走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子)\n		pCur = s.top();\n		s.pop();\n		// 一个根节点被访问的前提是：无右子树或右子树已被访问过\n		if (pCur->rchild == NULL || pCur->rchild == pLastVisit)	{\n			printf(\"%c\", pCur->data);\n			// 修改最近被访问的节点\n			pLastVisit = pCur;\n		}\n		/*  \n			这里的else语句可换成带条件的else if:\n			else if (pCur->lchild == pLastVisit)//若左子树刚被访问过，则需先进入右子树(根节点需再次入栈)\n			因为：上面的条件没通过就一定是下面的条件满足。仔细想想！\n		*/\n		else {\n			// 根节点再次入栈\n			s.push(pCur);\n			// 进入右子树，且可肯定右子树一定不为空\n			pCur = pCur->rchild;\n			while (pCur) {\n				s.push(pCur);\n				pCur = pCur->lchild;\n			}\n		}\n	}\n	printf(\"\\n\");\n}\n```\n### 完整代码及测试\n\n```c++\n#include<iostream>\n#include<queue>\n#include<stack> \n#include<cstdlib>\n\nusing namespace std;\n\ntypedef char ElemType;\n\n// 二叉树结点的结构 \ntypedef struct BiTNode {\n	ElemType data; // 数据库 \n	struct BiTNode *lchild, *rchild; // 左右孩子的指针 \n} BiTNode, *BiTree;\n\n// 先序创建二叉树\nvoid CreateBiTree(BiTree *T) {\n	ElemType data;\n	\n	scanf(\"%c\", &data);\n	if (data == \' \') {\n		*T = NULL;\n	} else {\n		*T = (BiTree)malloc(sizeof(BiTNode));\n		(*T)->data = data;\n		CreateBiTree(&(*T)->lchild);\n		CreateBiTree(&(*T)->rchild);\n	}\n} \n\n// 输出二叉树结点\nvoid visit(BiTree T) {\n	if (T->data != \' \') {\n		printf(\"%c\", T->data);\n	}\n} \n\n// 线序遍历二叉树\nvoid PreOrderTraverse(BiTree T) {\n	if (T) {\n		visit(T);\n		PreOrderTraverse(T->lchild);\n		PreOrderTraverse(T->rchild);\n	}\n} \n\n// 中序遍历二叉树\nvoid InOrderTraverse(BiTree T) {\n	if (T) {\n		InOrderTraverse(T->lchild);\n		visit(T);\n		InOrderTraverse(T->rchild);\n	}\n}\n\n// 后序遍历二叉树\nvoid PostOrderTraverse(BiTree T) {\n	if (T) {\n		PostOrderTraverse(T->lchild);\n		PostOrderTraverse(T->rchild);\n		visit(T);\n	}\n} \n\n// 层次遍历\nvoid LevelOrderTraverse(BiTree T) {\n	queue<BiTree> q;\n	BiTree p;\n	q.push(T);\n	while (!q.empty()) {\n		p = q.front();\n		q.pop();\n		visit(p);\n		if (p->lchild) {\n			q.push(p->lchild);\n		}\n		if (p->rchild) {\n			q.push(p->rchild);\n		}\n	}\n} \n\n/* 非递归实现 */\n// 先序遍历 \nvoid PreOrderByStack(BiTree T) {\n	stack<BiTree> s;\n	BiTree p = T;\n	\n	while (p || !s.empty()) { // 栈不为空或p不为空时循环 \n		if (p != NULL) {\n			s.push(p); // 存入栈中 \n			visit(p); // 输出结点元素 \n			p = p->lchild; // 遍历左子树 \n		} else {\n			p = s.top(); // 栈顶结点 \n			s.pop(); // 出栈 \n			p = p->rchild; // 遍历右子树 \n		} \n	}\n	printf(\"\\n\");\n} \n\n// 中序遍历 \nvoid InOrderByStack(BiTree T) {\n	stack<BiTree> s;\n	BiTree p = T;\n	\n	while (p || !s.empty()) {\n		if (p != NULL) { \n			s.push(p); // 入栈 \n			p = p->lchild; // 遍历左子树 \n		} else {\n			p = s.top(); // 栈顶结点 \n			s.pop(); // 出栈 \n			visit(p); // 访问结点 \n			p = p->rchild; // 遍历右子树 \n		}\n	}\n	printf(\"\\n\");\n} \n\n/*\n	后序遍历1：\n	后序遍历：左右根，可以看作根右左的逆序输出\n	所以可以利用两个栈：\n	1. push第一个结点进栈 s 中\n	2. 从 s 中pop一个结点temp，存入栈output中\n	3. 然后push temp结点的左孩子和右孩子到 s 中\n	4. 重复过程2,3，直到栈s为空\n	5. 完成后，所有的结点已经push到栈output中，且按照后序遍历二点逆序存放，直接依次pop并输出即位后序遍历的结果 \n*/ \nvoid PostOrderByStack1(BiTree T) {\n	stack<BiTree> s, output;\n	BiTree temp = NULL;\n	\n	s.push(T);\n	while (!s.empty()) {\n		temp = s.top();\n		s.pop();\n		output.push(temp);\n		if (temp->lchild) {\n			s.push(temp->lchild);\n		}\n		if (temp->rchild) {\n			s.push(temp->rchild);\n		}\n	}\n	while (!output.empty()) {\n		printf(\"%c\", output.top()->data);\n		output.pop();\n	}\n	printf(\"\\n\");\n} \n\n// 后序遍历2\nvoid PostOrderByStack2(BiTree T) {\n	stack<BiTree> s;\n	BiTree p = T, r = NULL;\n	\n	while (p || !s.empty()) {\n		if (p) { // 入栈左孩子 \n			s.push(p);\n			p = p->lchild;\n		} else {\n			p = s.top();\n			if (p->rchild && p->rchild != r) { // 当前结点有右孩子并且没有访问过，继续往下走 \n			 // 下面p位置NULL后，下次会来到改代码块，p更新为栈顶结点，而此时，该结点的右孩子已经访问过\n				p = p->rchild;\n			} else {\n				s.pop(); // 出栈 \n				visit(p); // 访问节点 \n				r = p; // 记录该节点 \n				p = NULL; // 置为NULL，使程序能进入到外层的else里面 \n			}\n		}\n	}\n	printf(\"\\n\");\n} \n\n// 后序遍历3\nvoid PostOrderByStack3(BiTree root)\n{\n	if (root == NULL) {\n		return;\n	}\n	stack<BiTree> s;\n	// pCur:当前访问节点，pLastVisit:上次访问节点\n	BiTree pCur, pLastVisit;\n	// pCur = root;\n	pCur = root;\n	pLastVisit = NULL;\n	// 先把pCur移动到左子树最下边\n	while (pCur) {\n		s.push(pCur);\n		pCur = pCur->lchild;\n	}\n	while (!s.empty())	{\n		// 走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子)\n		pCur = s.top();\n		s.pop();\n		// 一个根节点被访问的前提是：无右子树或右子树已被访问过\n		if (pCur->rchild == NULL || pCur->rchild == pLastVisit)	{\n			printf(\"%c\", pCur->data);\n			// 修改最近被访问的节点\n			pLastVisit = pCur;\n		}\n		/*  \n			这里的else语句可换成带条件的else if:\n			else if (pCur->lchild == pLastVisit)//若左子树刚被访问过，则需先进入右子树(根节点需再次入栈)\n			因为：上面的条件没通过就一定是下面的条件满足。仔细想想！\n		*/\n		else {\n			// 根节点再次入栈\n			s.push(pCur);\n			// 进入右子树，且可肯定右子树一定不为空\n			pCur = pCur->rchild;\n			while (pCur) {\n				s.push(pCur);\n				pCur = pCur->lchild;\n			}\n		}\n	}\n	printf(\"\\n\");\n}\n\nint main()\n{\n    BiTree T = NULL;\n\n    CreateBiTree(&T);\n    printf(\"========递归实现========\\n\");\n    printf(\"先序遍历：\"); \n    PreOrderTraverse(T);\n    printf(\"\\n\");\n    printf(\"中序遍历：\");\n    InOrderTraverse(T);\n    printf(\"\\n\");\n    printf(\"后序遍历：\"); \n    PostOrderTraverse(T); \n    printf(\"\\n\");\n    printf(\"层次遍历：\");\n    LevelOrderTraverse(T);\n    printf(\"\\n\");\n    printf(\"\\n\");\n    \n    printf(\"========非递归实现========\\n\");\n    printf(\"先序遍历：\");\n    PreOrderByStack(T);\n    printf(\"中序遍历：\");\n    InOrderByStack(T);\n    printf(\"后序遍历1：\");\n    PostOrderByStack1(T);\n    printf(\"后序遍历2：\");\n    PostOrderByStack2(T);\n    printf(\"后序遍历3：\"); \n    PostOrderByStack3(T);\n    \n	return 0;\n} \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200827095008292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\n', '2021-05-20 22:51:08', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (64, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621603583016.jpg', '2019年安徽省程序设计大赛题解', '## [问题 A: 机器人足球](https://acm.webturing.com/problem.php?cid=1355&pid=0&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n足球场地长为100,宽为20,对方的球门坐标为(100,10),你要控制一个个机器人踢球，初始位置为(x,y).机器人可以朝任何方向移动，但不能超出场地边界，当机器人与球门距离不超过10时，可以射门。 问机器人从初始位置出发到射门，最少要移动多少距离? (四舍五人到小数点后3位)\n\n**输入**\n\n每组输人为2个整数，分别为x ,y\n0<= x<=100\n0<= y<=20\n\n**输出**\n\n输出最小移动的距离\n\n**样例输入**\n\n```c++\n10 10\n1\n```\n\n**样例输出**\n\n```c++\n80.000\n```\n\n**题解:** 到球门中心的距离减去半径10\n\n```c++\n#include<stdio.h>\n#include<math.h>\n\nint main() {\n	int x, y;\n	scanf(\"%d%d\", &x, &y);\n	double s = sqrt((x-100)*(x-100) + (y-10)*(y-10));\n	printf(\"%.3lf\\n\", s - 10);\n	return 0;\n}\n```\n\n## [问题 B: 纸牌识别](https://acm.webturing.com/problem.php?cid=1355&pid=1&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\nAlice沉迷于机器人研究，他打算做- - 个机器人来检查-副扑克是否完整。现在，他想请你帮他写-一个程序，来识别纸牌，每张纸牌都有-个花色(四种花色，分别用大写字母P，K, H, T表示)和一一个数字点数(1-13) .纸牌可以用ABC的形式来表示，A代表花色，BC代表数字，如果数字小于10，会有一位补0.\n​ 比如花色是P,数字是9的纸牌会表示成P09.一副完整的纸牌有52张牌，四种不同的花色各有1张数字1-13的牌.你的程序要读人一个字符串，表示缺少的纸牌有哪些。如果包含相同的纸牌(花色数字都相同)输出GRESKA,否则输出每种花色剩余的纸牌数量。\n\n**输入**\n\n输人只有一行，一个字符串S, S的长度长度小于等于1000\n\n**输出**\n\n如果输人中包含相同的纸牌，输出GRESKA,否则分别输出四个整数，代表P,K, H, T四种花色纸牌的剩余数量\n\n**样例输入**\n\n```c++\nP01K02H03H04\n1\n```\n\n**样例输出**\n\n```c++\n12 12 11 13\n```\n\n**题解**: 模拟，利用四个数组分别表示四种花色牌的状态，对输入的字符串每3个字符一组进行判断，判断对应花色的牌是否存在，若不存在，将对应下标的数组置 1，对应花色的数量减 1，否则输出 GRESKA。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n// 分别代表四种花色对应牌是否已经含有 \nint c1[14], c2[14], c3[14], c4[14];\nchar str[1005];\n// 分别表示四种花色的牌的数量 \nint s1 = 13, s2 = 13, s3 = 13, s4 = 13; \nint flag;\n\nint main() {\n	cin>>str;\n	for (int i = 0; i < 14; i++) {\n		c1[i] = 0;\n		c2[i] = 0;\n		c3[i] = 0;\n		c4[i] = 0;	\n	}\n	int i = 0;\n	int len = strlen(str);\n	flag = 0;\n	while (i < len)	{\n		int num;\n		num = (str[i+1] - \'0\') * 10 + str[i+2] - \'0\';\n		if (str[i] == \'P\') {\n			if (c1[num] != 0) {\n				cout<<\"GRESKA\"<<endl;\n				flag = 1;\n				break;\n			} else {\n				c1[num] = 1;\n				s1--;\n			}\n		} else if (str[i] == \'K\') {\n			if (c2[num] != 0) {\n				cout<<\"GRESKA\"<<endl;\n				flag = 1;\n				break;\n			} else {\n				c2[num] = 1;\n				s2--;\n			}\n		} else if (str[i] == \'H\') {\n			if (c3[num] != 0) {\n				cout<<\"GRESKA\"<<endl;\n				flag = 1;\n				break;\n			} else {\n				c3[num] = 1;\n				s3--;\n			}\n		} else if (str[i] == \'T\') {\n			if (c4[num] != 0) {\n				cout<<\"GRESKA\"<<endl;\n				flag = 1;\n				break;\n			} else {\n				c4[num] = 1;\n				s4--;\n			}\n		}\n		i += 3;\n	}\n	if (!flag) {\n		cout<<s1<<\" \"<<s2<<\" \"<<s3<<\" \"<<s4<<endl;\n	}\n	return 0;\n}\n```\n\n## [问题 C: 卡牌对决](https://acm.webturing.com/problem.php?cid=1355&pid=2&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n有2N张牌，它们的点数分别为1到2N。Alice拿了其中的N张，Bob拿了剩下的N张. Alice和Bob会进行N轮游戏，在每轮游戏中，Alice 和Bob 各出一张牌。出了的牌不能收回。在前N/2轮中，每轮谁的牌点数大谁就赢;在后N/2轮中，每轮谁的牌点数小谁就赢。已知Bob 每一轮会出什么牌，试求Alice 最多能赢多少轮。\n\n**输入**\n\n第一行是一个整数N,\n接下来N行，每行一个整数，表示Bob这轮会出什么。\n2<=N <= 50000,保证N是偶数\n\n**输出**\n\n输出Alice最多能赢几轮\n\n**样例输入**\n\n```c++\n4\n1\n8\n4\n3\n1\n2\n3\n4\n5\n```\n\n**样例输出**\n\n```c++\n2\n```\n\n**题解**: 贪心，先把 b 的牌分成前 N/2 和 后 N/2，再根据 b 的牌得出 a 的牌，对 a、b的牌升序排列。因为前 N/2 轮，a 的牌大于 b 的牌，a 胜利，所以，用 a 的后 N/2 张牌（a 的较大值）与 b 的前 N/2 张牌（b 的较小值）进行比较；对于后 N/2 轮，则反过来。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint s[100001];  // 全部的牌 \nint a[50001]; // Alice 的牌 \nint b1[25001]; // Bob 前 N/2 的牌 \nint b2[25001]; // Bob 后 N/2 的牌 \nint N;\n\nint main() {\n	int x, y;\n	cin>>N;\n	for (int i = 1; i <= 2*N; i++) {\n		s[i] = i;\n	}\n	memset(b1, 0, sizeof(b1));\n	memset(b2, 0, sizeof(b2));\n	// 输入 Bob 的牌 \n	for (int i = 1, j = 1, k = 1; i <= N; i++) {\n		if (i <= N/2) {\n			cin>>x;\n			b1[j++] = x;\n			s[x] = 0;\n		} else {\n			cin>>y;\n			b2[k++] = y;\n			s[y] = 0;\n		}\n	}\n	// 根据 Bob 的牌和全部的牌得出 Alice 的牌 \n	for (int i = 1, k = 1; i <= 2*N; i++) {\n		if (s[i]) {\n			a[k++] = s[i];\n		}\n	}\n	// 各自的牌都升序排列 \n	sort(a + 1, a + N + 1);\n	sort(b2 + 1, b2 + N/2 + 1);\n	sort(b1 + 1, b1 + N/2 + 1);\n	int count = 0;\n	// a 的后 N/2 与 b 的前 N/2 比较，a > b 胜 \n	// a 的后 N/2 是 a 的较大值，b 的前 N/2 是 b 的较小值 \n	int i = N/2 + 1;\n	int j = 1;\n	while (i <= N && j <= N/2) {\n		if (a[i] > b1[j]) {\n			count++;\n			i++;\n			j++;\n		} else {\n			i++;\n		}\n	}\n	// a 的前 N/2 与 b 的后 N/2 比较，a < b 胜 \n	// a 的较小值与 b 的较大值 \n	i = N/2;\n	j = N/2;\n	while (i >= 1 && j >= 1) {\n		if (a[i] < b2[j]) {\n			i--;\n			j--;\n			count++;\n		} else {\n			i--;\n		}\n	}\n	cout<<count<<endl;\n	return 0;\n}\n```\n\n\n## [问题 H: 不要回文](https://acm.webturing.com/problem.php?cid=1355&pid=7&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n给出一个字符串 S，你需要尽可能少的修改 S 中的字符， 使得 S 不包含长度大于等于 2 的回文子串。\n\n**输入**\n\n输入的第一行是一个字符串 S， S只包含小写字母\nS 的长度大于 5 小于 300\n\n**输出**\n\n输出使得 S 中不包含长度大于等于 2 的回文， 最少需要修改几个字符 （可以修改成任意字符）\n\n**样例输入**\n\n```c++\nabbaa\n1\n```\n\n**样例输出**\n\n```c++\n2\n```\n\n**题解**: 贪心\n\n+ 把字符串中的字符转化成数字\n+ 进行两轮扫描，第一轮消除 3个字符的回文；第二轮消除 2个字符的回文\n+ 消除回文时，对**可能构成多个回文的字符**进行重新赋值，赋值一个不存在的数字即可\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[305], ans = 0;\nint t = 30;\nstring s;\n\nint main() {\n	cin>>s;\n	int len = s.length();\n	// 把字符串的字符转化成数字 \n	for (int i = 0; i < len; i++) {\n		a[i+1] = s[i] - \'a\' + 1;\n	}\n	// 第一轮扫描，消除 3个字符的回文 \n	for (int i = 1; i <= len - 2; i++) {\n 	  	if (a[i] == a[i+2]) { \n 	  		if (a[i] == a[i-1]) { \n 	  			a[i] = t++;\n 	  			ans++;\n			} else {\n				a[i+2] = t++;\n				ans++;\n			}\n		}\n	}\n	// 第二轮扫描，消除 2个字符的回文 \n	for (int i = 1; i <= len - 1; i++) {\n		if (a[i] == a[i+1]) {\n			a[i+1] = t++;\n			ans++;\n		}\n	}\n	cout<<ans;\n	return 0;\n}\n```\n\n## [问题 I: 你的名字](https://acm.webturing.com/problem.php?cid=1355&pid=8&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n​ Alice 想要计算他那 N 只猫的名字的价值每只猫的名字由不超过 1000 个大小写字母构成，没有一个名字是空字体串。 Alice有一张*价值字符串表”， 上面有 M个代表价值的字符串。每个字符串由不超过30个大小写字母构成，同样不存在空字符串。一个猫的名字蕴含多少个价值字符串，这个名字就有多少价值，所谓 “蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现 (不一定一个紧接着一个) .\n​ 所有的大写字母和小写字母都是等价的。比如，在贝黄的名字\"Bessie\"里， 蕴含有 “Be” “si” “EE” 以及 “Es” 等等字符串，但不蕴含\"Ls°或\"eB\"请帮Alice计算他的猫的名字的价值.\n\n**输入**\n\n输人的第-行是两个整数 N M\n接下来N行，每行一个字符串表示猫的名字。\n接下来M行，每行一个价值字符串\n1 <=N<= 1000\n1 <= M<=100\n\n**输出**\n\n输出每只猫蕴含多少个价值字符串。\n\n**样例输入**\n\n```c++\n5 3\nBessie\nJonathan\nMontgomery\nAlicia\nAngola\nSe  \nnGo  \noNt\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n**样例输出**\n\n```c++\n1\n1\n2\n0\n1\n```\n\n**题解**: 暴力，对每个名字，在价值字符串中扫描\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nchar cat[1005][1005];\nchar val[105][35];\nint n, m;\n\nint main() {\n	cin>>n>>m;\n	for (int i = 0; i < n; i++) {\n		cin>>cat[i];\n		int len = strlen(cat[i]);\n		for (int j = 0; j < len; j++) {\n			cat[i][j] = tolower(cat[i][j]); // 转化为小写 \n		}\n	}\n	for (int i = 0; i < m; i++) {\n		cin>>val[i];\n		int len = strlen(val[i]);\n		for (int j = 0; j < len; j++) {\n			val[i][j] = tolower(val[i][j]); // 转化为小写 \n		}\n	}\n	for (int i = 0; i < n; i++) {  // 名字循环\n		int count = 0;\n		for (int j = 0; j < m; j++) { // 价值循环（多个价值字符串）\n			int lenCat = strlen(cat[i]);\n			int lenVal = strlen(val[j]);\n			int p = 0, flag = 0;\n			for (int k = 0; k < lenVal; k++) { // 价值字符串长度\n				while (p < lenCat && cat[i][p] != val[j][k]) {\n					p++;\n				}\n				if (p == lenCat) {\n					flag = 1;\n					break;\n				}\n				p++;\n			}\n			if (!flag) {\n				count++;\n			}\n		}\n		cout<<count<<endl;\n	}\n	return 0;\n} \n```\n\n## [问题 L: 曲奇工厂](https://acm.webturing.com/problem.php?cid=1355&pid=11&langmask=262141&puzzle_mask=0)\n\n**题目描述**\n\n曲奇工厂是一个经典好玩的益智游戏，游戏中你的目标是生产至少 C 块曲奇:游戏的规则十分简单; 游戏开始时你有 0 块曲奇，每分钟可以手工作出 S 块曲奇。你也可以从 N 个工厂中选择些买下来; 工厂依次编号为 1-N ,买下第 i 个工厂需要花费 Ai 个曲奇饼。但是工厂会为你带来更多收益，买下第 i 个工厂后，每分钟曲奇产出会增加 Bi 块。\n对于每个工厂，你只能买一次: 你只能在整数分钟时购买工厂，并且可以一次买多个工厂, 请问达成日标所用最短时间是多少?\n\n**输入**\n\n输人的第一行是三个整数 N, C 和 S\n接下来 N 行，每行两个整数 Ai 和 Bi\n1 <=N<= 5\n1<= C, S, Ai, Bi <=.10^5\n\n**输出**\n\n输出得到至少C块曲奇,最少要多长时间。\n\n**样例输入**\n\n```c++\n2 18 1\n6 2\n5 1\n1\n2\n3\n```\n\n**样例输出**\n\n```c++\n12\n```\n\n**题解**: 求出工厂的全排列，依次按每种排列进行生产曲奇，每种排列中依次增加工厂，并计算每次需要花费的时间，这样所有情况都涉及到，取最小的时间即可。\n\n**技巧**：对工厂数组的下标进行全排列，也可以得到工厂数组的全排列。\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\nint n, c, s, ans;\nint a[5], b[5];\nint f[5] = {0, 1, 2, 3, 4};\n\nint main() {\n    cin >> n >> c >> s;\n    for (int i = 0; i < n; i++) {\n    	cin >> a[i] >> b[i];\n	}\n    ans = 0x3f3f3f3f;\n    do {\n        int i, j, k, t, w, val;\n        // (c + s - 1) / S 不使用工厂完成任务需要花费的时间 \n        ans = min(ans, (c + s - 1) / s);\n        for (j = f[i = 0], t = val = 0, w = s; i < n; i++, j = f[i]) {\n        	// 买 j 工厂需要花费多长时间 \n            k = max(0, a[j] - val + w - 1) / w;\n            // 花费的时间增加 \n            t += k;\n            // 买工厂后剩余的曲奇饼 \n			val += k * w - a[j];\n			// 买工厂后，每分钟能做出的曲奇饼数量增加了 \n			w += b[j];\n			// 有该工厂后，完成任务需要多少时间，更新 ans \n            ans = min(ans, t + max(0, (c - val + w - 1) / w));\n        }\n    } while (next_permutation(f, f + n));\n    cout << ans << endl;\n    return 0;\n}\n```\n\n', '2021-05-21 21:26:26', '2021-05-22 22:38:16', 0, 0, 0);
INSERT INTO `tb_article` VALUES (65, 1, 15, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621606137069.jpg', '分数规划入门', '## [Dropping tests POJ-2976](http://poj.org/problem?id=2976) 0/1分数规划 最大化平均值\n\n**Description**\n\nIn a certain course, you take *n* tests. If you get *ai* out of *bi* questions correct on test *i*, your cumulative average is defined to be\n\n![img](http://poj.org/images/2976_1.gif).\n\nGiven your test scores and a positive integer *k*, determine how high you can make your cumulative average if you are allowed to drop any *k* of your test scores.\n\nSuppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is ![img](http://poj.org/images/2976_3.gif). However, if you drop the third test, your cumulative average becomes ![img](http://poj.org/images/2976_2.gif).\n\n**Input**\n\nThe input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ *n* ≤ 1000 and 0 ≤ *k* < *n*. The second line contains *n* integers indicating *ai* for all *i*. The third line contains *n* positive integers indicating *bi* for all *i*. It is guaranteed that 0 ≤ *ai* ≤ *bi* ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with *n* = *k* = 0 and should not be processed.\n\n**Output**\n\nFor each test case, write a single line with the highest cumulative average possible after dropping *k* of the given test scores. The average should be rounded to the nearest integer.\n\n**Sample Input**\n\n```c++\n3 1\n5 0 2\n5 1 6\n4 2\n1 2 7 9\n5 6 7 9\n0 0\n```\n\n**Sample Output**\n\n```c++\n83\n100\n```\n\n**解题思路**\n\n给定两个数组a，b，a[i] 和 b[i] 是相对应的，不能改变位置，去掉其中的 k 个元素，求最大的 r = ∑a[i]/∑b[i]。\n\n对上面的式子进行转化，只要给每个物品重新赋值为 a[i] - r\' * b[i]，排序之后直接取前 n - k 大，判断这个值的正负性，进行二分，大于0，mid 偏小，l = mid，小于0，mid 偏大，r = mid。\n\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 1005;\nconst int inf = 0x3f3f3f3f;\n\nint n, k;\ndouble a[maxn], b[maxn], d[maxn];\n\ndouble check(double len) {\n	double sum = 0;\n	for (int i = 0; i < n; i++) {\n		d[i] = a[i] - b[i] * len;\n	}\n	// 升序排列 \n	sort(d, d + n);\n	// 去掉前 k 个元素 \n	for (int i = k; i < n; i++) {\n		sum += d[i];\n	}\n	return sum;\n}\n \nint main() {\n	while (~scanf(\"%d%d\", &n, &k)) {\n		if (!n && !k) {\n			break;\n		}\n		for (int i = 0; i < n; i++) {\n		}\n		for (int i = 0; i < n; i++) {\n			scanf(\"%lf\", &b[i]);\n		}\n		double l = inf, r = -inf;\n		for (int i = 0; i < n; i++) {\n			l = min(l, a[i] / b[i]);\n			r = max(r, a[i] / b[i]);\n		} \n		while (r - l > 1e-7) {\n			double mid = (l + r) / 2;\n			// 大于0，mid 偏小 \n			if (check(mid) > 0) {\n				l = mid;\n			} else { // mid 偏大 \n				r = mid;\n			}\n		}\n		printf(\"%.0f\\n\", l * 100);\n	} \n	return 0;\n}\n```\n\n## [Desert King POJ-2728](http://poj.org/problem?id=2728) 最优比率生成树\n\n**Description**\n\nDavid the Great has just become the king of a desert country. To win the respect of his people, he decided to build channels all over his country to bring water to every village. Villages which are connected to his capital village will be watered. As the dominate ruler and the symbol of wisdom in the country, he needs to build the channels in a most elegant way.\nAfter days of study, he finally figured his plan out. He wanted the average cost of each mile of the channels to be minimized. In other words, the ratio of the overall cost of the channels to the total length must be minimized. He just needs to build the necessary channels to bring water to all the villages, which means there will be only one way to connect each village to the capital.\nHis engineers surveyed the country and recorded the position and altitude of each village. All the channels must go straight between two villages and be built horizontally. Since every two villages are at different altitudes, they concluded that each channel between two villages needed a vertical water lifter, which can lift water up or let water flow down. The length of the channel is the horizontal distance between the two villages. The cost of the channel is the height of the lifter. You should notice that each village is at a different altitude, and different channels can\'t share a lifter. Channels can intersect safely and no three villages are on the same line.\nAs King David\'s prime scientist and programmer, you are asked to find out the best solution to build the channels.\n\n**Input**\n\nThere are several test cases. Each test case starts with a line containing a number N (2 <= N <= 1000), which is the number of villages. Each of the following N lines contains three integers, x, y and z (0 <= x, y < 10000, 0 <= z < 10000000). (x, y) is the position of the village and z is the altitude. The first village is the capital. A test case with N = 0 ends the input, and should not be processed.\n\n**Output**\n\nFor each test case, output one line containing a decimal number, which is the minimum ratio of overall cost of the channels to the total length. This number should be rounded three digits after the decimal point.\n\n**Sample Input**\n\n```c++\n4\n0 0 0\n0 1 1\n1 1 2\n1 0 3\n0\n```\n\n**Sample Output**\n\n```c++\n1.000\n```\n\n**题目大意：**有 n 个村庄，村庄在不同坐标和海拔，现在要对所有村庄供水，只要两个村庄之间有一条路即可，建造水管距离为坐标之间的欧几里德距离，费用为海拔之差，现在要求方案使得费用与距离的比值最小，很显然，这个题目是要求一棵最优比率生成树。\n\n**解题思路：**\n\n[参考链接](https://blog.csdn.net/sdj222555/article/details/7490797?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.control)\n\n求 MIN（ ∑CiXi / ∑DiXi ） Xi∈{0，1} ，对每个生成树，设其比率 r = ∑CiXi / ∑DiXi ，可得 ∑CiXi - ∑DiXi * r=0（条件1）\n\n那么对于所有的生成树，显然 ∑CiXi - ∑DiXi * min(r) >= 0，当 ∑CiXi / ∑DiXi = min(r)时，等号成立。 而我们现在不知道min(r)是多少，只好进行枚举，对每个枚举的 r ,构建新的权值（Ci - Di * r），然后求最小生成树，寻找使得生成树的总权值为 0 的可能性，因为只有当其等于0 的时候，才满足了条件 1 这个条件， 说明这个 r 是可行的，并且如果 r 枚举到值为min(r)时，其最小生成树的的总权值必然恰好等于0，但是如果不能等于0， 比如大于0， 显然是对该r值，所有的生成树上无论如何也满足不了条件1，说明 r 值就是偏小了。同理如果小于0，r 值是偏大的，说明可能存在某些生成树使得满足条件1，而我们的目标是在满足条件1的情况下使得 r 最小。\n\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 1005;\nconst double eps = 1e-6;\n\nint n; \ndouble x[maxn], y[maxn], z[maxn];\ndouble dist[maxn], g[maxn][maxn], res; \nint vis[maxn];\n\ndouble cal(int i, int j, double mid) {\n	return fabs(z[i]-z[j]) - mid*sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n}\n\ndouble prim(double mid) {\n	for (int i = 1; i <= n; i++) {\n		for (int j = i + 1; j <= n; j++) {\n            // 计算边的新权值\n			g[i][j] = g[j][i] = cal(i, j, mid);\n		}\n	}\n	for (int i = 1; i <= n; i++) {\n		vis[i] = 0;\n		dist[i] = g[1][i];\n	}\n	dist[1] = 0;\n	vis[1] = 1;\n\n	int x;\n	double sum = 0;\n	for (int i = 0; i < n - 1; i++)	{\n		double mindis = 1000000009;\n		for (int j = 1; j <= n; j++) {\n			if (!vis[j] && dist[j] < mindis) {\n				mindis = dist[j];\n				x = j;\n			}\n		} \n		vis[x] = 1;\n		sum += mindis;\n		for (int j = 1; j <= n; j++) {\n			if (!vis[j] && dist[j] > g[x][j]) {\n				dist[j] = g[x][j];\n			}\n		} \n	}\n	return sum;\n}\n\nint main() {\n	while (~scanf(\"%d\", &n) && n) {\n		for (int i = 1; i <= n; i++) {\n			scanf(\"%lf%lf%lf\", &x[i], &y[i], &z[i]);\n		}\n		double l = 0.0, r = 1e10;\n		while (fabs(r - l) > eps) {\n			double mid = (l + r) / 2;\n			if (prim(mid) >= eps) {\n				l = mid;\n			} else {\n				r = mid;\n			}\n		}\n		printf(\"%.3lf\\n\", l);\n	}\n	return 0;\n}\n```\n', '2021-05-21 22:09:02', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (67, 1, 14, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621698039364.jpg', '力扣刷题笔记之反转链表系列', '### [206.反转链表 (简单)](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n**非递归**\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n// 解法一\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while (cur != null) {\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n// 解法二\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode pre = dummy, cur = head;\n        while (cur.next != null) {\n            ListNode curNext = cur.next;\n            cur.next = curNext.next;\n            curNext.next = pre.next;\n            pre.next = curNext;\n        }\n        return dummy.next;\n    }\n}\n```\n**递归实现**\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode pre = dummy, cur = head;\n        while (cur.next != null) {\n            ListNode curNext = cur.next;\n            cur.next = curNext.next;\n            curNext.next = pre.next;\n            pre.next = curNext;\n        }\n        return dummy.next;\n    }\n}\n```\n\n举个例子就容易明白了\n\n\n```bash\n1->2->3->4->5->null\n(head)1->reverseList(2->3->4->5->null) #  ListNode newHead = reverseList(head.next);\n(head)1->2<-3<-4<-5(newHead) # reverseList(head.next)执行完后\n(head)1<-2<-3<-4<-5(newHead) # head.next.next = head\nnull<-(head)1<-2<-3<-4<-5(newHead)  # head.next = null\n```\n\n### [92. 反转链表 II (中等)](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\n\n**非递归**\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode pre = dummy;\n        for (int i = 1; i < left; i++) {\n            pre = pre.next;\n        }\n        ListNode cur = pre.next;\n        for (int i = left; i < right; i++) {\n            ListNode curNext = cur.next;\n            cur.next = curNext.next;\n            curNext.next = pre.next;\n            pre.next = curNext;\n        }\n        return dummy.next;\n    }\n}\n```\n\n**递归版**\n\n```java\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (left == 1) { // left = 1,相当于反转前 right 个节点\n            return reverseN(head, right);\n        }\n        // head.next 为第一个节点，则反转区间从 left - 1 开始，right - 1 结束\n        head.next = reverseBetween(head.next, left - 1, right - 1);\n        return head;\n    }\n\n    private ListNode successor = null; // 后继节点\n\n    // 反转以 head 为起点的 n 个节点，返回新的头节点\n    public ListNode reverseN(ListNode head, int n) {\n        if (n == 1) {\n            successor = head.next; // 记录后继节点\n            return head;\n        }\n        ListNode newHead = reverseN(head.next, n - 1);\n        head.next.next = head;\n        head.next = successor;\n        return newHead;\n    }\n}\n```\n### [25. K 个一组翻转链表 (困难)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || head.next == null || k < 2) {\n            return head;\n        }\n        ListNode p1 = head, p2 = head;\n        for (int i = 0; i < k; i++) {\n            if (p2 == null) {  // 不足 k 个直接返回\n                return head;\n            }\n            p2 = p2.next;\n        }\n        ListNode newHead = reverse(p1, p2);\n        p1.next = reverseKGroup(p2, k); // p1.next 指向后面反转的结果\n        return newHead;\n    }\n\n    // 反转 p1 和 p2 之间的节点，左闭右开\n    public ListNode reverse(ListNode p1, ListNode p2) {\n        ListNode pre = null;\n        ListNode cur = p1;\n        while (cur != p2) {\n            ListNode curNext = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = curNext;\n        }\n        return pre;\n    }\n}\n\n\n // 解法二\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || head.next == null || k < 2) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        int len = 0;\n        ListNode cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            len++;\n        }\n        // 1->2->3->4->5  k = 3\n        // 2->1->3->4->5\n        // 3->2->1->4->5\n        ListNode pre = dummy, curNext = null;\n        cur = head;\n        for (int i = 0; i < len / k; i++) {\n            for (int j = 1; j < k; j++) {\n                curNext = cur.next;\n                cur.next = curNext.next;\n                curNext.next = pre.next;\n                pre.next = curNext;\n            }\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n```\n\n\n\n', '2021-05-22 23:40:43', '2021-05-23 10:12:41', 0, 0, 0);
INSERT INTO `tb_article` VALUES (68, 1, 14, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621774751117.jpg', '力扣 234. 回文链表 (简单)', '### [234. 回文链表 (简单)](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n// 递归\nclass Solution {\n    private ListNode left;\n    public boolean isPalindrome(ListNode head) {\n        left = head;\n        return traverse(head.next);\n    }\n\n    public boolean traverse(ListNode right) {\n        if (right == null) {\n            return true;\n        }\n        boolean res = traverse(right.next);\n        res = res && (left.val == right.val);\n        left = left.next;\n        return res;\n    }\n}\n\n// 非递归，把后半部分反转，再与前半段比较\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) {\n            return true;\n        }\n        ListNode fast = head, slow = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        ListNode preTail = slow; \n        ListNode head2 = reverse(slow.next);\n        ListNode left = head;\n        ListNode right = head2;\n        while (right != null) {\n            if (left.val != right.val) {\n                return false;\n            }\n            left = left.next;\n            right = right.next;\n        }\n        // preTail.next = reverse(head2); // 恢复链表\n        return true;\n    }\n\n    public ListNode reverse(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while (cur != null) {\n            ListNode curNext = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = curNext;\n        }\n        return pre;\n    }\n}\n```', '2021-05-23 20:59:15', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (69, 1, 14, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621774962251.jpg', '力扣刷题笔记之二叉树（一）', '### [226. 翻转二叉树 (简单)](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n```c++\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n// 前序遍历\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        /* 前序遍历位置 */\n        // 交换 root 的左右子节点\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        // 左右子节点继续翻转\n        invertTree(root.left);\n        invertTree(root.right);\n        return root;\n    }\n}\n\n// 后序遍历\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        // 左右子节点翻转\n        invertTree(root.left);\n        invertTree(root.right);\n\n        /* 后序遍历位置 */\n        // 交换 root 的左右子节点\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        return root;\n    }\n}\n\n// 中序遍历\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        // 递归翻转左子树\n        invertTree(root.left);\n    \n        /* 中序序遍历位置 */\n        // 交换 root 的左右子节点\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n	    // 递归反转右子树，注意：这里是 root.left，因为上面的代码把左右节点互换了\n        // 此时的 root.left 就是原先的 root.right\n        invertTree(root.left);\n        return root;\n    }\n}\n\n// 层次遍历\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            TreeNode right = node.right;\n            node.right = node.left;\n            node.left = right;\n            if (node.left != null) {\n                q.offer(node.left);\n            }\n            if (node.right != null) {\n                q.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n### [116. 填充每个节点的下一个右侧节点指针 (中等)](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\n// 递归前序遍历写法\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return null;\n        }\n        connectTwoNodes(root.left, root.right);\n        return root;\n    }\n\n    public void connectTwoNodes(Node left, Node right) {\n        if (left == null || right == null) {\n            return;\n        }\n        /* 前序遍历位置 */\n        // 连接传入的两个节点\n        left.next = right;\n        // 连接具有相同父结点的两个子节点\n        connectTwoNodes(left.left, left.right);\n        connectTwoNodes(right.left, right.right);\n        // 连接具有不同父结点的两个子节点\n        connectTwoNodes(left.right, right.left);\n    }\n}\n\n/*\n	递归，前序遍历\n	1.通过父节点来连接子节点 \n	2.通过父节点的 next 域来进行不同父节点的字节点的连接\n*/\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null || root.left == null) {\n            return root;\n        }\n        // root 的左子节点连接右子节点\n        root.left.next = root.right;\n        // 通过父节点的 next 域来进行不同父节点的字节点的连接\n        // root 是左父节点，root.next 是右父节点\n        if (root.next != null) {\n            // root.right 是左父节点的右子节点，root.next.left 是右父结点的左子节点\n            root.right.next = root.next.left;\n        }\n        connect(root.left);\n        connect(root.right);\n        return root;\n    }\n}\n\n// 层次遍历\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return root;\n        }\n        // 初始化队列同时将第一层节点加入队列中，即根节点\n        Queue<Node> queue = new LinkedList<Node>(); \n        queue.offer(root);\n        // 外层的 while 循环迭代的是层数\n        while (!queue.isEmpty()) {\n            // 记录当前队列大小\n            int size = queue.size();\n            // 遍历这一层的所有节点\n            for (int i = 0; i < size; i++) {\n                // 从队首取出元素\n                Node node = queue.poll();\n                // 连接\n                if (i < size - 1) {\n                    node.next = queue.peek();\n                }\n                // 拓展下一层节点\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n        }\n        // 返回根节点\n        return root;\n    }\n}\n```\n\n\n\n### [114. 二叉树展开为链表 (中等)](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        // 递归展开左子树和右子树\n        flatten(root.left);\n        flatten(root.right);\n        TreeNode left = root.left;\n        TreeNode right = root.right;\n	    // 因为按照先序遍历顺序，所以将左子树变为右子树\n        // 此时 root.right 连接的是展开后为链表的左子树\n        root.right = left;\n        root.left = null;\n\n        // 将原来的右子树接到新右子树的末端\n        TreeNode cur = root;\n        while (cur.right != null) {\n            cur = cur.right;\n        }\n        cur.right = right;\n    }\n}\n\n// 先序遍历的逆序遍历，右左根\nclass Solution {\n    private TreeNode right = null;\n    public void flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        flatten(root.right);\n        flatten(root.left);\n        root.right = right;\n        root.left = null;\n        right = root;\n    }\n}\n\n// 用 list 记录先序遍历序列，再遍历 list 修改 left，right 指向\nclass Solution {\n    private List<TreeNode> list = new ArrayList<>();\n\n    public void flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        preOrder(root);\n        for (int i = 0; i < list.size() - 1; i++) {\n            TreeNode pre = list.get(i);\n            TreeNode next = list.get(i + 1);\n            pre.right = next;\n            pre.left = null;\n        }\n    }\n\n    public void preOrder(TreeNode root) {\n        if (root != null) {\n            list.add(root);\n            preOrder(root.left);\n            preOrder(root.right);\n        }\n    }\n}\n```\n\n', '2021-05-23 21:02:48', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (70, 1, 14, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621926835942.jpg', '力扣刷题笔记之二叉树（二）', '### [654. 最大二叉树 (中等)](https://leetcode-cn.com/problems/maximum-binary-tree/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return build(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode build(int[] nums, int low, int high) {\n        if (low > high) {\n            return null;\n        }\n        int index = -1, maxVal = Integer.MIN_VALUE;\n        for (int i = low; i <= high; i++) {\n            if (nums[i] > maxVal) {\n                maxVal = nums[i];\n                index = i;\n            }\n        }\n        TreeNode root = new TreeNode(maxVal);\n        root.left = build(nums, low, index - 1);\n        root.right = build(nums, index + 1, high);\n        return root;\n    }\n}\n```\n\n### [105. 从前序与中序遍历序列构造二叉树 (中等)](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    // 存放中序序列中的值与下标的映射，方便查询\n    private Map<Integer, Integer> map = new HashMap<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder.length == 0 || inorder.length == 0) {\n            return null;\n        }\n        for (int i = 0; i < inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n        return buildTreeHelper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);\n    }   \n    // 先序：根左右\n    // 中序：左根右\n    public TreeNode buildTreeHelper(int[] preorder, int preStart, int preEnd,\n                                    int[] inorder, int inStart, int inEnd) {\n        if (preStart > preEnd) {\n            return null;\n        }\n        // 根节点的值\n        int rootVal = preorder[preStart];\n        // 创建根节点\n        TreeNode root = new TreeNode(rootVal);\n        // 获取根节点在中序数组中的索引\n        int rootIndex = map.get(rootVal);\n        // 左子树的大小\n        int leftSize = rootIndex - inStart;\n        root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, \n                                    inorder, inStart, rootIndex - 1);\n        root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, \n                                    inorder, rootIndex + 1, inEnd);\n        return root;\n    }\n}\n```\n\n### [106. 从中序与后序遍历序列构造二叉树 (中等)](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    // 存放中序数组中值和索引的映射关系\n    private Map<Integer, Integer> map = new HashMap<>();\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if (inorder.length == 0 && postorder.length == 0) {\n            return null;\n        }\n        for (int i = 0; i < inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n        return buildTreeHelper(inorder, 0, inorder.length-1, postorder,0,postorder.length-1);\n    }\n\n    // 中序：左根右\n    // 后序：左右根\n    public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd,\n                            int[] postorder, int postStart, int postEnd) {\n        if (inStart > inEnd) {\n            return null;\n        }\n        // 根节点的值\n        int rootVal = postorder[postEnd];\n        // 创建根节点\n        TreeNode root = new TreeNode(rootVal);\n        // 根节点在中序数组中的下标\n        int rootIndex = map.get(rootVal);\n        // 左子树的长度\n        int leftSize = rootIndex - inStart;\n        root.left = buildTreeHelper(inorder, inStart, rootIndex - 1, \n                                postorder, postStart, postStart + leftSize - 1);\n        root.right = buildTreeHelper(inorder, rootIndex + 1, inEnd,\n                                postorder, postStart + leftSize, postEnd - 1);\n        return root;\n    }\n}\n```', '2021-05-25 15:14:09', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (71, 1, 14, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621928977041.jpg', '力扣刷题笔记之二叉树（三）', '### [652. 寻找重复的子树 (中等)](https://leetcode-cn.com/problems/find-duplicate-subtrees/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    // 存放所有子树出现的次数\n    private Map<String, Integer> subTreeMap = new HashMap<>();\n    // 存放重复子树的根节点\n    private List<TreeNode> res = new ArrayList<>();\n\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        postTraverse(root);\n        return res;\n    }\n\n    public String postTraverse(TreeNode root) {\n        if (root == null) {\n            return \"#\";\n        }\n        String left = postTraverse(root.left);\n        String right = postTraverse(root.right);\n        String subTree = left + \",\" + right + \",\" + root.val;\n        int count = subTreeMap.getOrDefault(subTree, 0);\n        if (count == 1) {\n            res.add(root);\n        }\n        subTreeMap.put(subTree, count + 1);\n        return subTree;\n    }\n}\n```', '2021-05-25 15:49:40', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (72, 1, 14, ' https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621929115889.jpg', '力扣刷题笔记之二叉搜索树（一）', '### [230. 二叉搜索树中第K小的元素 (中等)](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int res = 0; // 结果\n    private int rank = 0; // 排名\n\n    public int kthSmallest(TreeNode root, int k) {\n        traverse(root, k);\n        return res;\n    }\n\n    // 二叉搜索树中序遍历是升序的\n    public void traverse(TreeNode root, int k) {\n        if (root == null) {\n            return;\n        }\n        traverse(root.left, k);\n        /* 中序遍历处理代码 */\n        rank++;\n        if (k == rank) {\n            res = root.val;\n            return;\n        }\n        traverse(root.right, k);\n    }\n}\n```\n\n### [538. 把二叉搜索树转换为累加树 (中等)](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)\n\n此题与 [1038. 把二叉搜索树转换为累加树 (中等)](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/) 是一样的\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int sum = 0;\n    // 二叉搜索树按中序遍历的逆序遍历，是递减的\n    public TreeNode convertBST(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        convertBST(root.right);\n        sum += root.val;\n        root.val = sum;\n        convertBST(root.left);\n        return root;\n    }\n}\n```', '2021-05-25 15:51:59', NULL, 0, 0, 0);
INSERT INTO `tb_article` VALUES (73, 1, NULL, '', '2022-01-30', 'adwaw', '2022-01-30 11:27:10', NULL, 0, 1, 0);

-- ----------------------------
-- Table structure for tb_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_tag`;
CREATE TABLE `tb_article_tag`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `article_id` int(0) NOT NULL COMMENT '文章id',
  `tag_id` int(0) NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,
  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 348 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_article_tag
-- ----------------------------
INSERT INTO `tb_article_tag` VALUES (282, 40, 19);
INSERT INTO `tb_article_tag` VALUES (287, 42, 19);
INSERT INTO `tb_article_tag` VALUES (288, 42, 20);
INSERT INTO `tb_article_tag` VALUES (289, 43, 19);
INSERT INTO `tb_article_tag` VALUES (290, 43, 21);
INSERT INTO `tb_article_tag` VALUES (293, 44, 24);
INSERT INTO `tb_article_tag` VALUES (302, 48, 27);
INSERT INTO `tb_article_tag` VALUES (306, 51, 29);
INSERT INTO `tb_article_tag` VALUES (311, 49, 28);
INSERT INTO `tb_article_tag` VALUES (312, 52, 31);
INSERT INTO `tb_article_tag` VALUES (313, 53, 26);
INSERT INTO `tb_article_tag` VALUES (316, 54, 26);
INSERT INTO `tb_article_tag` VALUES (317, 46, 26);
INSERT INTO `tb_article_tag` VALUES (319, 57, 33);
INSERT INTO `tb_article_tag` VALUES (321, 59, 28);
INSERT INTO `tb_article_tag` VALUES (322, 55, 32);
INSERT INTO `tb_article_tag` VALUES (324, 47, 22);
INSERT INTO `tb_article_tag` VALUES (327, 63, 37);
INSERT INTO `tb_article_tag` VALUES (328, 62, 36);
INSERT INTO `tb_article_tag` VALUES (329, 61, 34);
INSERT INTO `tb_article_tag` VALUES (332, 65, 38);
INSERT INTO `tb_article_tag` VALUES (333, 65, 24);
INSERT INTO `tb_article_tag` VALUES (336, 64, 26);
INSERT INTO `tb_article_tag` VALUES (337, 64, 22);
INSERT INTO `tb_article_tag` VALUES (342, 67, 28);
INSERT INTO `tb_article_tag` VALUES (343, 68, 28);
INSERT INTO `tb_article_tag` VALUES (344, 69, 37);
INSERT INTO `tb_article_tag` VALUES (345, 70, 37);
INSERT INTO `tb_article_tag` VALUES (346, 71, 37);
INSERT INTO `tb_article_tag` VALUES (347, 72, 37);
INSERT INTO `tb_article_tag` VALUES (348, 72, 39);

-- ----------------------------
-- Table structure for tb_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_category`;
CREATE TABLE `tb_category`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '分类名',
  `create_time` datetime(0) DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_category
-- ----------------------------
INSERT INTO `tb_category` VALUES (13, '杂记', '2021-05-03 16:36:36');
INSERT INTO `tb_category` VALUES (14, 'leetcode', '2021-05-03 16:37:02');
INSERT INTO `tb_category` VALUES (15, '程序设计', '2021-05-03 16:37:30');
INSERT INTO `tb_category` VALUES (16, '数据结构', '2021-05-03 16:37:40');
INSERT INTO `tb_category` VALUES (17, 'Java基础', '2021-05-08 14:58:54');

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_id` int(0) NOT NULL COMMENT '评论用户Id',
  `article_id` int(0) DEFAULT NULL COMMENT '评论文章id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `create_time` datetime(0) NOT NULL COMMENT '评论时间',
  `reply_id` int(0) DEFAULT NULL COMMENT '回复用户id',
  `parent_id` int(0) DEFAULT NULL COMMENT '父评论id',
  `is_delete` tinyint(0) DEFAULT 0 COMMENT '是否删除  0否 1是',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_comment_user`(`user_id`) USING BTREE,
  INDEX `fk_comment_article`(`article_id`) USING BTREE,
  INDEX `fk_comment_parent`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 273 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_comment
-- ----------------------------
INSERT INTO `tb_comment` VALUES (272, 1, NULL, '123331313', '2022-02-09 11:22:16', NULL, NULL, 0);

-- ----------------------------
-- Table structure for tb_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `tb_friend_link`;
CREATE TABLE `tb_friend_link`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '链接名',
  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '链接头像',
  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '链接地址',
  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '链接介绍',
  `create_time` datetime(0) NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_friend_link_user`(`link_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_friend_link
-- ----------------------------
INSERT INTO `tb_friend_link` VALUES (12, '风丶宇的个人博客', 'https://static.talkxj.com/photos/b553f564f81a80dc338695acb1b475d2.jpg', 'https://www.talkxj.com/', '成事在人 谋事在天', '2021-03-20 23:40:33');
INSERT INTO `tb_friend_link` VALUES (13, 'ONESTARの客栈', 'https://onestar.newstar.net.cn/images/me.jpg', 'https://onestar.newstar.net.cn/', '欢迎来到我的客栈，我是一颗星，夜空中最亮的那颗', '2021-05-21 22:58:51');

-- ----------------------------
-- Table structure for tb_menu
-- ----------------------------
DROP TABLE IF EXISTS `tb_menu`;
CREATE TABLE `tb_menu`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜单名',
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜单路径',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '组件',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜单icon',
  `create_time` datetime(0) DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) DEFAULT NULL COMMENT '更新时间',
  `order_num` tinyint(0) DEFAULT NULL COMMENT '排序',
  `parent_id` int(0) DEFAULT NULL COMMENT '父id',
  `is_disable` tinyint(1) DEFAULT NULL COMMENT '是否禁用 0否1是',
  `is_hidden` tinyint(1) DEFAULT NULL COMMENT '是否隐藏  0否1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 204 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_menu
-- ----------------------------
INSERT INTO `tb_menu` VALUES (1, '首页', '/', '/home/Home.vue', 'el-icon-myshouye', '2021-01-26 17:06:51', '2021-01-26 17:06:53', 1, NULL, 0, 0);
INSERT INTO `tb_menu` VALUES (2, '文章管理', '/article-submenu', 'Layout', 'el-icon-mywenzhang-copy', '2021-01-25 20:43:07', '2021-01-25 20:43:09', 2, NULL, 0, 0);
INSERT INTO `tb_menu` VALUES (3, '消息管理', '/message-submenu', 'Layout', 'el-icon-myxiaoxi', '2021-01-25 20:44:17', '2021-01-25 20:44:20', 3, NULL, 0, 0);
INSERT INTO `tb_menu` VALUES (4, '系统管理', '/system-submenu', 'Layout', 'el-icon-myshezhi', '2021-01-25 20:45:57', '2021-01-25 20:45:59', 5, NULL, 0, 0);
INSERT INTO `tb_menu` VALUES (5, '个人中心', '/setting', '/setting/Setting.vue', 'el-icon-myuser', '2021-01-26 17:22:38', '2021-01-26 17:22:41', 7, NULL, 0, 0);
INSERT INTO `tb_menu` VALUES (6, '添加文章', '/articles', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:30:48', '2021-01-26 14:30:51', 1, 2, 0, 0);
INSERT INTO `tb_menu` VALUES (7, '修改文章', '/articles/*', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:31:32', '2021-01-26 14:31:34', 2, 2, 0, 1);
INSERT INTO `tb_menu` VALUES (8, '文章列表', '/article-list', '/article/ArticleList.vue', 'el-icon-mywenzhangliebiao', '2021-01-26 14:32:13', '2021-01-26 14:32:16', 3, 2, 0, 0);
INSERT INTO `tb_menu` VALUES (9, '分类管理', '/categories', '/category/Category.vue', 'el-icon-myfenlei', '2021-01-26 14:33:42', '2021-01-26 14:33:43', 4, 2, 0, 0);
INSERT INTO `tb_menu` VALUES (10, '标签管理', '/tags', '/tag/Tag.vue', 'el-icon-myicontag', '2021-01-26 14:34:33', '2021-01-26 14:34:36', 5, 2, 0, 0);
INSERT INTO `tb_menu` VALUES (11, '评论管理', '/comments', '/comment/Comment.vue', 'el-icon-mypinglunzu', '2021-01-26 14:35:31', '2021-01-26 14:35:34', 1, 3, 0, 0);
INSERT INTO `tb_menu` VALUES (12, '留言管理', '/messages', '/message/Message.vue', 'el-icon-myliuyan', '2021-01-26 14:36:09', '2021-01-26 14:36:13', 2, 3, 0, 0);
INSERT INTO `tb_menu` VALUES (13, '用户列表', '/users', '/user/User.vue', 'el-icon-myyonghuliebiao', '2021-01-26 14:38:09', '2021-01-26 14:38:12', 1, 202, 0, 0);
INSERT INTO `tb_menu` VALUES (14, '角色管理', '/roles', '/role/Role.vue', 'el-icon-myjiaoseliebiao', '2021-01-26 14:39:01', '2021-01-26 14:39:03', 2, 202, 0, 0);
INSERT INTO `tb_menu` VALUES (15, '资源管理', '/resources', '/resource/Resource.vue', 'el-icon-myxitong', '2021-01-26 14:40:14', '2021-01-26 14:40:16', 2, 4, 0, 0);
INSERT INTO `tb_menu` VALUES (16, '菜单管理', '/menus', '/menu/Menu.vue', 'el-icon-mycaidan', '2021-01-26 14:40:54', '2021-01-26 14:40:56', 1, 4, 0, 0);
INSERT INTO `tb_menu` VALUES (17, '友链管理', '/links', '/friendLink/FriendLink.vue', 'el-icon-mydashujukeshihuaico-', '2021-01-26 14:41:35', '2021-01-26 14:41:37', 3, 4, 0, 0);
INSERT INTO `tb_menu` VALUES (18, '关于我', '/about', '/about/About.vue', 'el-icon-myguanyuwo', '2021-01-26 14:42:05', '2021-01-26 14:42:10', 4, 4, 0, 0);
INSERT INTO `tb_menu` VALUES (19, '日志管理', '/log-submenu', 'Layout', 'el-icon-myguanyuwo', '2021-01-31 21:33:56', '2021-01-31 21:33:59', 6, NULL, 0, 0);
INSERT INTO `tb_menu` VALUES (20, '操作日志', '/operation/log', '/log/Operation.vue', 'el-icon-myguanyuwo', '2021-01-31 15:53:21', '2021-01-31 15:53:25', 1, 19, 0, 0);
INSERT INTO `tb_menu` VALUES (201, '在线用户', '/online/users', '/user/Online.vue', 'el-icon-myyonghuliebiao', '2021-02-05 14:59:51', '2021-02-05 14:59:53', 7, 202, 0, 0);
INSERT INTO `tb_menu` VALUES (202, '用户管理', '/users-submenu', 'Layout', 'el-icon-myyonghuliebiao', '2021-02-06 23:44:59', '2021-02-06 23:45:03', 4, NULL, 0, 0);

-- ----------------------------
-- Table structure for tb_message
-- ----------------------------
DROP TABLE IF EXISTS `tb_message`;
CREATE TABLE `tb_message`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户地址',
  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像',
  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '留言内容',
  `time` tinyint(1) DEFAULT NULL COMMENT '弹幕速度',
  `create_time` datetime(0) NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3439 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_message
-- ----------------------------
INSERT INTO `tb_message` VALUES (3436, '183.167.246.248', '安徽省安庆市 电信', '谁亦能呵一呵', 'http://thirdqq.qlogo.cn/g?b=oidb&k=aI2eHkWDtVbicAj3GnDvgAg&s=40&t=1586074784', '测试', 8, '2021-05-21 11:26:21');
INSERT INTO `tb_message` VALUES (3437, '183.167.246.248', '安徽省安庆市 电信', '游客', 'https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mp&v=1.4.14', 'ttttttt', 7, '2021-05-21 11:37:30');
INSERT INTO `tb_message` VALUES (3438, '183.167.246.248', '安徽省安庆市 电信', '游客', 'https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mp&v=1.4.14', '有呼呼呼呼呼', 8, '2021-05-21 11:43:05');
INSERT INTO `tb_message` VALUES (3439, '58.243.254.186', '安徽省合肥市 联通', '游客', 'https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mp&v=1.4.14', '我来了我来了我来了', 9, '2021-05-21 15:19:13');

-- ----------------------------
-- Table structure for tb_operation_log
-- ----------------------------
DROP TABLE IF EXISTS `tb_operation_log`;
CREATE TABLE `tb_operation_log`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作模块',
  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作类型',
  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作url',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作方法',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作描述',
  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '请求方式',
  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '返回数据',
  `user_id` int(0) DEFAULT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户昵称',
  `ip_addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作地址',
  `create_time` datetime(0) DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 150 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_operation_log
-- ----------------------------
INSERT INTO `tb_operation_log` VALUES (1, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"嘿嘿嘿嘿嘿嘿\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619175658596.jpg\",\"articleTitle\":\"嘿嘿嘿嘿嘿嘿\",\"categoryId\":12,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:01:04');
INSERT INTO `tb_operation_log` VALUES (2, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"哈哈哈哈哈哈哈哈哈哈\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619176571008.png\",\"articleTitle\":\"哈哈哈哈哈哈哈哈哈哈\",\"categoryId\":12,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:16:19');
INSERT INTO `tb_operation_log` VALUES (3, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"博客列表\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619177569874.jpg\",\"articleTitle\":\"博客列表\",\"categoryId\":12,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:32:54');
INSERT INTO `tb_operation_log` VALUES (4, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"快速排序\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619178469828.jpg\",\"articleTitle\":\"快速排序\",\"categoryId\":12,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:48:17');
INSERT INTO `tb_operation_log` VALUES (5, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[33],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:53:34');
INSERT INTO `tb_operation_log` VALUES (6, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[33],\"isDelete\":0}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:56:23');
INSERT INTO `tb_operation_log` VALUES (7, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"怎么了\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619179086860.jpg\",\"articleTitle\":\"怎么了\",\"categoryId\":12,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 19:58:21');
INSERT INTO `tb_operation_log` VALUES (8, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"堆排序\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619179185950.jpg\",\"articleTitle\":\"堆排序\",\"categoryId\":12,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 20:00:05');
INSERT INTO `tb_operation_log` VALUES (9, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"常见的垃圾回收器\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1619179355894.jpg\",\"articleTitle\":\"深入理解Java虚拟机\",\"categoryId\":12,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[18]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-04-23 20:02:43');
INSERT INTO `tb_operation_log` VALUES (10, '角色模块', '新增或修改', '/admin/role', 'top.bravecoder.blog.controller.RoleController.listRoles', '保存或更新角色', '[{\"id\":2,\"resourceIdList\":[227,239,234,235],\"roleLabel\":\"user\",\"roleName\":\"用户\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '127.0.0.1', '', '2021-05-01 22:59:12');
INSERT INTO `tb_operation_log` VALUES (11, '博客信息模块', '修改', '/admin/notice', 'top.bravecoder.blog.controller.BlogInfoController.updateNotice', '修改公告', '[\"欢迎访问zhang、的个人博客！\"]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, '管理员', '58.243.254.91', '安徽省合肥市 联通', '2021-05-03 09:24:05');
INSERT INTO `tb_operation_log` VALUES (12, '角色模块', '新增或修改', '/admin/role', 'top.bravecoder.blog.controller.RoleController.listRoles', '保存或更新角色', '[{\"id\":1,\"menuIdList\":[1,2,6,7,8,9,10,3,11,12,202,13,14,201,4,16,15,17,18,19,20],\"roleLabel\":\"admin\",\"roleName\":\"管理员\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '127.0.0.1', '', '2021-05-03 10:53:48');
INSERT INTO `tb_operation_log` VALUES (13, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 数据库\\n\\n### 数据表\\n\\n| 表名             | 中文含义         | 说明                                                         |\\n| ---------------- | ---------------- | ------------------------------------------------------------ |\\n| tb_article       | 文章表           | 存放文章标题、内容、分类id、发布时间、置顶状态等             |\\n| tb_category      | 分类表           | 存放分类名称、创建时间                                       |\\n| tb_tag           | 标签表           | 存放标签名称、创建时间                                       |\\n| tb_article_tag   | 文章标签关系表   | 文章与标签之类是多对多的关系，存放article_id、tag_id         |\\n| tb_friend_link   | 友链表           | 存放友链信息，名称、地址、介绍、头像、创建时间等             |\\n| tb_message       | 留言表           | 存放留言用户ip、地址、昵称、头像url、内容、时间等            |\\n| tb_comment       | 评论表           | 存放评论用户id、评论文章id、内容、回复用户id、父评论id等     |\\n| tb_operation_log | 操作日志表       | 记录管理也操作的日志，操作模块、类型、url、方法、描述、参数、请求方式、返回数据、用户id、昵称、操作ip、地址等 |\\n| tb_menu          | 菜单表           | 存放菜单名、菜单路径、组件、菜单icon、父菜单id、时间、状态信息等 |\\n| tb_resource      | 权限表           | 存放权限名、权限路径、请求方式、父权限id、时间、状态信息等   |\\n| tb_role          | 角色表           | 存放角色名、角色描述、时间、状态信息等                       |\\n| tb_role_menu     | 角色菜单关系表   | 菜单和角色是多对多的关系，存放role_id、menu_id               |\\n| tb_role_resource | 角色权限关系表   | 角色和权限是多对多的关系，存放role_id、resource_id           |\\n| tb_user_auth     | 用户登录信息表   | 存放用户个人信息id、用户名、密码、登录类型、ip、ip来源、时间等 |\\n| tb_user_info     | 用户个人信息表   | 存放邮箱、昵称、头像url、用户简介、个人网站、时间、是否禁用等 |\\n| tb_user_role     | 用户角色关系表   | 用户和角色是多对多的关系，存放user_id、role_id               |\\n| tb_unique_view   | 网站单日访问量表 | 存放网站每天的访问量信息，如时间、访问量                     |\\n\\n### 表关系\\n\\n+ 文章和标签是多对多的关系，即一个文章可以含有多个标签，一个标签也可以对应多个文章。所以使用tb_article_tag 来维护这个关系。\\n+ 菜单和角色是多对多的关系，一个菜单可以被多个角色访问，一个角色也可以访问多个菜单。\\n+ 角色和权限是多对多的关系，一个角色可以有多个访问权限，一个权限也可以被多个角色访问。\\n+ 用户和角色是多对多的关系，一个用户可以有多个角色，一个角色可以被多个用户拥有。\\n\\n> 注意\\n>\\n> + 用户的访问权限该博客是使用 SpringSecurity 来控制的，具体的见后序分析。\\n> + 用户对菜单的访问是在查询是用代码控制的。\\n>   + 用户id可以确定角色集合\\n>   + 角色可以确定访问的菜单集合\\n\\n### 建表语句\\n\\n```sql\\n-- ----------------------------\\n-- Table structure for tb_article 文章表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article`;\\nCREATE TABLE `tb_article`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'作者\',\\n  `category_id` int(11) DEFAULT NULL COMMENT \'文章分类\',\\n  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'文章缩略图\',\\n  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标题\',\\n  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'内容\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'发表时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_top` tinyint(1) DEFAULT NULL COMMENT \'是否置顶 0否 1是\',\\n  `is_draft` tinyint(1) DEFAULT 0 COMMENT \'是否为草稿 0否 1是\',\\n  `is_delete` tinyint(1) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `category_id`(`category_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_category 分类表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_category`;\\nCREATE TABLE `tb_category`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'分类名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_tag 标签表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_tag`;\\nCREATE TABLE `tb_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标签名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_article_tag 文章标签关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article_tag`;\\nCREATE TABLE `tb_article_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `article_id` int(11) NOT NULL COMMENT \'文章id\',\\n  `tag_id` int(11) NOT NULL COMMENT \'标签id\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,\\n  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_friend_link 友链表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_friend_link`;\\nCREATE TABLE `tb_friend_link`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接名\',\\n  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接头像\',\\n  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接地址\',\\n  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接介绍\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_friend_link_user`(`link_name`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_message 留言表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_message`;\\nCREATE TABLE `tb_message`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户地址\',\\n  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'昵称\',\\n  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'头像\',\\n  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'留言内容\',\\n  `time` tinyint(1) DEFAULT NULL COMMENT \'弹幕速度\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'发布时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 3435 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_comment 评论表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_comment`;\\nCREATE TABLE `tb_comment`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'评论用户Id\',\\n  `article_id` int(11) DEFAULT NULL COMMENT \'评论文章id\',\\n  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'评论内容\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'评论时间\',\\n  `reply_id` int(11) DEFAULT NULL COMMENT \'回复用户id\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父评论id\',\\n  `is_delete` tinyint(4) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_comment_user`(`user_id`) USING BTREE,\\n  INDEX `fk_comment_article`(`article_id`) USING BTREE,\\n  INDEX `fk_comment_parent`(`parent_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 268 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_operation_log 操作日志表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_operation_log`;\\nCREATE TABLE `tb_operation_log`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作模块\',\\n  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作类型\',\\n  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作url\',\\n  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作方法\',\\n  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作描述\',\\n  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'请求参数\',\\n  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'返回数据\',\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户昵称\',\\n  `ip_addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作地址\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_menu 菜单表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_menu`;\\nCREATE TABLE `tb_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单名\',\\n  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单路径\',\\n  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'组件\',\\n  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单icon\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `order_num` tinyint(4) DEFAULT NULL COMMENT \'排序\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父id\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否1是\',\\n  `is_hidden` tinyint(1) DEFAULT NULL COMMENT \'是否隐藏  0否1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 203 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_resource 权限表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_resource`;\\nCREATE TABLE `tb_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'资源名\',\\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'权限路径\',\\n  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父权限id\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'修改时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否 1是\',\\n  `is_anonymous` tinyint(4) DEFAULT NULL COMMENT \'是否匿名访问 0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 250 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role 角色表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role`;\\nCREATE TABLE `tb_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色名\',\\n  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色描述\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_menu 角色菜单关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_menu`;\\nCREATE TABLE `tb_role_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `menu_id` int(11) DEFAULT NULL COMMENT \'菜单id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 1265 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_resource 角色权限关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_resource`;\\nCREATE TABLE `tb_role_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `resource_id` int(11) DEFAULT NULL COMMENT \'权限id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4181 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_auth 用户登录信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_auth`;\\nCREATE TABLE `tb_user_auth`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_info_id` int(11) NOT NULL COMMENT \'用户信息id\',\\n  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户名\',\\n  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'密码\',\\n  `login_type` tinyint(1) NOT NULL COMMENT \'登录类型\',\\n  `ip_addr` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户登录ip\',\\n  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'ip来源\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `last_login_time` datetime(0) DEFAULT NULL COMMENT \'上次登录时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  UNIQUE INDEX `username`(`username`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 201 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_info 用户个人信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_info`;\\nCREATE TABLE `tb_user_info`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'邮箱号\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户昵称\',\\n  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT \'\' COMMENT \'用户头像\',\\n  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户简介\',\\n  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'个人网站\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT 0 COMMENT \'是否禁用\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 212 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_role 用户角色关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_role`;\\nCREATE TABLE `tb_user_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 221 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_unique_view 网站单日访问量表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_unique_view`;\\nCREATE TABLE `tb_unique_view`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `create_time` datetime(0) NOT NULL COMMENT \'时间\',\\n  `views_count` int(11) NOT NULL COMMENT \'访问量\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 225 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n```\\n\\n## 博客整体概览\\n\\n### 包结构\\n\\n| 包名       | 说明                                                         |\\n| ---------- | ------------------------------------------------------------ |\\n| annotation | 自定义注解                                                   |\\n| config     | 自定义配置类，MybatisPlus、Redis、Swagger的配置类等          |\\n| constant   | 自定义的常量类，Redis的key常量、操作类型、状态码等           |\\n| controller | 控制层代码                                                   |\\n| dao        | 持久层接口                                                   |\\n| dto        | 把后端返回前端的数据封装成DTO                                |\\n| entity     | 实体类                                                       |\\n| enums      | 自定义枚举类，登录类型、角色枚举、操作类型等                 |\\n| exception  | 自定义异常类                                                 |\\n| handler    | 自定义处理器，SpringSecurity的自定义handler、日志切面类、监听器等 |\\n| service    | 业务层代码                                                   |\\n| util       | 工具类，日期、OSS、ip等工具类                                |\\n| vo         | 用于接收前端传来的数据，把这些数据封装成VO便于接收参数       |\\n\\n### 核心功能\\n\\n#### 操作日志记录\\n\\n对所有加了 `@OptLog  ` 注解（通过 `optType` 指明操作类型）的方法进行日志记录。\\n\\n**操作日志注解 annotation.OptLog**\\n\\n```java\\n/**\\n * 操作日志注解\\n */\\n@Target(ElementType.METHOD)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Documented\\npublic @interface OptLog {\\n    /**\\n     * @return 操作类型\\n     */\\n    String optType() default \\\"\\\";\\n}\\n```\\n\\n**操作类型常量类 constant.OptTypeConst**\\n\\n```java\\n/**\\n * 操作日志类型常量\\n */\\npublic class OptTypeConst {\\n\\n    /**\\n     * 新增操作\\n     */\\n    public static final String SAVE_OR_UPDATE = \\\"新增或修改\\\";\\n\\n    /**\\n     * 新增\\n     */\\n    public static final String SAVE = \\\"新增\\\";\\n\\n    /**\\n     * 修改操作\\n     */\\n    public static final String UPDATE = \\\"修改\\\";\\n\\n    /**\\n     * 删除操作\\n     */\\n    public static final String REMOVE = \\\"删除\\\";\\n\\n    /**\\n     * 上传操作\\n     */\\n    public static final String UPLOAD = \\\"上传\\\";\\n}\\n```\\n\\n**日志切面类 handler.OptLogAspect **\\n\\n```java\\n/**\\n * 操作日志切面处理\\n */\\n@Component\\npublic class OptLogAspect {\\n\\n    @Autowired\\n    private OperationLogDao operationLogDao;\\n\\n    /**\\n     * 设置操作日志切入点 记录操作日志 在注解的位置切入代码\\n     */\\n    @Pointcut(\\\"@annotation(top.bravecoder.blog.annotation.OptLog)\\\")\\n    public void optLogPointCut() {\\n    }\\n\\n    /**\\n     * 正常返回通知，拦截用户操作日志，连接点正常执行完成后执行， 如果连接点抛出异常，则不会执行\\n     * @param joinPoint 切入点\\n     * @param keys      返回结果\\n     */\\n    @Async\\n    @Transactional(rollbackFor = Exception.class)\\n    @AfterReturning(value = \\\"optLogPointCut()\\\", returning = \\\"keys\\\")\\n    public void saveOptLog(JoinPoint joinPoint, Object keys) {\\n        // 获取RequestAttributes\\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\\n        // 从获取RequestAttributes中获取HttpServletRequest的信息\\n        HttpServletRequest request = (HttpServletRequest) Objects.requireNonNull(requestAttributes).resolveReference(RequestAttributes.REFERENCE_REQUEST);\\n        OperationLog operationLog = new OperationLog();\\n        // 从切面织入点处通过反射机制获取织入点处的方法\\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\\n        // 获取切入点所在的方法\\n        Method method = signature.getMethod();\\n        // 获取操作\\n        Api api = (Api) signature.getDeclaringType().getAnnotation(Api.class);\\n        ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);\\n        OptLog optLog = method.getAnnotation(OptLog.class);\\n        // 操作模块\\n        operationLog.setOptModule(api.tags()[0]);\\n        // 操作类型\\n        operationLog.setOptType(optLog.optType());\\n        // 操作描述\\n        operationLog.setOptDesc(apiOperation.value());\\n        // 获取请求的类名\\n        String className = joinPoint.getTarget().getClass().getName();\\n        // 获取请求的方法名\\n        String methodName = method.getName();\\n        methodName = className + \\\".\\\" + methodName;\\n        // 请求方式\\n        operationLog.setRequestMethod(Objects.requireNonNull(request).getMethod());\\n        // 请求方法\\n        operationLog.setOptMethod(methodName);\\n        // 请求参数\\n        operationLog.setRequestParam(JSON.toJSONString(joinPoint.getArgs()));\\n        // 返回结果\\n        operationLog.setResponseData(JSON.toJSONString(keys));\\n        // 请求用户ID\\n        operationLog.setUserId(UserUtil.getLoginUser().getId());\\n        // 请求用户\\n        operationLog.setNickname(UserUtil.getLoginUser().getNickname());\\n        // 请求IP\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        operationLog.setIpAddr(ipAddr);\\n        operationLog.setIpSource(IpUtil.getIpSource(ipAddr));\\n        // 请求URL\\n        operationLog.setOptUrl(request.getRequestURI());\\n        // 创建时间\\n        operationLog.setCreateTime(new Date());\\n        operationLogDao.insert(operationLog);\\n    }\\n}\\n```\\n\\n对需要的进行日志记录的方法上加上 `@OptLog  ` 注解，并通过 `OptTypeConst` 常量类指明对应的操作类型，日志切面类 `OptLogAspect` 会进行日志记录，读取方法上的注解，把数据封装成 `OperationLog` 对象，插入数据库。\\n\\n#### 异常处理\\n\\n**自定义异常类 exception.ServeException **\\n\\n```java\\n/**\\n * 自定义异常类\\n */\\npublic class ServeException extends RuntimeException {\\n    public ServeException(String message) {\\n        super(message);\\n    }\\n}\\n\\n```\\n\\n**返回状态码常量 constant.StatusConst ** \\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * 返回码常量\\n */\\npublic class StatusConst {\\n\\n    /**\\n     * 成功\\n     */\\n    public static final int OK = 20000;\\n\\n    /**\\n     * 失败\\n     */\\n    public static final int ERROR = 20001;\\n\\n    /**\\n     * 系统异常\\n     */\\n    public static final int SYSTEM_ERROR = 50000;\\n\\n    /**\\n     * 未登录\\n     */\\n    public static final int NOT_LOGIN = 40001;\\n\\n    /**\\n     * 没有操作权限\\n     */\\n    public static final int AUTHORIZED = 40003;\\n}\\n```\\n\\n**全局异常处理类 controller.ControllerAdvice**\\n\\n```java\\n/**\\n * 全局异常处理\\n */\\n@RestControllerAdvice\\npublic class ControllerAdvice {\\n\\n    /**\\n     * 处理服务异常\\n     * @param e\\n     * @return\\n     */\\n    @ExceptionHandler(value = ServeException.class)\\n    public Result errorHandler(ServeException e) {\\n        return new Result(false, StatusConst.ERROR, e.getMessage());\\n    }\\n\\n    /**\\n     * 处理参数异常\\n     */\\n    @ExceptionHandler(MethodArgumentNotValidException.class)\\n    public Result errorHandler(MethodArgumentNotValidException e) {\\n        return new Result(false, StatusConst.ERROR, e.getBindingResult().getFieldError().getDefaultMessage());\\n    }\\n\\n    /**\\n     * 处理系统异常\\n     */\\n    @ExceptionHandler(value = Exception.class)\\n    public Result errorHandler(Exception e) {\\n        return new Result(false, StatusConst.SYSTEM_ERROR, \\\"系统异常\\\");\\n    }\\n}\\n```\\n\\n#### SpringScurity 权限控制\\n\\n**SpringSecurity 配置类 config.WebSecurityConfig**\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n**用户登录信息，UserDetails 的实现类 UserInfoDTO **\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**自定义登录校验 UserDetailsServiceImpl**\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n**登录成功处理器 handler.AuthenticationSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功！\\\", userLoginDTO)));\\n    }\\n\\n    /**\\n     * 更新用户信息\\n     */\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n**登录失败处理器 handler.AuthenticationFailHandlerImpl**\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n**权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl**\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n**用户未登录处理 hanlder.AuthenticationEntryPointImpl**\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n**自定义的 FilterInvocationSecurityMetadataSource**\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n**自定决策器 AccessDecisionManagerImpl**\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\\n#### Redis 使用场景\\n\\n**Redis 配置类**\\n\\n```java\\npackage top.bravecoder.blog.config;\\n\\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n/**\\n * redis配置\\n * @author zhangzhi\\n */\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\\n        redisTemplate.setConnectionFactory(factory);\\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\\n        ObjectMapper mapper = new ObjectMapper();\\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\\n        // mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL,\\n                JsonTypeInfo.As.PROPERTY);\\n        jackson2JsonRedisSerializer.setObjectMapper(mapper);\\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\\n        // key采用String的序列化方式\\n        redisTemplate.setKeySerializer(stringRedisSerializer);\\n        // hash的key也采用String的序列化方式\\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\\n        // value序列化方式采用jackson\\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\\n        // hash的value序列化方式采用jackson\\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\\n        redisTemplate.afterPropertiesSet();\\n        return redisTemplate;\\n    }\\n}\\n```\\n\\n**Redis常量**\\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * redis常量\\n */\\npublic class RedisPrefixConst {\\n\\n    /**\\n     * 验证码过期时间\\n     */\\n    public static final long CODE_EXPIRE_TIME = 15 * 60 * 1000;\\n\\n    /**\\n     * 验证码\\n     */\\n    public static final String CODE_KEY = \\\"code_\\\";\\n\\n    /**\\n     * 博客总浏览量\\n     */\\n    public static final String BLOG_VIEWS_COUNT = \\\"blog_views_count\\\";\\n\\n    /**\\n     * 文章浏览量\\n     */\\n    public static final String ARTICLE_VIEWS_COUNT = \\\"article_views_count\\\";\\n\\n    /**\\n     * 文章点赞量\\n     */\\n    public static final String ARTICLE_LIKE_COUNT = \\\"article_like_count\\\";\\n\\n    /**\\n     * 用户点赞文章\\n     */\\n    public static final String ARTICLE_USER_LIKE = \\\"article_user_like\\\";\\n\\n    /**\\n     * 评论点赞量\\n     */\\n    public static final String COMMENT_LIKE_COUNT = \\\"comment_like_count\\\";\\n\\n    /**\\n     * 用户点赞评论\\n     */\\n    public static final String COMMENT_USER_LIKE = \\\"comment_user_like\\\";\\n\\n    /**\\n     * 关于我信息\\n     */\\n    public static final String ABOUT = \\\"about\\\";\\n\\n    /**\\n     * 公告\\n     */\\n    public static final String NOTICE = \\\"notice\\\";\\n\\n    /**\\n     * ip集合\\n     */\\n    public static final String IP_SET = \\\"ip_set\\\";\\n}\\n```\\n\\n+ 用户注册时，存放验证码，**string**\\n\\n  ```java\\n  // 将验证码存入redis，设置过期时间为15分钟\\n  redisTemplate.boundValueOps(CODE_KEY + username).set(code);\\n  redisTemplate.expire(CODE_KEY + username, CODE_EXPIRE_TIME, TimeUnit.MILLISECONDS);\\n  ```\\n\\n+ 存放博客的总浏览量，**string**\\n\\n   ```java\\n   // 判断当前ip是否访问，增加访问量\\n  String ipAddr = IpUtil.getIpAddr(request);\\n  if (!ipAddr.equals(ip)) {\\n      session.setAttribute(\\\"ip\\\", ipAddr);\\n      // 博客总浏览量 +1\\n      redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n  }\\n   ```\\n\\n+ 存放文章的浏览量，**hash**\\n\\n  ```java\\n  // 判断是否第一次访问，增加浏览量\\n  Set<Integer> set = (Set<Integer>) session.getAttribute(\\\"articleSet\\\");\\n  if (Objects.isNull(set)) {\\n      set = new HashSet<>();\\n  }\\n  if (!set.contains(articleId)) {\\n      set.add(articleId);\\n      session.setAttribute(\\\"articleSet\\\", set);\\n      // 浏览量+1\\n      redisTemplate.boundHashOps(ARTICLE_VIEWS_COUNT).increment(articleId.toString(), 1);\\n  }\\n  ```\\n\\n+ 存放所有文章各自的点赞量和用户点赞的文章集合，**hash**\\n\\n```java\\n public void saveArticleLike(Integer articleId) {\\n        // 查询当前用户点赞过的文章id集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(articleLikeSet)) {\\n            articleLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (articleLikeSet.contains(articleId)) {\\n            // 点过赞则删除文章id\\n            articleLikeSet.remove(articleId);\\n            // 文章点赞量-1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), -1);\\n        } else {\\n            // 未点赞则增加文章id\\n            articleLikeSet.add(articleId);\\n            // 文章点赞量+1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), 1);\\n        }\\n        // 保存用户的点赞记录\\n  redisTemplate.boundHashOps(ARTICLE_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), articleLikeSet);\\n    }\\n```\\n\\n+ 存放所有评论各自的点赞量和用户点赞的评论集合，与上面类似，**hash**\\n\\n```java\\n public void saveCommentLike(Integer commentId) {\\n        // 查询当前用户点赞过的评论id集合\\n        HashSet<Integer> commentLikeSet = (HashSet<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(commentLikeSet)) {\\n            commentLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (commentLikeSet.contains(commentId)) {\\n            // 点过赞则删除评论id\\n            commentLikeSet.remove(commentId);\\n            // 评论点赞量-1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), -1);\\n        } else {\\n            // 未点赞则增加评论id\\n            commentLikeSet.add(commentId);\\n            // 评论点赞量+1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), 1);\\n        }\\n        // 保存点赞记录\\n  redisTemplate.boundHashOps(COMMENT_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), commentLikeSet);\\n    }\\n```\\n\\n+ 存放关于我、公告信息，**string**\\n\\n  ```java\\n  public void updateAbout(String aboutContent) {\\n      redisTemplate.boundValueOps(ABOUT).set(aboutContent);\\n  }\\n\\n  public void updateNotice(String notice) {\\n      redisTemplate.boundValueOps(NOTICE).set(notice);\\n  }\\n\\n  ```\\n\\n+ 存放ip，统计每日用户量，**set**\\n\\n  暂时存储每天的ip集合，定时把当天的访问量存储到数据库，定时删除\\n\\n  ```java\\n\\n  /**\\n   * request监听\\n   */\\n  @Component\\n  public class ServletRequestListenerImpl implements ServletRequestListener {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n\\n      @Override\\n      public void requestInitialized(ServletRequestEvent sre) {\\n          HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\\n          HttpSession session = request.getSession();\\n          String ip = (String) session.getAttribute(\\\"ip\\\");\\n          // 判断当前ip是否访问，增加访问量\\n          String ipAddr = IpUtil.getIpAddr(request);\\n          if (!ipAddr.equals(ip)) {\\n              session.setAttribute(\\\"ip\\\", ipAddr);\\n              redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n          }\\n          // 将ip存入redis，统计每日用户量\\n          redisTemplate.boundSetOps(IP_SET).add(ipAddr);\\n      }\\n\\n      // 每天凌晨0点1分执行一次\\n      @Scheduled(cron = \\\" 0 1 0 * * ?\\\")\\n      private void clear() {\\n          // 清空redis中的ip\\n          redisTemplate.delete(IP_SET);\\n      }\\n  }\\n\\n  -----------------------------------------------------------\\n  @Service\\n  public class UniqueViewServiceImpl extends ServiceImpl<UniqueViewDao, UniqueView> implements UniqueViewService {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n      @Autowired\\n      private UniqueViewDao uniqueViewDao;\\n\\n      // 每天 0 点执行一次\\n      @Scheduled(cron = \\\" 0 0 0 * * ?\\\")\\n      @Override\\n      public void saveUniqueView() {\\n          // 获取每天用户量\\n          Long count = redisTemplate.boundSetOps(\\\"ip_set\\\").size();\\n          // 获取昨天日期插入数据\\n          UniqueView uniqueView = UniqueView.builder()\\n                  .createTime(DateUtil.getSomeDay(new Date(), -1))\\n                  .viewsCount(Objects.nonNull(count) ? count.intValue() : 0).build();\\n          uniqueViewDao.insert(uniqueView);\\n      }\\n  }\\n  ```\\n\\n#### RabbitMQ使用场景\\n\\n**常量类**\\n\\n```java\\n/**\\n * MQ常量\\n */\\npublic class MQPrefixConst {\\n\\n    /**\\n     * email交换机\\n     */\\n    public static final String EMAIL_EXCHANGE = \\\"send\\\";\\n\\n    /**\\n     * 邮件队列\\n     */\\n    public static final String EMAIL_QUEUE = \\\"email\\\";\\n}\\n```\\n\\n**RabbitMQ配置类**\\n\\n```java\\n/**\\n * Rabbitmq配置类\\n */\\n@Configuration\\npublic class RabbitConfig {\\n\\n    // 创建队列\\n    @Bean\\n    public Queue emailQueue() {\\n        return new Queue(MQPrefixConst.EMAIL_QUEUE, true);\\n    }\\n\\n    // 创建交换机\\n    @Bean\\n    public FanoutExchange emailExchange() {\\n        return new FanoutExchange(MQPrefixConst.EMAIL_EXCHANGE, true, false);\\n    }\\n\\n    // 把队列和交换机绑定在一起\\n    @Bean\\n    public Binding bindingEmailDirect() {\\n        return BindingBuilder.bind(emailQueue()).to(emailExchange());\\n    }\\n}\\n```\\n\\n**消费者 EmailReceiver**\\n\\n```java\\n/**\\n * 监听EMAIL_QUEUE，发送邮件\\n */\\n@Component\\n@RabbitListener(queues = MQPrefixConst.EMAIL_QUEUE)\\npublic class EmailReceiver {\\n    /**\\n     * 邮箱号\\n     */\\n    @Value(\\\"${spring.mail.username}\\\")\\n    private String email;\\n\\n    @Autowired\\n    private JavaMailSender javaMailSender;\\n\\n    @RabbitHandler\\n    public void process(byte[] data) {\\n        EmailDTO emailDTO = JSON.parseObject(new String(data), EmailDTO.class);\\n        SimpleMailMessage message = new SimpleMailMessage();\\n        message.setFrom(email);\\n        message.setTo(emailDTO.getEmail());\\n        message.setSubject(emailDTO.getSubject());\\n        message.setText(emailDTO.getContent());\\n        javaMailSender.send(message);\\n    }\\n}\\n```\\n\\n**场景一**\\n\\n用户注册时，对邮箱发送验证码\\n\\n```java\\nrabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", new Message(JSON.toJSONBytes(emailDTO), \\n                new MessageProperties()));\\n```\\n\\n**场景二**\\n\\n用户的评论收到回复时，发邮件进行通知\\n\\n```java\\n/**\\n * 通知评论用户\\n */\\n@Async\\npublic void notice(CommentVO commentVO) {\\n    // 判断是回复用户还是评论作者\\n    Integer userId = Objects.nonNull(commentVO.getReplyId()) ? commentVO.getReplyId() : BLOGGER_ID;\\n    // 查询邮箱号\\n    String email = userInfoDao.selectById(userId).getEmail();\\n    if (StringUtils.isNotBlank(email)) {\\n        // 判断页面路径\\n        String url = Objects.nonNull(commentVO.getArticleId()) ? URL + ARTICLE_PATH + commentVO.getArticleId() : URL + LINK_PATH;\\n        // 发送消息\\n        EmailDTO emailDTO = EmailDTO.builder()\\n            .email(email)\\n            .subject(\\\"评论提醒\\\")\\n            .content(\\\"您收到了一条新的回复，请前往\\\" + url + \\\"\\\\n页面查看\\\")\\n            .build();\\n        rabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", \\n                       new Message(JSON.toJSONBytes(emailDTO), new MessageProperties()));\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"博客内容梳理\",\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:36:24');
INSERT INTO `tb_operation_log` VALUES (14, '分类模块', '新增或修改', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"杂记\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:36:37');
INSERT INTO `tb_operation_log` VALUES (15, '分类模块', '新增或修改', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"leetcode刷题记录\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:37:02');
INSERT INTO `tb_operation_log` VALUES (16, '分类模块', '新增或修改', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"leetcode\",\"id\":14}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:37:22');
INSERT INTO `tb_operation_log` VALUES (17, '分类模块', '新增或修改', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"程序设计\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:37:30');
INSERT INTO `tb_operation_log` VALUES (18, '分类模块', '新增或修改', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"数据结构\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:37:40');
INSERT INTO `tb_operation_log` VALUES (19, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"博客\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:37:57');
INSERT INTO `tb_operation_log` VALUES (20, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 数据库\\n\\n### 数据表\\n\\n| 表名             | 中文含义         | 说明                                                         |\\n| ---------------- | ---------------- | ------------------------------------------------------------ |\\n| tb_article       | 文章表           | 存放文章标题、内容、分类id、发布时间、置顶状态等             |\\n| tb_category      | 分类表           | 存放分类名称、创建时间                                       |\\n| tb_tag           | 标签表           | 存放标签名称、创建时间                                       |\\n| tb_article_tag   | 文章标签关系表   | 文章与标签之类是多对多的关系，存放article_id、tag_id         |\\n| tb_friend_link   | 友链表           | 存放友链信息，名称、地址、介绍、头像、创建时间等             |\\n| tb_message       | 留言表           | 存放留言用户ip、地址、昵称、头像url、内容、时间等            |\\n| tb_comment       | 评论表           | 存放评论用户id、评论文章id、内容、回复用户id、父评论id等     |\\n| tb_operation_log | 操作日志表       | 记录管理也操作的日志，操作模块、类型、url、方法、描述、参数、请求方式、返回数据、用户id、昵称、操作ip、地址等 |\\n| tb_menu          | 菜单表           | 存放菜单名、菜单路径、组件、菜单icon、父菜单id、时间、状态信息等 |\\n| tb_resource      | 权限表           | 存放权限名、权限路径、请求方式、父权限id、时间、状态信息等   |\\n| tb_role          | 角色表           | 存放角色名、角色描述、时间、状态信息等                       |\\n| tb_role_menu     | 角色菜单关系表   | 菜单和角色是多对多的关系，存放role_id、menu_id               |\\n| tb_role_resource | 角色权限关系表   | 角色和权限是多对多的关系，存放role_id、resource_id           |\\n| tb_user_auth     | 用户登录信息表   | 存放用户个人信息id、用户名、密码、登录类型、ip、ip来源、时间等 |\\n| tb_user_info     | 用户个人信息表   | 存放邮箱、昵称、头像url、用户简介、个人网站、时间、是否禁用等 |\\n| tb_user_role     | 用户角色关系表   | 用户和角色是多对多的关系，存放user_id、role_id               |\\n| tb_unique_view   | 网站单日访问量表 | 存放网站每天的访问量信息，如时间、访问量                     |\\n\\n### 表关系\\n\\n+ 文章和标签是多对多的关系，即一个文章可以含有多个标签，一个标签也可以对应多个文章。所以使用tb_article_tag 来维护这个关系。\\n+ 菜单和角色是多对多的关系，一个菜单可以被多个角色访问，一个角色也可以访问多个菜单。\\n+ 角色和权限是多对多的关系，一个角色可以有多个访问权限，一个权限也可以被多个角色访问。\\n+ 用户和角色是多对多的关系，一个用户可以有多个角色，一个角色可以被多个用户拥有。\\n\\n> 注意\\n>\\n> + 用户的访问权限该博客是使用 SpringSecurity 来控制的，具体的见后序分析。\\n> + 用户对菜单的访问是在查询是用代码控制的。\\n>   + 用户id可以确定角色集合\\n>   + 角色可以确定访问的菜单集合\\n\\n### 建表语句\\n\\n```sql\\n-- ----------------------------\\n-- Table structure for tb_article 文章表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article`;\\nCREATE TABLE `tb_article`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'作者\',\\n  `category_id` int(11) DEFAULT NULL COMMENT \'文章分类\',\\n  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'文章缩略图\',\\n  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标题\',\\n  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'内容\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'发表时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_top` tinyint(1) DEFAULT NULL COMMENT \'是否置顶 0否 1是\',\\n  `is_draft` tinyint(1) DEFAULT 0 COMMENT \'是否为草稿 0否 1是\',\\n  `is_delete` tinyint(1) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `category_id`(`category_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_category 分类表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_category`;\\nCREATE TABLE `tb_category`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'分类名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_tag 标签表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_tag`;\\nCREATE TABLE `tb_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标签名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_article_tag 文章标签关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article_tag`;\\nCREATE TABLE `tb_article_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `article_id` int(11) NOT NULL COMMENT \'文章id\',\\n  `tag_id` int(11) NOT NULL COMMENT \'标签id\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,\\n  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_friend_link 友链表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_friend_link`;\\nCREATE TABLE `tb_friend_link`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接名\',\\n  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接头像\',\\n  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接地址\',\\n  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接介绍\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_friend_link_user`(`link_name`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_message 留言表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_message`;\\nCREATE TABLE `tb_message`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户地址\',\\n  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'昵称\',\\n  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'头像\',\\n  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'留言内容\',\\n  `time` tinyint(1) DEFAULT NULL COMMENT \'弹幕速度\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'发布时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 3435 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_comment 评论表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_comment`;\\nCREATE TABLE `tb_comment`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'评论用户Id\',\\n  `article_id` int(11) DEFAULT NULL COMMENT \'评论文章id\',\\n  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'评论内容\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'评论时间\',\\n  `reply_id` int(11) DEFAULT NULL COMMENT \'回复用户id\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父评论id\',\\n  `is_delete` tinyint(4) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_comment_user`(`user_id`) USING BTREE,\\n  INDEX `fk_comment_article`(`article_id`) USING BTREE,\\n  INDEX `fk_comment_parent`(`parent_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 268 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_operation_log 操作日志表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_operation_log`;\\nCREATE TABLE `tb_operation_log`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作模块\',\\n  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作类型\',\\n  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作url\',\\n  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作方法\',\\n  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作描述\',\\n  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'请求参数\',\\n  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'返回数据\',\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户昵称\',\\n  `ip_addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作地址\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_menu 菜单表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_menu`;\\nCREATE TABLE `tb_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单名\',\\n  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单路径\',\\n  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'组件\',\\n  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单icon\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `order_num` tinyint(4) DEFAULT NULL COMMENT \'排序\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父id\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否1是\',\\n  `is_hidden` tinyint(1) DEFAULT NULL COMMENT \'是否隐藏  0否1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 203 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_resource 权限表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_resource`;\\nCREATE TABLE `tb_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'资源名\',\\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'权限路径\',\\n  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父权限id\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'修改时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否 1是\',\\n  `is_anonymous` tinyint(4) DEFAULT NULL COMMENT \'是否匿名访问 0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 250 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role 角色表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role`;\\nCREATE TABLE `tb_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色名\',\\n  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色描述\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_menu 角色菜单关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_menu`;\\nCREATE TABLE `tb_role_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `menu_id` int(11) DEFAULT NULL COMMENT \'菜单id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 1265 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_resource 角色权限关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_resource`;\\nCREATE TABLE `tb_role_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `resource_id` int(11) DEFAULT NULL COMMENT \'权限id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4181 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_auth 用户登录信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_auth`;\\nCREATE TABLE `tb_user_auth`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_info_id` int(11) NOT NULL COMMENT \'用户信息id\',\\n  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户名\',\\n  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'密码\',\\n  `login_type` tinyint(1) NOT NULL COMMENT \'登录类型\',\\n  `ip_addr` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户登录ip\',\\n  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'ip来源\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `last_login_time` datetime(0) DEFAULT NULL COMMENT \'上次登录时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  UNIQUE INDEX `username`(`username`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 201 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_info 用户个人信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_info`;\\nCREATE TABLE `tb_user_info`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'邮箱号\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户昵称\',\\n  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT \'\' COMMENT \'用户头像\',\\n  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户简介\',\\n  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'个人网站\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT 0 COMMENT \'是否禁用\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 212 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_role 用户角色关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_role`;\\nCREATE TABLE `tb_user_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 221 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_unique_view 网站单日访问量表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_unique_view`;\\nCREATE TABLE `tb_unique_view`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `create_time` datetime(0) NOT NULL COMMENT \'时间\',\\n  `views_count` int(11) NOT NULL COMMENT \'访问量\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 225 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n```\\n\\n## 博客整体概览\\n\\n### 包结构\\n\\n| 包名       | 说明                                                         |\\n| ---------- | ------------------------------------------------------------ |\\n| annotation | 自定义注解                                                   |\\n| config     | 自定义配置类，MybatisPlus、Redis、Swagger的配置类等          |\\n| constant   | 自定义的常量类，Redis的key常量、操作类型、状态码等           |\\n| controller | 控制层代码                                                   |\\n| dao        | 持久层接口                                                   |\\n| dto        | 把后端返回前端的数据封装成DTO                                |\\n| entity     | 实体类                                                       |\\n| enums      | 自定义枚举类，登录类型、角色枚举、操作类型等                 |\\n| exception  | 自定义异常类                                                 |\\n| handler    | 自定义处理器，SpringSecurity的自定义handler、日志切面类、监听器等 |\\n| service    | 业务层代码                                                   |\\n| util       | 工具类，日期、OSS、ip等工具类                                |\\n| vo         | 用于接收前端传来的数据，把这些数据封装成VO便于接收参数       |\\n\\n### 核心功能\\n\\n#### 操作日志记录\\n\\n对所有加了 `@OptLog  ` 注解（通过 `optType` 指明操作类型）的方法进行日志记录。\\n\\n**操作日志注解 annotation.OptLog**\\n\\n```java\\n/**\\n * 操作日志注解\\n */\\n@Target(ElementType.METHOD)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Documented\\npublic @interface OptLog {\\n    /**\\n     * @return 操作类型\\n     */\\n    String optType() default \\\"\\\";\\n}\\n```\\n\\n**操作类型常量类 constant.OptTypeConst**\\n\\n```java\\n/**\\n * 操作日志类型常量\\n */\\npublic class OptTypeConst {\\n\\n    /**\\n     * 新增操作\\n     */\\n    public static final String SAVE_OR_UPDATE = \\\"新增或修改\\\";\\n\\n    /**\\n     * 新增\\n     */\\n    public static final String SAVE = \\\"新增\\\";\\n\\n    /**\\n     * 修改操作\\n     */\\n    public static final String UPDATE = \\\"修改\\\";\\n\\n    /**\\n     * 删除操作\\n     */\\n    public static final String REMOVE = \\\"删除\\\";\\n\\n    /**\\n     * 上传操作\\n     */\\n    public static final String UPLOAD = \\\"上传\\\";\\n}\\n```\\n\\n**日志切面类 handler.OptLogAspect **\\n\\n```java\\n/**\\n * 操作日志切面处理\\n */\\n@Component\\npublic class OptLogAspect {\\n\\n    @Autowired\\n    private OperationLogDao operationLogDao;\\n\\n    /**\\n     * 设置操作日志切入点 记录操作日志 在注解的位置切入代码\\n     */\\n    @Pointcut(\\\"@annotation(top.bravecoder.blog.annotation.OptLog)\\\")\\n    public void optLogPointCut() {\\n    }\\n\\n    /**\\n     * 正常返回通知，拦截用户操作日志，连接点正常执行完成后执行， 如果连接点抛出异常，则不会执行\\n     * @param joinPoint 切入点\\n     * @param keys      返回结果\\n     */\\n    @Async\\n    @Transactional(rollbackFor = Exception.class)\\n    @AfterReturning(value = \\\"optLogPointCut()\\\", returning = \\\"keys\\\")\\n    public void saveOptLog(JoinPoint joinPoint, Object keys) {\\n        // 获取RequestAttributes\\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\\n        // 从获取RequestAttributes中获取HttpServletRequest的信息\\n        HttpServletRequest request = (HttpServletRequest) Objects.requireNonNull(requestAttributes).resolveReference(RequestAttributes.REFERENCE_REQUEST);\\n        OperationLog operationLog = new OperationLog();\\n        // 从切面织入点处通过反射机制获取织入点处的方法\\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\\n        // 获取切入点所在的方法\\n        Method method = signature.getMethod();\\n        // 获取操作\\n        Api api = (Api) signature.getDeclaringType().getAnnotation(Api.class);\\n        ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);\\n        OptLog optLog = method.getAnnotation(OptLog.class);\\n        // 操作模块\\n        operationLog.setOptModule(api.tags()[0]);\\n        // 操作类型\\n        operationLog.setOptType(optLog.optType());\\n        // 操作描述\\n        operationLog.setOptDesc(apiOperation.value());\\n        // 获取请求的类名\\n        String className = joinPoint.getTarget().getClass().getName();\\n        // 获取请求的方法名\\n        String methodName = method.getName();\\n        methodName = className + \\\".\\\" + methodName;\\n        // 请求方式\\n        operationLog.setRequestMethod(Objects.requireNonNull(request).getMethod());\\n        // 请求方法\\n        operationLog.setOptMethod(methodName);\\n        // 请求参数\\n        operationLog.setRequestParam(JSON.toJSONString(joinPoint.getArgs()));\\n        // 返回结果\\n        operationLog.setResponseData(JSON.toJSONString(keys));\\n        // 请求用户ID\\n        operationLog.setUserId(UserUtil.getLoginUser().getId());\\n        // 请求用户\\n        operationLog.setNickname(UserUtil.getLoginUser().getNickname());\\n        // 请求IP\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        operationLog.setIpAddr(ipAddr);\\n        operationLog.setIpSource(IpUtil.getIpSource(ipAddr));\\n        // 请求URL\\n        operationLog.setOptUrl(request.getRequestURI());\\n        // 创建时间\\n        operationLog.setCreateTime(new Date());\\n        operationLogDao.insert(operationLog);\\n    }\\n}\\n```\\n\\n对需要的进行日志记录的方法上加上 `@OptLog  ` 注解，并通过 `OptTypeConst` 常量类指明对应的操作类型，日志切面类 `OptLogAspect` 会进行日志记录，读取方法上的注解，把数据封装成 `OperationLog` 对象，插入数据库。\\n\\n#### 异常处理\\n\\n**自定义异常类 exception.ServeException **\\n\\n```java\\n/**\\n * 自定义异常类\\n */\\npublic class ServeException extends RuntimeException {\\n    public ServeException(String message) {\\n        super(message);\\n    }\\n}\\n\\n```\\n\\n**返回状态码常量 constant.StatusConst ** \\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * 返回码常量\\n */\\npublic class StatusConst {\\n\\n    /**\\n     * 成功\\n     */\\n    public static final int OK = 20000;\\n\\n    /**\\n     * 失败\\n     */\\n    public static final int ERROR = 20001;\\n\\n    /**\\n     * 系统异常\\n     */\\n    public static final int SYSTEM_ERROR = 50000;\\n\\n    /**\\n     * 未登录\\n     */\\n    public static final int NOT_LOGIN = 40001;\\n\\n    /**\\n     * 没有操作权限\\n     */\\n    public static final int AUTHORIZED = 40003;\\n}\\n```\\n\\n**全局异常处理类 controller.ControllerAdvice**\\n\\n```java\\n/**\\n * 全局异常处理\\n */\\n@RestControllerAdvice\\npublic class ControllerAdvice {\\n\\n    /**\\n     * 处理服务异常\\n     * @param e\\n     * @return\\n     */\\n    @ExceptionHandler(value = ServeException.class)\\n    public Result errorHandler(ServeException e) {\\n        return new Result(false, StatusConst.ERROR, e.getMessage());\\n    }\\n\\n    /**\\n     * 处理参数异常\\n     */\\n    @ExceptionHandler(MethodArgumentNotValidException.class)\\n    public Result errorHandler(MethodArgumentNotValidException e) {\\n        return new Result(false, StatusConst.ERROR, e.getBindingResult().getFieldError().getDefaultMessage());\\n    }\\n\\n    /**\\n     * 处理系统异常\\n     */\\n    @ExceptionHandler(value = Exception.class)\\n    public Result errorHandler(Exception e) {\\n        return new Result(false, StatusConst.SYSTEM_ERROR, \\\"系统异常\\\");\\n    }\\n}\\n```\\n\\n#### SpringScurity 权限控制\\n\\n**SpringSecurity 配置类 config.WebSecurityConfig**\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n**用户登录信息，UserDetails 的实现类 UserInfoDTO **\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**自定义登录校验 UserDetailsServiceImpl**\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n**登录成功处理器 handler.AuthenticationSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功！\\\", userLoginDTO)));\\n    }\\n\\n    /**\\n     * 更新用户信息\\n     */\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n**登录失败处理器 handler.AuthenticationFailHandlerImpl**\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n**权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl**\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n**用户未登录处理 hanlder.AuthenticationEntryPointImpl**\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n**自定义的 FilterInvocationSecurityMetadataSource**\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n**自定决策器 AccessDecisionManagerImpl**\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\\n#### Redis 使用场景\\n\\n**Redis 配置类**\\n\\n```java\\npackage top.bravecoder.blog.config;\\n\\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n/**\\n * redis配置\\n * @author zhangzhi\\n */\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\\n        redisTemplate.setConnectionFactory(factory);\\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\\n        ObjectMapper mapper = new ObjectMapper();\\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\\n        // mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL,\\n                JsonTypeInfo.As.PROPERTY);\\n        jackson2JsonRedisSerializer.setObjectMapper(mapper);\\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\\n        // key采用String的序列化方式\\n        redisTemplate.setKeySerializer(stringRedisSerializer);\\n        // hash的key也采用String的序列化方式\\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\\n        // value序列化方式采用jackson\\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\\n        // hash的value序列化方式采用jackson\\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\\n        redisTemplate.afterPropertiesSet();\\n        return redisTemplate;\\n    }\\n}\\n```\\n\\n**Redis常量**\\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * redis常量\\n */\\npublic class RedisPrefixConst {\\n\\n    /**\\n     * 验证码过期时间\\n     */\\n    public static final long CODE_EXPIRE_TIME = 15 * 60 * 1000;\\n\\n    /**\\n     * 验证码\\n     */\\n    public static final String CODE_KEY = \\\"code_\\\";\\n\\n    /**\\n     * 博客总浏览量\\n     */\\n    public static final String BLOG_VIEWS_COUNT = \\\"blog_views_count\\\";\\n\\n    /**\\n     * 文章浏览量\\n     */\\n    public static final String ARTICLE_VIEWS_COUNT = \\\"article_views_count\\\";\\n\\n    /**\\n     * 文章点赞量\\n     */\\n    public static final String ARTICLE_LIKE_COUNT = \\\"article_like_count\\\";\\n\\n    /**\\n     * 用户点赞文章\\n     */\\n    public static final String ARTICLE_USER_LIKE = \\\"article_user_like\\\";\\n\\n    /**\\n     * 评论点赞量\\n     */\\n    public static final String COMMENT_LIKE_COUNT = \\\"comment_like_count\\\";\\n\\n    /**\\n     * 用户点赞评论\\n     */\\n    public static final String COMMENT_USER_LIKE = \\\"comment_user_like\\\";\\n\\n    /**\\n     * 关于我信息\\n     */\\n    public static final String ABOUT = \\\"about\\\";\\n\\n    /**\\n     * 公告\\n     */\\n    public static final String NOTICE = \\\"notice\\\";\\n\\n    /**\\n     * ip集合\\n     */\\n    public static final String IP_SET = \\\"ip_set\\\";\\n}\\n```\\n\\n+ 用户注册时，存放验证码，**string**\\n\\n  ```java\\n  // 将验证码存入redis，设置过期时间为15分钟\\n  redisTemplate.boundValueOps(CODE_KEY + username).set(code);\\n  redisTemplate.expire(CODE_KEY + username, CODE_EXPIRE_TIME, TimeUnit.MILLISECONDS);\\n  ```\\n\\n+ 存放博客的总浏览量，**string**\\n\\n   ```java\\n   // 判断当前ip是否访问，增加访问量\\n  String ipAddr = IpUtil.getIpAddr(request);\\n  if (!ipAddr.equals(ip)) {\\n      session.setAttribute(\\\"ip\\\", ipAddr);\\n      // 博客总浏览量 +1\\n      redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n  }\\n   ```\\n\\n+ 存放文章的浏览量，**hash**\\n\\n  ```java\\n  // 判断是否第一次访问，增加浏览量\\n  Set<Integer> set = (Set<Integer>) session.getAttribute(\\\"articleSet\\\");\\n  if (Objects.isNull(set)) {\\n      set = new HashSet<>();\\n  }\\n  if (!set.contains(articleId)) {\\n      set.add(articleId);\\n      session.setAttribute(\\\"articleSet\\\", set);\\n      // 浏览量+1\\n      redisTemplate.boundHashOps(ARTICLE_VIEWS_COUNT).increment(articleId.toString(), 1);\\n  }\\n  ```\\n\\n+ 存放所有文章各自的点赞量和用户点赞的文章集合，**hash**\\n\\n```java\\n public void saveArticleLike(Integer articleId) {\\n        // 查询当前用户点赞过的文章id集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(articleLikeSet)) {\\n            articleLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (articleLikeSet.contains(articleId)) {\\n            // 点过赞则删除文章id\\n            articleLikeSet.remove(articleId);\\n            // 文章点赞量-1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), -1);\\n        } else {\\n            // 未点赞则增加文章id\\n            articleLikeSet.add(articleId);\\n            // 文章点赞量+1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), 1);\\n        }\\n        // 保存用户的点赞记录\\n  redisTemplate.boundHashOps(ARTICLE_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), articleLikeSet);\\n    }\\n```\\n\\n+ 存放所有评论各自的点赞量和用户点赞的评论集合，与上面类似，**hash**\\n\\n```java\\n public void saveCommentLike(Integer commentId) {\\n        // 查询当前用户点赞过的评论id集合\\n        HashSet<Integer> commentLikeSet = (HashSet<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(commentLikeSet)) {\\n            commentLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (commentLikeSet.contains(commentId)) {\\n            // 点过赞则删除评论id\\n            commentLikeSet.remove(commentId);\\n            // 评论点赞量-1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), -1);\\n        } else {\\n            // 未点赞则增加评论id\\n            commentLikeSet.add(commentId);\\n            // 评论点赞量+1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), 1);\\n        }\\n        // 保存点赞记录\\n  redisTemplate.boundHashOps(COMMENT_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), commentLikeSet);\\n    }\\n```\\n\\n+ 存放关于我、公告信息，**string**\\n\\n  ```java\\n  public void updateAbout(String aboutContent) {\\n      redisTemplate.boundValueOps(ABOUT).set(aboutContent);\\n  }\\n\\n  public void updateNotice(String notice) {\\n      redisTemplate.boundValueOps(NOTICE).set(notice);\\n  }\\n\\n  ```\\n\\n+ 存放ip，统计每日用户量，**set**\\n\\n  暂时存储每天的ip集合，定时把当天的访问量存储到数据库，定时删除\\n\\n  ```java\\n\\n  /**\\n   * request监听\\n   */\\n  @Component\\n  public class ServletRequestListenerImpl implements ServletRequestListener {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n\\n      @Override\\n      public void requestInitialized(ServletRequestEvent sre) {\\n          HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\\n          HttpSession session = request.getSession();\\n          String ip = (String) session.getAttribute(\\\"ip\\\");\\n          // 判断当前ip是否访问，增加访问量\\n          String ipAddr = IpUtil.getIpAddr(request);\\n          if (!ipAddr.equals(ip)) {\\n              session.setAttribute(\\\"ip\\\", ipAddr);\\n              redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n          }\\n          // 将ip存入redis，统计每日用户量\\n          redisTemplate.boundSetOps(IP_SET).add(ipAddr);\\n      }\\n\\n      // 每天凌晨0点1分执行一次\\n      @Scheduled(cron = \\\" 0 1 0 * * ?\\\")\\n      private void clear() {\\n          // 清空redis中的ip\\n          redisTemplate.delete(IP_SET);\\n      }\\n  }\\n\\n  -----------------------------------------------------------\\n  @Service\\n  public class UniqueViewServiceImpl extends ServiceImpl<UniqueViewDao, UniqueView> implements UniqueViewService {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n      @Autowired\\n      private UniqueViewDao uniqueViewDao;\\n\\n      // 每天 0 点执行一次\\n      @Scheduled(cron = \\\" 0 0 0 * * ?\\\")\\n      @Override\\n      public void saveUniqueView() {\\n          // 获取每天用户量\\n          Long count = redisTemplate.boundSetOps(\\\"ip_set\\\").size();\\n          // 获取昨天日期插入数据\\n          UniqueView uniqueView = UniqueView.builder()\\n                  .createTime(DateUtil.getSomeDay(new Date(), -1))\\n                  .viewsCount(Objects.nonNull(count) ? count.intValue() : 0).build();\\n          uniqueViewDao.insert(uniqueView);\\n      }\\n  }\\n  ```\\n\\n#### RabbitMQ使用场景\\n\\n**常量类**\\n\\n```java\\n/**\\n * MQ常量\\n */\\npublic class MQPrefixConst {\\n\\n    /**\\n     * email交换机\\n     */\\n    public static final String EMAIL_EXCHANGE = \\\"send\\\";\\n\\n    /**\\n     * 邮件队列\\n     */\\n    public static final String EMAIL_QUEUE = \\\"email\\\";\\n}\\n```\\n\\n**RabbitMQ配置类**\\n\\n```java\\n/**\\n * Rabbitmq配置类\\n */\\n@Configuration\\npublic class RabbitConfig {\\n\\n    // 创建队列\\n    @Bean\\n    public Queue emailQueue() {\\n        return new Queue(MQPrefixConst.EMAIL_QUEUE, true);\\n    }\\n\\n    // 创建交换机\\n    @Bean\\n    public FanoutExchange emailExchange() {\\n        return new FanoutExchange(MQPrefixConst.EMAIL_EXCHANGE, true, false);\\n    }\\n\\n    // 把队列和交换机绑定在一起\\n    @Bean\\n    public Binding bindingEmailDirect() {\\n        return BindingBuilder.bind(emailQueue()).to(emailExchange());\\n    }\\n}\\n```\\n\\n**消费者 EmailReceiver**\\n\\n```java\\n/**\\n * 监听EMAIL_QUEUE，发送邮件\\n */\\n@Component\\n@RabbitListener(queues = MQPrefixConst.EMAIL_QUEUE)\\npublic class EmailReceiver {\\n    /**\\n     * 邮箱号\\n     */\\n    @Value(\\\"${spring.mail.username}\\\")\\n    private String email;\\n\\n    @Autowired\\n    private JavaMailSender javaMailSender;\\n\\n    @RabbitHandler\\n    public void process(byte[] data) {\\n        EmailDTO emailDTO = JSON.parseObject(new String(data), EmailDTO.class);\\n        SimpleMailMessage message = new SimpleMailMessage();\\n        message.setFrom(email);\\n        message.setTo(emailDTO.getEmail());\\n        message.setSubject(emailDTO.getSubject());\\n        message.setText(emailDTO.getContent());\\n        javaMailSender.send(message);\\n    }\\n}\\n```\\n\\n**场景一**\\n\\n用户注册时，对邮箱发送验证码\\n\\n```java\\nrabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", new Message(JSON.toJSONBytes(emailDTO), \\n                new MessageProperties()));\\n```\\n\\n**场景二**\\n\\n用户的评论收到回复时，发邮件进行通知\\n\\n```java\\n/**\\n * 通知评论用户\\n */\\n@Async\\npublic void notice(CommentVO commentVO) {\\n    // 判断是回复用户还是评论作者\\n    Integer userId = Objects.nonNull(commentVO.getReplyId()) ? commentVO.getReplyId() : BLOGGER_ID;\\n    // 查询邮箱号\\n    String email = userInfoDao.selectById(userId).getEmail();\\n    if (StringUtils.isNotBlank(email)) {\\n        // 判断页面路径\\n        String url = Objects.nonNull(commentVO.getArticleId()) ? URL + ARTICLE_PATH + commentVO.getArticleId() : URL + LINK_PATH;\\n        // 发送消息\\n        EmailDTO emailDTO = EmailDTO.builder()\\n            .email(email)\\n            .subject(\\\"评论提醒\\\")\\n            .content(\\\"您收到了一条新的回复，请前往\\\" + url + \\\"\\\\n页面查看\\\")\\n            .build();\\n        rabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", \\n                       new Message(JSON.toJSONBytes(emailDTO), new MessageProperties()));\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620031190128.jpeg\",\"articleTitle\":\"博客内容梳理\",\"categoryId\":13,\"id\":39,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:39:56');
INSERT INTO `tb_operation_log` VALUES (21, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 数据库\\n\\n### 数据表\\n\\n| 表名             | 中文含义         | 说明                                                         |\\n| ---------------- | ---------------- | ------------------------------------------------------------ |\\n| tb_article       | 文章表           | 存放文章标题、内容、分类id、发布时间、置顶状态等             |\\n| tb_category      | 分类表           | 存放分类名称、创建时间                                       |\\n| tb_tag           | 标签表           | 存放标签名称、创建时间                                       |\\n| tb_article_tag   | 文章标签关系表   | 文章与标签之类是多对多的关系，存放article_id、tag_id         |\\n| tb_friend_link   | 友链表           | 存放友链信息，名称、地址、介绍、头像、创建时间等             |\\n| tb_message       | 留言表           | 存放留言用户ip、地址、昵称、头像url、内容、时间等            |\\n| tb_comment       | 评论表           | 存放评论用户id、评论文章id、内容、回复用户id、父评论id等     |\\n| tb_operation_log | 操作日志表       | 记录管理也操作的日志，操作模块、类型、url、方法、描述、参数、请求方式、返回数据、用户id、昵称、操作ip、地址等 |\\n| tb_menu          | 菜单表           | 存放菜单名、菜单路径、组件、菜单icon、父菜单id、时间、状态信息等 |\\n| tb_resource      | 权限表           | 存放权限名、权限路径、请求方式、父权限id、时间、状态信息等   |\\n| tb_role          | 角色表           | 存放角色名、角色描述、时间、状态信息等                       |\\n| tb_role_menu     | 角色菜单关系表   | 菜单和角色是多对多的关系，存放role_id、menu_id               |\\n| tb_role_resource | 角色权限关系表   | 角色和权限是多对多的关系，存放role_id、resource_id           |\\n| tb_user_auth     | 用户登录信息表   | 存放用户个人信息id、用户名、密码、登录类型、ip、ip来源、时间等 |\\n| tb_user_info     | 用户个人信息表   | 存放邮箱、昵称、头像url、用户简介、个人网站、时间、是否禁用等 |\\n| tb_user_role     | 用户角色关系表   | 用户和角色是多对多的关系，存放user_id、role_id               |\\n| tb_unique_view   | 网站单日访问量表 | 存放网站每天的访问量信息，如时间、访问量                     |\\n\\n### 表关系\\n\\n+ 文章和标签是多对多的关系，即一个文章可以含有多个标签，一个标签也可以对应多个文章。所以使用tb_article_tag 来维护这个关系。\\n+ 菜单和角色是多对多的关系，一个菜单可以被多个角色访问，一个角色也可以访问多个菜单。\\n+ 角色和权限是多对多的关系，一个角色可以有多个访问权限，一个权限也可以被多个角色访问。\\n+ 用户和角色是多对多的关系，一个用户可以有多个角色，一个角色可以被多个用户拥有。\\n\\n> 注意\\n>\\n> + 用户的访问权限该博客是使用 SpringSecurity 来控制的，具体的见后序分析。\\n> + 用户对菜单的访问是在查询是用代码控制的。\\n>   + 用户id可以确定角色集合\\n>   + 角色可以确定访问的菜单集合\\n\\n### 建表语句\\n\\n```sql\\n-- ----------------------------\\n-- Table structure for tb_article 文章表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article`;\\nCREATE TABLE `tb_article`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'作者\',\\n  `category_id` int(11) DEFAULT NULL COMMENT \'文章分类\',\\n  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'文章缩略图\',\\n  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标题\',\\n  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'内容\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'发表时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_top` tinyint(1) DEFAULT NULL COMMENT \'是否置顶 0否 1是\',\\n  `is_draft` tinyint(1) DEFAULT 0 COMMENT \'是否为草稿 0否 1是\',\\n  `is_delete` tinyint(1) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `category_id`(`category_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_category 分类表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_category`;\\nCREATE TABLE `tb_category`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'分类名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_tag 标签表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_tag`;\\nCREATE TABLE `tb_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标签名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_article_tag 文章标签关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article_tag`;\\nCREATE TABLE `tb_article_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `article_id` int(11) NOT NULL COMMENT \'文章id\',\\n  `tag_id` int(11) NOT NULL COMMENT \'标签id\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,\\n  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_friend_link 友链表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_friend_link`;\\nCREATE TABLE `tb_friend_link`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接名\',\\n  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接头像\',\\n  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接地址\',\\n  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接介绍\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_friend_link_user`(`link_name`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_message 留言表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_message`;\\nCREATE TABLE `tb_message`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户地址\',\\n  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'昵称\',\\n  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'头像\',\\n  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'留言内容\',\\n  `time` tinyint(1) DEFAULT NULL COMMENT \'弹幕速度\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'发布时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 3435 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_comment 评论表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_comment`;\\nCREATE TABLE `tb_comment`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'评论用户Id\',\\n  `article_id` int(11) DEFAULT NULL COMMENT \'评论文章id\',\\n  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'评论内容\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'评论时间\',\\n  `reply_id` int(11) DEFAULT NULL COMMENT \'回复用户id\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父评论id\',\\n  `is_delete` tinyint(4) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_comment_user`(`user_id`) USING BTREE,\\n  INDEX `fk_comment_article`(`article_id`) USING BTREE,\\n  INDEX `fk_comment_parent`(`parent_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 268 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_operation_log 操作日志表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_operation_log`;\\nCREATE TABLE `tb_operation_log`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作模块\',\\n  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作类型\',\\n  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作url\',\\n  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作方法\',\\n  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作描述\',\\n  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'请求参数\',\\n  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'返回数据\',\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户昵称\',\\n  `ip_addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作地址\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_menu 菜单表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_menu`;\\nCREATE TABLE `tb_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单名\',\\n  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单路径\',\\n  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'组件\',\\n  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单icon\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `order_num` tinyint(4) DEFAULT NULL COMMENT \'排序\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父id\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否1是\',\\n  `is_hidden` tinyint(1) DEFAULT NULL COMMENT \'是否隐藏  0否1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 203 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_resource 权限表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_resource`;\\nCREATE TABLE `tb_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'资源名\',\\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'权限路径\',\\n  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父权限id\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'修改时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否 1是\',\\n  `is_anonymous` tinyint(4) DEFAULT NULL COMMENT \'是否匿名访问 0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 250 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role 角色表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role`;\\nCREATE TABLE `tb_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色名\',\\n  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色描述\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_menu 角色菜单关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_menu`;\\nCREATE TABLE `tb_role_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `menu_id` int(11) DEFAULT NULL COMMENT \'菜单id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 1265 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_resource 角色权限关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_resource`;\\nCREATE TABLE `tb_role_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `resource_id` int(11) DEFAULT NULL COMMENT \'权限id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4181 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_auth 用户登录信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_auth`;\\nCREATE TABLE `tb_user_auth`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_info_id` int(11) NOT NULL COMMENT \'用户信息id\',\\n  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户名\',\\n  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'密码\',\\n  `login_type` tinyint(1) NOT NULL COMMENT \'登录类型\',\\n  `ip_addr` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户登录ip\',\\n  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'ip来源\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `last_login_time` datetime(0) DEFAULT NULL COMMENT \'上次登录时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  UNIQUE INDEX `username`(`username`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 201 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_info 用户个人信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_info`;\\nCREATE TABLE `tb_user_info`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'邮箱号\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户昵称\',\\n  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT \'\' COMMENT \'用户头像\',\\n  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户简介\',\\n  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'个人网站\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT 0 COMMENT \'是否禁用\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 212 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_role 用户角色关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_role`;\\nCREATE TABLE `tb_user_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 221 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_unique_view 网站单日访问量表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_unique_view`;\\nCREATE TABLE `tb_unique_view`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `create_time` datetime(0) NOT NULL COMMENT \'时间\',\\n  `views_count` int(11) NOT NULL COMMENT \'访问量\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 225 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n```\\n\\n## 博客整体概览\\n\\n### 包结构\\n\\n| 包名       | 说明                                                         |\\n| ---------- | ------------------------------------------------------------ |\\n| annotation | 自定义注解                                                   |\\n| config     | 自定义配置类，MybatisPlus、Redis、Swagger的配置类等          |\\n| constant   | 自定义的常量类，Redis的key常量、操作类型、状态码等           |\\n| controller | 控制层代码                                                   |\\n| dao        | 持久层接口                                                   |\\n| dto        | 把后端返回前端的数据封装成DTO                                |\\n| entity     | 实体类                                                       |\\n| enums      | 自定义枚举类，登录类型、角色枚举、操作类型等                 |\\n| exception  | 自定义异常类                                                 |\\n| handler    | 自定义处理器，SpringSecurity的自定义handler、日志切面类、监听器等 |\\n| service    | 业务层代码                                                   |\\n| util       | 工具类，日期、OSS、ip等工具类                                |\\n| vo         | 用于接收前端传来的数据，把这些数据封装成VO便于接收参数       |\\n\\n### 核心功能\\n\\n#### 操作日志记录\\n\\n对所有加了 **@OptLog** 注解（通过 **optType** 指明操作类型）的方法进行日志记录。\\n\\n**操作日志注解 annotation.OptLog**\\n\\n```java\\n/**\\n * 操作日志注解\\n */\\n@Target(ElementType.METHOD)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Documented\\npublic @interface OptLog {\\n    /**\\n     * @return 操作类型\\n     */\\n    String optType() default \\\"\\\";\\n}\\n```\\n\\n**操作类型常量类 constant.OptTypeConst**\\n\\n```java\\n/**\\n * 操作日志类型常量\\n */\\npublic class OptTypeConst {\\n\\n    /**\\n     * 新增操作\\n     */\\n    public static final String SAVE_OR_UPDATE = \\\"新增或修改\\\";\\n\\n    /**\\n     * 新增\\n     */\\n    public static final String SAVE = \\\"新增\\\";\\n\\n    /**\\n     * 修改操作\\n     */\\n    public static final String UPDATE = \\\"修改\\\";\\n\\n    /**\\n     * 删除操作\\n     */\\n    public static final String REMOVE = \\\"删除\\\";\\n\\n    /**\\n     * 上传操作\\n     */\\n    public static final String UPLOAD = \\\"上传\\\";\\n}\\n```\\n\\n**日志切面类 handler.OptLogAspect**\\n\\n```java\\n/**\\n * 操作日志切面处理\\n */\\n@Component\\npublic class OptLogAspect {\\n\\n    @Autowired\\n    private OperationLogDao operationLogDao;\\n\\n    /**\\n     * 设置操作日志切入点 记录操作日志 在注解的位置切入代码\\n     */\\n    @Pointcut(\\\"@annotation(top.bravecoder.blog.annotation.OptLog)\\\")\\n    public void optLogPointCut() {\\n    }\\n\\n    /**\\n     * 正常返回通知，拦截用户操作日志，连接点正常执行完成后执行， 如果连接点抛出异常，则不会执行\\n     * @param joinPoint 切入点\\n     * @param keys      返回结果\\n     */\\n    @Async\\n    @Transactional(rollbackFor = Exception.class)\\n    @AfterReturning(value = \\\"optLogPointCut()\\\", returning = \\\"keys\\\")\\n    public void saveOptLog(JoinPoint joinPoint, Object keys) {\\n        // 获取RequestAttributes\\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\\n        // 从获取RequestAttributes中获取HttpServletRequest的信息\\n        HttpServletRequest request = (HttpServletRequest) Objects.requireNonNull(requestAttributes).resolveReference(RequestAttributes.REFERENCE_REQUEST);\\n        OperationLog operationLog = new OperationLog();\\n        // 从切面织入点处通过反射机制获取织入点处的方法\\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\\n        // 获取切入点所在的方法\\n        Method method = signature.getMethod();\\n        // 获取操作\\n        Api api = (Api) signature.getDeclaringType().getAnnotation(Api.class);\\n        ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);\\n        OptLog optLog = method.getAnnotation(OptLog.class);\\n        // 操作模块\\n        operationLog.setOptModule(api.tags()[0]);\\n        // 操作类型\\n        operationLog.setOptType(optLog.optType());\\n        // 操作描述\\n        operationLog.setOptDesc(apiOperation.value());\\n        // 获取请求的类名\\n        String className = joinPoint.getTarget().getClass().getName();\\n        // 获取请求的方法名\\n        String methodName = method.getName();\\n        methodName = className + \\\".\\\" + methodName;\\n        // 请求方式\\n        operationLog.setRequestMethod(Objects.requireNonNull(request).getMethod());\\n        // 请求方法\\n        operationLog.setOptMethod(methodName);\\n        // 请求参数\\n        operationLog.setRequestParam(JSON.toJSONString(joinPoint.getArgs()));\\n        // 返回结果\\n        operationLog.setResponseData(JSON.toJSONString(keys));\\n        // 请求用户ID\\n        operationLog.setUserId(UserUtil.getLoginUser().getId());\\n        // 请求用户\\n        operationLog.setNickname(UserUtil.getLoginUser().getNickname());\\n        // 请求IP\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        operationLog.setIpAddr(ipAddr);\\n        operationLog.setIpSource(IpUtil.getIpSource(ipAddr));\\n        // 请求URL\\n        operationLog.setOptUrl(request.getRequestURI());\\n        // 创建时间\\n        operationLog.setCreateTime(new Date());\\n        operationLogDao.insert(operationLog);\\n    }\\n}\\n```\\n\\n对需要的进行日志记录的方法上加上 @OptLog 注解，并通过 OptTypeConst 常量类指明对应的操作类型，日志切面类 OptLogAspect 会进行日志记录，读取方法上的注解，把数据封装成 OperationLog 对象，插入数据库。\\n\\n#### 异常处理\\n\\n**自定义异常类 exception.ServeException**\\n\\n```java\\n/**\\n * 自定义异常类\\n */\\npublic class ServeException extends RuntimeException {\\n    public ServeException(String message) {\\n        super(message);\\n    }\\n}\\n\\n```\\n\\n**返回状态码常量 constant.StatusConst** \\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * 返回码常量\\n */\\npublic class StatusConst {\\n\\n    /**\\n     * 成功\\n     */\\n    public static final int OK = 20000;\\n\\n    /**\\n     * 失败\\n     */\\n    public static final int ERROR = 20001;\\n\\n    /**\\n     * 系统异常\\n     */\\n    public static final int SYSTEM_ERROR = 50000;\\n\\n    /**\\n     * 未登录\\n     */\\n    public static final int NOT_LOGIN = 40001;\\n\\n    /**\\n     * 没有操作权限\\n     */\\n    public static final int AUTHORIZED = 40003;\\n}\\n```\\n\\n**全局异常处理类 controller.ControllerAdvice**\\n\\n```java\\n/**\\n * 全局异常处理\\n */\\n@RestControllerAdvice\\npublic class ControllerAdvice {\\n\\n    /**\\n     * 处理服务异常\\n     * @param e\\n     * @return\\n     */\\n    @ExceptionHandler(value = ServeException.class)\\n    public Result errorHandler(ServeException e) {\\n        return new Result(false, StatusConst.ERROR, e.getMessage());\\n    }\\n\\n    /**\\n     * 处理参数异常\\n     */\\n    @ExceptionHandler(MethodArgumentNotValidException.class)\\n    public Result errorHandler(MethodArgumentNotValidException e) {\\n        return new Result(false, StatusConst.ERROR, e.getBindingResult().getFieldError().getDefaultMessage());\\n    }\\n\\n    /**\\n     * 处理系统异常\\n     */\\n    @ExceptionHandler(value = Exception.class)\\n    public Result errorHandler(Exception e) {\\n        return new Result(false, StatusConst.SYSTEM_ERROR, \\\"系统异常\\\");\\n    }\\n}\\n```\\n\\n#### SpringScurity 权限控制\\n\\n**SpringSecurity 配置类 config.WebSecurityConfig**\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n**用户登录信息，UserDetails 的实现类 UserInfoDTO**\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**自定义登录校验 UserDetailsServiceImpl**\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n**登录成功处理器 handler.AuthenticationSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功！\\\", userLoginDTO)));\\n    }\\n\\n    /**\\n     * 更新用户信息\\n     */\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n**登录失败处理器 handler.AuthenticationFailHandlerImpl**\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n**权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl**\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n**用户未登录处理 hanlder.AuthenticationEntryPointImpl**\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n**自定义的 FilterInvocationSecurityMetadataSource**\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n**自定决策器 AccessDecisionManagerImpl**\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\\n#### Redis 使用场景\\n\\n**Redis 配置类**\\n\\n```java\\npackage top.bravecoder.blog.config;\\n\\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n/**\\n * redis配置\\n * @author zhangzhi\\n */\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\\n        redisTemplate.setConnectionFactory(factory);\\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\\n        ObjectMapper mapper = new ObjectMapper();\\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\\n        // mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL,\\n                JsonTypeInfo.As.PROPERTY);\\n        jackson2JsonRedisSerializer.setObjectMapper(mapper);\\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\\n        // key采用String的序列化方式\\n        redisTemplate.setKeySerializer(stringRedisSerializer);\\n        // hash的key也采用String的序列化方式\\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\\n        // value序列化方式采用jackson\\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\\n        // hash的value序列化方式采用jackson\\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\\n        redisTemplate.afterPropertiesSet();\\n        return redisTemplate;\\n    }\\n}\\n```\\n\\n**Redis常量**\\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * redis常量\\n */\\npublic class RedisPrefixConst {\\n\\n    /**\\n     * 验证码过期时间\\n     */\\n    public static final long CODE_EXPIRE_TIME = 15 * 60 * 1000;\\n\\n    /**\\n     * 验证码\\n     */\\n    public static final String CODE_KEY = \\\"code_\\\";\\n\\n    /**\\n     * 博客总浏览量\\n     */\\n    public static final String BLOG_VIEWS_COUNT = \\\"blog_views_count\\\";\\n\\n    /**\\n     * 文章浏览量\\n     */\\n    public static final String ARTICLE_VIEWS_COUNT = \\\"article_views_count\\\";\\n\\n    /**\\n     * 文章点赞量\\n     */\\n    public static final String ARTICLE_LIKE_COUNT = \\\"article_like_count\\\";\\n\\n    /**\\n     * 用户点赞文章\\n     */\\n    public static final String ARTICLE_USER_LIKE = \\\"article_user_like\\\";\\n\\n    /**\\n     * 评论点赞量\\n     */\\n    public static final String COMMENT_LIKE_COUNT = \\\"comment_like_count\\\";\\n\\n    /**\\n     * 用户点赞评论\\n     */\\n    public static final String COMMENT_USER_LIKE = \\\"comment_user_like\\\";\\n\\n    /**\\n     * 关于我信息\\n     */\\n    public static final String ABOUT = \\\"about\\\";\\n\\n    /**\\n     * 公告\\n     */\\n    public static final String NOTICE = \\\"notice\\\";\\n\\n    /**\\n     * ip集合\\n     */\\n    public static final String IP_SET = \\\"ip_set\\\";\\n}\\n```\\n\\n+ 用户注册时，存放验证码，**string**\\n\\n  ```java\\n  // 将验证码存入redis，设置过期时间为15分钟\\n  redisTemplate.boundValueOps(CODE_KEY + username).set(code);\\n  redisTemplate.expire(CODE_KEY + username, CODE_EXPIRE_TIME, TimeUnit.MILLISECONDS);\\n  ```\\n\\n+ 存放博客的总浏览量，**string**\\n\\n   ```java\\n   // 判断当前ip是否访问，增加访问量\\n  String ipAddr = IpUtil.getIpAddr(request);\\n  if (!ipAddr.equals(ip)) {\\n      session.setAttribute(\\\"ip\\\", ipAddr);\\n      // 博客总浏览量 +1\\n      redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n  }\\n   ```\\n\\n+ 存放文章的浏览量，**hash**\\n\\n  ```java\\n  // 判断是否第一次访问，增加浏览量\\n  Set<Integer> set = (Set<Integer>) session.getAttribute(\\\"articleSet\\\");\\n  if (Objects.isNull(set)) {\\n      set = new HashSet<>();\\n  }\\n  if (!set.contains(articleId)) {\\n      set.add(articleId);\\n      session.setAttribute(\\\"articleSet\\\", set);\\n      // 浏览量+1\\n      redisTemplate.boundHashOps(ARTICLE_VIEWS_COUNT).increment(articleId.toString(), 1);\\n  }\\n  ```\\n\\n+ 存放所有文章各自的点赞量和用户点赞的文章集合，**hash**\\n\\n```java\\n public void saveArticleLike(Integer articleId) {\\n        // 查询当前用户点赞过的文章id集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(articleLikeSet)) {\\n            articleLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (articleLikeSet.contains(articleId)) {\\n            // 点过赞则删除文章id\\n            articleLikeSet.remove(articleId);\\n            // 文章点赞量-1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), -1);\\n        } else {\\n            // 未点赞则增加文章id\\n            articleLikeSet.add(articleId);\\n            // 文章点赞量+1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), 1);\\n        }\\n        // 保存用户的点赞记录\\n  redisTemplate.boundHashOps(ARTICLE_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), articleLikeSet);\\n    }\\n```\\n\\n+ 存放所有评论各自的点赞量和用户点赞的评论集合，与上面类似，**hash**\\n\\n```java\\n public void saveCommentLike(Integer commentId) {\\n        // 查询当前用户点赞过的评论id集合\\n        HashSet<Integer> commentLikeSet = (HashSet<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(commentLikeSet)) {\\n            commentLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (commentLikeSet.contains(commentId)) {\\n            // 点过赞则删除评论id\\n            commentLikeSet.remove(commentId);\\n            // 评论点赞量-1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), -1);\\n        } else {\\n            // 未点赞则增加评论id\\n            commentLikeSet.add(commentId);\\n            // 评论点赞量+1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), 1);\\n        }\\n        // 保存点赞记录\\n  redisTemplate.boundHashOps(COMMENT_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), commentLikeSet);\\n    }\\n```\\n\\n+ 存放关于我、公告信息，**string**\\n\\n  ```java\\n  public void updateAbout(String aboutContent) {\\n      redisTemplate.boundValueOps(ABOUT).set(aboutContent);\\n  }\\n\\n  public void updateNotice(String notice) {\\n      redisTemplate.boundValueOps(NOTICE).set(notice);\\n  }\\n\\n  ```\\n\\n+ 存放ip，统计每日用户量，**set**\\n\\n  暂时存储每天的ip集合，定时把当天的访问量存储到数据库，定时删除\\n\\n  ```java\\n\\n  /**\\n   * request监听\\n   */\\n  @Component\\n  public class ServletRequestListenerImpl implements ServletRequestListener {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n\\n      @Override\\n      public void requestInitialized(ServletRequestEvent sre) {\\n          HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\\n          HttpSession session = request.getSession();\\n          String ip = (String) session.getAttribute(\\\"ip\\\");\\n          // 判断当前ip是否访问，增加访问量\\n          String ipAddr = IpUtil.getIpAddr(request);\\n          if (!ipAddr.equals(ip)) {\\n              session.setAttribute(\\\"ip\\\", ipAddr);\\n              redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n          }\\n          // 将ip存入redis，统计每日用户量\\n          redisTemplate.boundSetOps(IP_SET).add(ipAddr);\\n      }\\n\\n      // 每天凌晨0点1分执行一次\\n      @Scheduled(cron = \\\" 0 1 0 * * ?\\\")\\n      private void clear() {\\n          // 清空redis中的ip\\n          redisTemplate.delete(IP_SET);\\n      }\\n  }\\n\\n  -----------------------------------------------------------\\n  @Service\\n  public class UniqueViewServiceImpl extends ServiceImpl<UniqueViewDao, UniqueView> implements UniqueViewService {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n      @Autowired\\n      private UniqueViewDao uniqueViewDao;\\n\\n      // 每天 0 点执行一次\\n      @Scheduled(cron = \\\" 0 0 0 * * ?\\\")\\n      @Override\\n      public void saveUniqueView() {\\n          // 获取每天用户量\\n          Long count = redisTemplate.boundSetOps(\\\"ip_set\\\").size();\\n          // 获取昨天日期插入数据\\n          UniqueView uniqueView = UniqueView.builder()\\n                  .createTime(DateUtil.getSomeDay(new Date(), -1))\\n                  .viewsCount(Objects.nonNull(count) ? count.intValue() : 0).build();\\n          uniqueViewDao.insert(uniqueView);\\n      }\\n  }\\n  ```\\n\\n#### RabbitMQ使用场景\\n\\n**常量类**\\n\\n```java\\n/**\\n * MQ常量\\n */\\npublic class MQPrefixConst {\\n\\n    /**\\n     * email交换机\\n     */\\n    public static final String EMAIL_EXCHANGE = \\\"send\\\";\\n\\n    /**\\n     * 邮件队列\\n     */\\n    public static final String EMAIL_QUEUE = \\\"email\\\";\\n}\\n```\\n\\n**RabbitMQ配置类**\\n\\n```java\\n/**\\n * Rabbitmq配置类\\n */\\n@Configuration\\npublic class RabbitConfig {\\n\\n    // 创建队列\\n    @Bean\\n    public Queue emailQueue() {\\n        return new Queue(MQPrefixConst.EMAIL_QUEUE, true);\\n    }\\n\\n    // 创建交换机\\n    @Bean\\n    public FanoutExchange emailExchange() {\\n        return new FanoutExchange(MQPrefixConst.EMAIL_EXCHANGE, true, false);\\n    }\\n\\n    // 把队列和交换机绑定在一起\\n    @Bean\\n    public Binding bindingEmailDirect() {\\n        return BindingBuilder.bind(emailQueue()).to(emailExchange());\\n    }\\n}\\n```\\n\\n**消费者 EmailReceiver**\\n\\n```java\\n/**\\n * 监听EMAIL_QUEUE，发送邮件\\n */\\n@Component\\n@RabbitListener(queues = MQPrefixConst.EMAIL_QUEUE)\\npublic class EmailReceiver {\\n    /**\\n     * 邮箱号\\n     */\\n    @Value(\\\"${spring.mail.username}\\\")\\n    private String email;\\n\\n    @Autowired\\n    private JavaMailSender javaMailSender;\\n\\n    @RabbitHandler\\n    public void process(byte[] data) {\\n        EmailDTO emailDTO = JSON.parseObject(new String(data), EmailDTO.class);\\n        SimpleMailMessage message = new SimpleMailMessage();\\n        message.setFrom(email);\\n        message.setTo(emailDTO.getEmail());\\n        message.setSubject(emailDTO.getSubject());\\n        message.setText(emailDTO.getContent());\\n        javaMailSender.send(message);\\n    }\\n}\\n```\\n\\n**场景一**\\n\\n用户注册时，对邮箱发送验证码\\n\\n```java\\nrabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", new Message(JSON.toJSONBytes(emailDTO), \\n                new MessageProperties()));\\n```\\n\\n**场景二**\\n\\n用户的评论收到回复时，发邮件进行通知\\n\\n```java\\n/**\\n * 通知评论用户\\n */\\n@Async\\npublic void notice(CommentVO commentVO) {\\n    // 判断是回复用户还是评论作者\\n    Integer userId = Objects.nonNull(commentVO.getReplyId()) ? commentVO.getReplyId() : BLOGGER_ID;\\n    // 查询邮箱号\\n    String email = userInfoDao.selectById(userId).getEmail();\\n    if (StringUtils.isNotBlank(email)) {\\n        // 判断页面路径\\n        String url = Objects.nonNull(commentVO.getArticleId()) ? URL + ARTICLE_PATH + commentVO.getArticleId() : URL + LINK_PATH;\\n        // 发送消息\\n        EmailDTO emailDTO = EmailDTO.builder()\\n            .email(email)\\n            .subject(\\\"评论提醒\\\")\\n            .content(\\\"您收到了一条新的回复，请前往\\\" + url + \\\"\\\\n页面查看\\\")\\n            .build();\\n        rabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", \\n                       new Message(JSON.toJSONBytes(emailDTO), new MessageProperties()));\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620031190128.jpeg\",\"articleTitle\":\"博客内容梳理\",\"categoryId\":13,\"id\":39,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-03 16:44:46');
INSERT INTO `tb_operation_log` VALUES (22, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 数据库\\n\\n### 数据表\\n\\n| 表名             | 中文含义         | 说明                                                         |\\n| ---------------- | ---------------- | ------------------------------------------------------------ |\\n| tb_article       | 文章表           | 存放文章标题、内容、分类id、发布时间、置顶状态等             |\\n| tb_category      | 分类表           | 存放分类名称、创建时间                                       |\\n| tb_tag           | 标签表           | 存放标签名称、创建时间                                       |\\n| tb_article_tag   | 文章标签关系表   | 文章与标签之类是多对多的关系，存放article_id、tag_id         |\\n| tb_friend_link   | 友链表           | 存放友链信息，名称、地址、介绍、头像、创建时间等             |\\n| tb_message       | 留言表           | 存放留言用户ip、地址、昵称、头像url、内容、时间等            |\\n| tb_comment       | 评论表           | 存放评论用户id、评论文章id、内容、回复用户id、父评论id等     |\\n| tb_operation_log | 操作日志表       | 记录管理也操作的日志，操作模块、类型、url、方法、描述、参数、请求方式、返回数据、用户id、昵称、操作ip、地址等 |\\n| tb_menu          | 菜单表           | 存放菜单名、菜单路径、组件、菜单icon、父菜单id、时间、状态信息等 |\\n| tb_resource      | 权限表           | 存放权限名、权限路径、请求方式、父权限id、时间、状态信息等   |\\n| tb_role          | 角色表           | 存放角色名、角色描述、时间、状态信息等                       |\\n| tb_role_menu     | 角色菜单关系表   | 菜单和角色是多对多的关系，存放role_id、menu_id               |\\n| tb_role_resource | 角色权限关系表   | 角色和权限是多对多的关系，存放role_id、resource_id           |\\n| tb_user_auth     | 用户登录信息表   | 存放用户个人信息id、用户名、密码、登录类型、ip、ip来源、时间等 |\\n| tb_user_info     | 用户个人信息表   | 存放邮箱、昵称、头像url、用户简介、个人网站、时间、是否禁用等 |\\n| tb_user_role     | 用户角色关系表   | 用户和角色是多对多的关系，存放user_id、role_id               |\\n| tb_unique_view   | 网站单日访问量表 | 存放网站每天的访问量信息，如时间、访问量                     |\\n\\n### 表关系\\n\\n+ 文章和标签是多对多的关系，即一个文章可以含有多个标签，一个标签也可以对应多个文章。所以使用tb_article_tag 来维护这个关系。\\n+ 菜单和角色是多对多的关系，一个菜单可以被多个角色访问，一个角色也可以访问多个菜单。\\n+ 角色和权限是多对多的关系，一个角色可以有多个访问权限，一个权限也可以被多个角色访问。\\n+ 用户和角色是多对多的关系，一个用户可以有多个角色，一个角色可以被多个用户拥有。\\n\\n**注意**\\n + 用户的访问权限该博客是使用 SpringSecurity 来控制的，具体的见后序分析。\\n + 用户对菜单的访问是在查询是用代码控制的。由用户id可以确定角色集合，再通过角色即可以确定访问的菜单集合\\n\\n### 建表语句\\n\\n```sql\\n-- ----------------------------\\n-- Table structure for tb_article 文章表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article`;\\nCREATE TABLE `tb_article`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'作者\',\\n  `category_id` int(11) DEFAULT NULL COMMENT \'文章分类\',\\n  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'文章缩略图\',\\n  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标题\',\\n  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'内容\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'发表时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_top` tinyint(1) DEFAULT NULL COMMENT \'是否置顶 0否 1是\',\\n  `is_draft` tinyint(1) DEFAULT 0 COMMENT \'是否为草稿 0否 1是\',\\n  `is_delete` tinyint(1) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `category_id`(`category_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_category 分类表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_category`;\\nCREATE TABLE `tb_category`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'分类名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_tag 标签表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_tag`;\\nCREATE TABLE `tb_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'标签名\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_article_tag 文章标签关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_article_tag`;\\nCREATE TABLE `tb_article_tag`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `article_id` int(11) NOT NULL COMMENT \'文章id\',\\n  `tag_id` int(11) NOT NULL COMMENT \'标签id\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,\\n  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_friend_link 友链表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_friend_link`;\\nCREATE TABLE `tb_friend_link`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接名\',\\n  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接头像\',\\n  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接地址\',\\n  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'链接介绍\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_friend_link_user`(`link_name`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_message 留言表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_message`;\\nCREATE TABLE `tb_message`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户地址\',\\n  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'昵称\',\\n  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'头像\',\\n  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'留言内容\',\\n  `time` tinyint(1) DEFAULT NULL COMMENT \'弹幕速度\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'发布时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 3435 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_comment 评论表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_comment`;\\nCREATE TABLE `tb_comment`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) NOT NULL COMMENT \'评论用户Id\',\\n  `article_id` int(11) DEFAULT NULL COMMENT \'评论文章id\',\\n  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'评论内容\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'评论时间\',\\n  `reply_id` int(11) DEFAULT NULL COMMENT \'回复用户id\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父评论id\',\\n  `is_delete` tinyint(4) DEFAULT 0 COMMENT \'是否删除  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `fk_comment_user`(`user_id`) USING BTREE,\\n  INDEX `fk_comment_article`(`article_id`) USING BTREE,\\n  INDEX `fk_comment_parent`(`parent_id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 268 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_operation_log 操作日志表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_operation_log`;\\nCREATE TABLE `tb_operation_log`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作模块\',\\n  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作类型\',\\n  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作url\',\\n  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作方法\',\\n  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作描述\',\\n  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'请求参数\',\\n  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'返回数据\',\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户昵称\',\\n  `ip_addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作ip\',\\n  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'操作地址\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_menu 菜单表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_menu`;\\nCREATE TABLE `tb_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单名\',\\n  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单路径\',\\n  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'组件\',\\n  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'菜单icon\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `order_num` tinyint(4) DEFAULT NULL COMMENT \'排序\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父id\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否1是\',\\n  `is_hidden` tinyint(1) DEFAULT NULL COMMENT \'是否隐藏  0否1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 203 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_resource 权限表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_resource`;\\nCREATE TABLE `tb_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'资源名\',\\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'权限路径\',\\n  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'请求方式\',\\n  `parent_id` int(11) DEFAULT NULL COMMENT \'父权限id\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'修改时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用 0否 1是\',\\n  `is_anonymous` tinyint(4) DEFAULT NULL COMMENT \'是否匿名访问 0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 250 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role 角色表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role`;\\nCREATE TABLE `tb_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色名\',\\n  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'角色描述\',\\n  `create_time` datetime(0) DEFAULT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT NULL COMMENT \'是否禁用  0否 1是\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_menu 角色菜单关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_menu`;\\nCREATE TABLE `tb_role_menu`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `menu_id` int(11) DEFAULT NULL COMMENT \'菜单id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 1265 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_role_resource 角色权限关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_role_resource`;\\nCREATE TABLE `tb_role_resource`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  `resource_id` int(11) DEFAULT NULL COMMENT \'权限id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 4181 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_auth 用户登录信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_auth`;\\nCREATE TABLE `tb_user_auth`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_info_id` int(11) NOT NULL COMMENT \'用户信息id\',\\n  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户名\',\\n  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'密码\',\\n  `login_type` tinyint(1) NOT NULL COMMENT \'登录类型\',\\n  `ip_addr` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户登录ip\',\\n  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'ip来源\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `last_login_time` datetime(0) DEFAULT NULL COMMENT \'上次登录时间\',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  UNIQUE INDEX `username`(`username`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 201 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_info 用户个人信息表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_info`;\\nCREATE TABLE `tb_user_info`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'邮箱号\',\\n  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'用户昵称\',\\n  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT \'\' COMMENT \'用户头像\',\\n  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'用户简介\',\\n  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \'个人网站\',\\n  `create_time` datetime(0) NOT NULL COMMENT \'创建时间\',\\n  `update_time` datetime(0) DEFAULT NULL COMMENT \'更新时间\',\\n  `is_disable` tinyint(1) DEFAULT 0 COMMENT \'是否禁用\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 212 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_user_role 用户角色关系表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_user_role`;\\nCREATE TABLE `tb_user_role`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` int(11) DEFAULT NULL COMMENT \'用户id\',\\n  `role_id` int(11) DEFAULT NULL COMMENT \'角色id\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 221 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n\\n\\n-- ----------------------------\\n-- Table structure for tb_unique_view 网站单日访问量表\\n-- ----------------------------\\nDROP TABLE IF EXISTS `tb_unique_view`;\\nCREATE TABLE `tb_unique_view`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `create_time` datetime(0) NOT NULL COMMENT \'时间\',\\n  `views_count` int(11) NOT NULL COMMENT \'访问量\',\\n  PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 225 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620140202321.jpg\",\"articleTitle\":\"博客数据库\",\"categoryId\":13,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.229', '安徽省合肥市 联通', '2021-05-04 22:56:46');
INSERT INTO `tb_operation_log` VALUES (23, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"#### SpringScurity 权限控制\\n\\n**SpringSecurity 配置类 config.WebSecurityConfig**\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n**用户登录信息，UserDetails 的实现类 UserInfoDTO **\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**自定义登录校验 UserDetailsServiceImpl**\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n**登录成功处理器 handler.AuthenticationSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功！\\\", userLoginDTO)));\\n    }\\n\\n    /**\\n     * 更新用户信息\\n     */\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n**登录失败处理器 handler.AuthenticationFailHandlerImpl**\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n**权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl**\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n**用户未登录处理 hanlder.AuthenticationEntryPointImpl**\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n**自定义的 FilterInvocationSecurityMetadataSource**\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n**自定决策器 AccessDecisionManagerImpl**\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\",\"articleCover\":\"\",\"articleTitle\":\"博客权限控制 SpringSecurity\",\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:46:15');
INSERT INTO `tb_operation_log` VALUES (24, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"SpringSecurity\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:46:22');
INSERT INTO `tb_operation_log` VALUES (25, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"#### SpringScurity 权限控制\\n\\n**SpringSecurity 配置类 config.WebSecurityConfig**\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n**用户登录信息，UserDetails 的实现类 UserInfoDTO **\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**自定义登录校验 UserDetailsServiceImpl**\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n**登录成功处理器 handler.AuthenticationSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功！\\\", userLoginDTO)));\\n    }\\n\\n    /**\\n     * 更新用户信息\\n     */\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n**登录失败处理器 handler.AuthenticationFailHandlerImpl**\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n**权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl**\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n**用户未登录处理 hanlder.AuthenticationEntryPointImpl**\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n**自定义的 FilterInvocationSecurityMetadataSource**\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n**自定决策器 AccessDecisionManagerImpl**\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620215219268.jpg\",\"articleTitle\":\"博客权限控制 SpringSecurity\",\"categoryId\":13,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19,20]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:47:02');
INSERT INTO `tb_operation_log` VALUES (26, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## SpringScurity 权限控制\\n\\n### SpringSecurity 配置类 config.WebSecurityConfig\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n### 用户登录信息，UserDetails 的实现类 UserInfoDTO\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n### 自定义登录校验 UserDetailsServiceImpl\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n### 登录成功处理器 handler.AuthenticationSuccessHandlerImpl\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功！\\\", userLoginDTO)));\\n    }\\n\\n    /**\\n     * 更新用户信息\\n     */\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n### 登录失败处理器 handler.AuthenticationFailHandlerImpl\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n### 权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n### 用户未登录处理 hanlder.AuthenticationEntryPointImpl\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n### 自定义的 FilterInvocationSecurityMetadataSource\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n### 自定决策器 AccessDecisionManagerImpl\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620215219268.jpg\",\"articleTitle\":\"博客权限控制 SpringSecurity\",\"categoryId\":13,\"id\":42,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19,20]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:50:46');
INSERT INTO `tb_operation_log` VALUES (27, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## SpringScurity 权限控制\\n\\n### SpringSecurity 配置类 config.WebSecurityConfig\\n\\n```java\\n/**\\n * Security配置类\\n */\\n@Configuration\\n// 开启security自定义配置\\n@EnableWebSecurity\\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\\n    @Autowired\\n    private AuthenticationEntryPointImpl authenticationEntryPoint;\\n    @Autowired\\n    private AccessDeniedHandlerImpl accessDeniedHandler;\\n    @Autowired\\n    private AuthenticationSuccessHandlerImpl authenticationSuccessHandler;\\n    @Autowired\\n    private AuthenticationFailHandlerImpl authenticationFailHandler;\\n    @Autowired\\n    private LogoutSuccessHandlerImpl logoutSuccessHandler;\\n\\n    // 自定义登录校验接口\\n    @Autowired\\n    private UserDetailsServiceImpl userDetailsService;\\n\\n    @Bean\\n    public FilterInvocationSecurityMetadataSource securityMetadataSource() {\\n        return new FilterInvocationSecurityMetadataSourceImpl();\\n    }\\n\\n    @Bean\\n    public AccessDecisionManager accessDecisionManager() {\\n        return new AccessDecisionManagerImpl();\\n    }\\n\\n    @Bean\\n    public SessionRegistry sessionRegistry() {\\n        return new SessionRegistryImpl();\\n    }\\n\\n    // 防用户重复登录\\n    @Bean\\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\\n        return new HttpSessionEventPublisher();\\n    }\\n\\n    /**\\n     * 密码加密\\n     */\\n    @Bean\\n    public PasswordEncoder passwordEncoder() {\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\\n        // 指定 userDetailsService\\n        auth.userDetailsService(userDetailsService)\\n                // 密码编码器\\n                .passwordEncoder(passwordEncoder());\\n    }\\n\\n    /**\\n     * 配置权限\\n     */\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        // 配置登录注销路径\\n        http.formLogin()\\n                .loginProcessingUrl(\\\"/login\\\")\\n                // 登录成功处理\\n                .successHandler(authenticationSuccessHandler)\\n                // 登陆失败处理\\n                .failureHandler(authenticationFailHandler).and()\\n                .logout().logoutUrl(\\\"/logout\\\")\\n                // 退出登录处理\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        // 配置路由权限信息\\n        http.authorizeRequests()\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {\\n                        // 设置自定义 FilterInvocationSecurityMetadataSource\\n                        fsi.setSecurityMetadataSource(securityMetadataSource());\\n                        // 设置自定义的 AccessDecisionManager\\n                        fsi.setAccessDecisionManager(accessDecisionManager());\\n                        return fsi;\\n                    }\\n                })\\n                .anyRequest().permitAll()\\n                .and()\\n                // 关闭跨站请求防护\\n                .csrf().disable().exceptionHandling()\\n                // 未登录处理\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                // 权限不足处理\\n                .accessDeniedHandler(accessDeniedHandler).and()\\n                // SpringSecurity使用X-Frame-Options防止网页被Frame，把x-frame-options disable\\n                .headers().frameOptions().disable()\\n                .and()\\n                // 开启session管理，session并发最多20个超出后，旧的session被注销，新的会注册，这种操作称为缺省实现。\\n                .sessionManagement()\\n                .maximumSessions(20)\\n                // sessionRegistry 用来统计在线用户\\n                .sessionRegistry(sessionRegistry());\\n    }\\n}\\n```\\n\\n### 用户登录信息，UserDetails 的实现类 UserInfoDTO\\n\\n```java\\n/*\\n * 用户登录信息\\n */\\n@Data\\n@Builder\\npublic class UserInfoDTO implements UserDetails {\\n    /**\\n     * 用户账号id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 用户信息id\\n     */\\n    private Integer userInfoId;\\n\\n    /**\\n     * 邮箱号\\n     */\\n    private String email;\\n\\n    /**\\n     * 登录方式\\n     */\\n    private Integer loginType;\\n\\n    /**\\n     * 用户名\\n     */\\n    private String username;\\n\\n    /**\\n     * 密码\\n     */\\n    private String password;\\n\\n    /**\\n     * 用户角色\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 用户昵称\\n     */\\n    private String nickname;\\n\\n    /**\\n     * 用户头像\\n     */\\n    private String avatar;\\n\\n    /**\\n     * 用户简介\\n     */\\n    private String intro;\\n\\n    /**\\n     * 个人网站\\n     */\\n    private String webSite;\\n\\n    /**\\n     * 点赞文章集合\\n     */\\n    private Set<Integer> articleLikeSet;\\n\\n    /**\\n     * 点赞评论集合\\n     */\\n    private Set<Integer> commentLikeSet;\\n\\n    /**\\n     * 用户登录ip\\n     */\\n    private String ipAddr;\\n\\n    /**\\n     * ip来源\\n     */\\n    private String ipSource;\\n\\n    /**\\n     * 浏览器\\n     */\\n    private String browser;\\n\\n    /**\\n     * 操作系统\\n     */\\n    private String os;\\n\\n    /**\\n     * 最近登录时间\\n     */\\n    private Date lastLoginTime;\\n\\n    /**\\n     * 获取角色集合\\n     * @return\\n     */\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return roleList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return this.username;\\n    }\\n\\n    /**\\n     * 账户是非过期的\\n     */\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户账号是非被锁定的\\n     */\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户密码是非过期的\\n     */\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    /**\\n     * 用户是否可用\\n     */\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n```\\n\\n### 自定义登录校验 UserDetailsServiceImpl\\n\\n```java\\n/**\\n * 自定义 UserDetailsService，将用户信息和权限注入进来\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n    @Autowired\\n    private UserInfoDao userInfoDao;\\n    @Autowired\\n    private RoleDao roleDao;\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n    @Resource\\n    private HttpServletRequest request;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) {\\n        if (StringUtils.isBlank(username)) {\\n            throw new ServeException(\\\"用户名不能为空！\\\");\\n        }\\n        // 查询账号是否存在\\n        UserAuth user = userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\\n                .select(UserAuth::getId, UserAuth::getUserInfoId, UserAuth::getUsername, UserAuth::getPassword, UserAuth::getLoginType)\\n                .eq(UserAuth::getUsername, username));\\n        if (Objects.isNull(user)) {\\n            throw new ServeException(\\\"用户名不存在!\\\");\\n        }\\n        // 查询账号信息\\n        UserInfo userInfo = userInfoDao.selectOne(new LambdaQueryWrapper<UserInfo>()\\n                .select(UserInfo::getId, UserInfo::getEmail, UserInfo::getNickname, UserInfo::getAvatar, UserInfo::getIntro, UserInfo::getWebSite, UserInfo::getIsDisable)\\n                .eq(UserInfo::getId, user.getUserInfoId()));\\n        // 查询账号对应的角色集合\\n        List<String> roleList = roleDao.listRolesByUserInfoId(userInfo.getId());\\n        // 查询账号点赞信息\\n        // 点赞的文章集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(userInfo.getId().toString());\\n        // 点赞的评论集合\\n        Set<Integer> commentLikeSet = (Set<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(userInfo.getId().toString());\\n        // 封装登录信息为 UserDetailsService，即 UserInfoDTO 对象\\n        return convertLoginUser(user, userInfo, roleList, articleLikeSet, commentLikeSet, request);\\n    }\\n}\\n\\n------------------------------------------------------------------------\\n/**\\n * 用户工具类\\n */\\npublic class UserUtil {\\n\\n    /**\\n     * 获取当前登录用户\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO getLoginUser() {\\n        return (UserInfoDTO) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\\n    }\\n\\n    /**\\n     * 封装用户登录信息\\n     *\\n     * @param user           用户账号\\n     * @param userInfo       用户信息\\n     * @param articleLikeSet 点赞文章id集合\\n     * @param commentLikeSet 点赞评论id集合\\n     * @param request        请求\\n     * @return 用户登录信息\\n     */\\n    public static UserInfoDTO convertLoginUser(UserAuth user, UserInfo userInfo, List<String> roleList, Set<Integer> articleLikeSet, Set<Integer> commentLikeSet, HttpServletRequest request) {\\n        // 获取登录信息\\n        String ipAddr = IpUtil.getIpAddr(request);\\n        String ipSource = IpUtil.getIpSource(ipAddr);\\n        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\\\"User-Agent\\\"));\\n        // 封装权限集合\\n        return UserInfoDTO.builder()\\n                .id(user.getId())\\n                .loginType(user.getLoginType())\\n                .userInfoId(userInfo.getId())\\n                .username(user.getUsername())\\n                .password(user.getPassword())\\n                .email(userInfo.getEmail())\\n                .roleList(roleList)\\n                .nickname(userInfo.getNickname())\\n                .avatar(userInfo.getAvatar())\\n                .intro(userInfo.getIntro())\\n                .webSite(userInfo.getWebSite())\\n                .articleLikeSet(articleLikeSet)\\n                .commentLikeSet(commentLikeSet)\\n                .ipAddr(ipAddr)\\n                .ipSource(ipSource)\\n                .browser(userAgent.getBrowser().getName())\\n                .os(userAgent.getOperatingSystem().getName())\\n                .lastLoginTime(new Date())\\n                .build();\\n    }\\n}\\n```\\n\\n### 登录成功处理器 handler.AuthenticationSuccessHandlerImpl\\n\\n```java\\n/**\\n * 登录成功处理，更新用户信息，返回登录用户信息\\n */\\n@Component\\npublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {\\n    @Autowired\\n    private UserAuthDao userAuthDao;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {\\n        // 更新用户ip，最近登录时间\\n        updateUserInfo();\\n        UserLoginDTO userLoginDTO = BeanCopyUtil.copyObject(UserUtil.getLoginUser(), UserLoginDTO.class);\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<UserInfoDTO>(true, StatusConst.OK, \\\"登录成功!\\\", userLoginDTO)));\\n    }\\n\\n    // 更新用户信息\\n    @Async\\n    public void updateUserInfo() {\\n        UserAuth userAuth = UserAuth.builder()\\n                .id(UserUtil.getLoginUser().getId())\\n                .ipAddr(UserUtil.getLoginUser().getIpAddr())\\n                .ipSource(UserUtil.getLoginUser().getIpSource())\\n                .lastLoginTime(UserUtil.getLoginUser().getLastLoginTime())\\n                .build();\\n        userAuthDao.updateById(userAuth);\\n    }\\n}\\n```\\n\\n### 登录失败处理器 handler.AuthenticationFailHandlerImpl\\n\\n```java\\n/**\\n * 登录失败处理，返回错误信息\\n */\\n@Component\\npublic class AuthenticationFailHandlerImpl implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.ERROR, e.getMessage())));\\n    }\\n}\\n```\\n\\n**退出成功处理器 handler.LogoutSuccessHandlerImpl**\\n\\n```java\\n/**\\n * 注销处理，返回成功信息\\n */\\n@Component\\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(true, StatusConst.OK,\\\"注销成功\\\")));\\n    }\\n}\\n```\\n\\n### 权限不足处理器（访问被拒绝）handler.AccessDeniedHandlerImpl\\n\\n```java\\n/**\\n * 用户权限不足，返回没有操作权限的错误信息\\n */\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n\\n    @Override\\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result(false, StatusConst.AUTHORIZED, \\\"没有操作权限\\\")));\\n    }\\n}\\n```\\n\\n### 用户未登录处理 hanlder.AuthenticationEntryPointImpl\\n\\n```java\\n/**\\n * 用户未登录处理，返回未登录的提示信息\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n\\n    @Override\\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {\\n        httpServletResponse.setContentType(\\\"application/json;charset=utf-8\\\");\\n        httpServletResponse.getWriter().write(JSON.toJSONString(new Result<>(false, StatusConst.NOT_LOGIN, \\\"请登录\\\")));\\n    }\\n}\\n```\\n\\n### 自定义的 FilterInvocationSecurityMetadataSource\\n\\n```java\\n/**\\n * 用来储存请求与权限的对应关系\\n */\\n@Component\\npublic class FilterInvocationSecurityMetadataSourceImpl implements FilterInvocationSecurityMetadataSource {\\n    /**\\n     * 接口角色列表\\n     */\\n    private static List<UrlRoleDTO> urlRoleList;\\n\\n    @Autowired\\n    private RoleDao roleDao;\\n\\n    /**\\n     * 加载接口角色信息，查询出所有的资源与角色的关系（一个资源对应角色集合，由UrlRoleDTO类体现）\\n     */\\n    @PostConstruct\\n    private void loadDataSource() {\\n        // 查询的是资源非匿名的集合\\n        urlRoleList = roleDao.listUrlRoles();\\n    }\\n\\n    /**\\n     * 清空接口角色信息\\n     */\\n    public void clearDataSource() {\\n        urlRoleList = null;\\n    }\\n\\n    /**\\n     * 返回请求的资源需要的角色集合\\n     * @param object FilterInvocation 类型，可以获取请求方式和请求路径\\n     */\\n    @Override\\n    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {\\n        // 修改接口角色关系后重新加载\\n        if (CollectionUtils.isEmpty(urlRoleList)) {\\n            this.loadDataSource();\\n        }\\n        FilterInvocation fi = (FilterInvocation) object;\\n        // 获取用户请求方式\\n        String method = fi.getRequest().getMethod();\\n        // 获取用户请求Url\\n        String url = fi.getRequest().getRequestURI();\\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\\n        // 获取接口角色信息，若无对应角色则禁止\\n        for (UrlRoleDTO urlRoleDTO : urlRoleList) {\\n            // 如果 url、method都相同\\n            if (antPathMatcher.match(urlRoleDTO.getUrl(), url) && urlRoleDTO.getRequestMethod().equals(method)) {\\n                List<String> roleList = urlRoleDTO.getRoleList();\\n                if (CollectionUtils.isEmpty(roleList)) {\\n                    return SecurityConfig.createList(\\\"disable\\\");\\n                }\\n                return SecurityConfig.createList(roleList.toArray(new String[]{}));\\n            }\\n        }\\n        return null;\\n    }\\n\\n    @Override\\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\\n        return null;\\n    }\\n\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return FilterInvocation.class.isAssignableFrom(aClass);\\n    }\\n}\\n\\n-------------------------------------------------------------------------------------------\\n/**\\n * 资源与角色的关系类，即访问一个资源需要用户哪些角色\\n * 这里的资源由 url 和 requestMethod 确定\\n */\\n@Data\\npublic class UrlRoleDTO {\\n\\n    /**\\n     * 资源id\\n     */\\n    private Integer id;\\n\\n    /**\\n     * 路径\\n     */\\n    private String url;\\n\\n    /**\\n     * 请求方式\\n     */\\n    private String requestMethod;\\n\\n    /**\\n     * 角色名\\n     */\\n    private List<String> roleList;\\n\\n    /**\\n     * 是否匿名\\n     */\\n    private Integer isAnonymous;\\n}\\n```\\n\\n### 自定决策器 AccessDecisionManagerImpl\\n\\n```java\\n/**\\n * 决策器，由AbstractSecurityInterceptor调用，负责鉴定用户是否有访问对应资源（方法或URL）的权限。\\n */\\n@Component\\npublic class AccessDecisionManagerImpl implements AccessDecisionManager {\\n\\n    /**\\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\\n     *\\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的 authorities。\\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\\n     * @param configAttributes configAttributes是本次访问需要的权限\\n     */\\n    @Override\\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\\n        // 获取用户权限列表\\n        List<String> permissionList = authentication.getAuthorities()\\n                .stream()\\n                .map(GrantedAuthority::getAuthority)\\n                .collect(Collectors.toList());\\n        // 判断该用户是否用户本次访问需要的权限\\n        for (ConfigAttribute item : configAttributes) {\\n            if (permissionList.contains(item.getAttribute())) {\\n                return;\\n            }\\n        }\\n        throw new AccessDeniedException(\\\"没有操作权限\\\");\\n    }\\n\\n    /**\\n     * 表示此 AccessDecisionManager 是否能够处理传递的ConfigAttribute呈现的授权请求\\n     */\\n    @Override\\n    public boolean supports(ConfigAttribute configAttribute) {\\n        return true;\\n    }\\n\\n    /**\\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\\n     */\\n    @Override\\n    public boolean supports(Class<?> aClass) {\\n        return true;\\n    }\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620215219268.jpg\",\"articleTitle\":\"博客权限控制 SpringSecurity\",\"categoryId\":13,\"id\":42,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19,20]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:52:39');
INSERT INTO `tb_operation_log` VALUES (28, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"redis\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:53:35');
INSERT INTO `tb_operation_log` VALUES (29, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## Redis 使用场景\\n\\n### Redis 配置类\\n\\n```java\\npackage top.bravecoder.blog.config;\\n\\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n/**\\n * redis配置\\n * @author zhangzhi\\n */\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\\n        redisTemplate.setConnectionFactory(factory);\\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\\n        ObjectMapper mapper = new ObjectMapper();\\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\\n        // mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL,\\n                JsonTypeInfo.As.PROPERTY);\\n        jackson2JsonRedisSerializer.setObjectMapper(mapper);\\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\\n        // key采用String的序列化方式\\n        redisTemplate.setKeySerializer(stringRedisSerializer);\\n        // hash的key也采用String的序列化方式\\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\\n        // value序列化方式采用jackson\\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\\n        // hash的value序列化方式采用jackson\\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\\n        redisTemplate.afterPropertiesSet();\\n        return redisTemplate;\\n    }\\n}\\n```\\n\\n### Redis常量\\n\\n```java\\npackage top.bravecoder.blog.constant;\\n\\n/**\\n * redis常量\\n */\\npublic class RedisPrefixConst {\\n\\n    /**\\n     * 验证码过期时间\\n     */\\n    public static final long CODE_EXPIRE_TIME = 15 * 60 * 1000;\\n\\n    /**\\n     * 验证码\\n     */\\n    public static final String CODE_KEY = \\\"code_\\\";\\n\\n    /**\\n     * 博客总浏览量\\n     */\\n    public static final String BLOG_VIEWS_COUNT = \\\"blog_views_count\\\";\\n\\n    /**\\n     * 文章浏览量\\n     */\\n    public static final String ARTICLE_VIEWS_COUNT = \\\"article_views_count\\\";\\n\\n    /**\\n     * 文章点赞量\\n     */\\n    public static final String ARTICLE_LIKE_COUNT = \\\"article_like_count\\\";\\n\\n    /**\\n     * 用户点赞文章\\n     */\\n    public static final String ARTICLE_USER_LIKE = \\\"article_user_like\\\";\\n\\n    /**\\n     * 评论点赞量\\n     */\\n    public static final String COMMENT_LIKE_COUNT = \\\"comment_like_count\\\";\\n\\n    /**\\n     * 用户点赞评论\\n     */\\n    public static final String COMMENT_USER_LIKE = \\\"comment_user_like\\\";\\n\\n    /**\\n     * 关于我信息\\n     */\\n    public static final String ABOUT = \\\"about\\\";\\n\\n    /**\\n     * 公告\\n     */\\n    public static final String NOTICE = \\\"notice\\\";\\n\\n    /**\\n     * ip集合\\n     */\\n    public static final String IP_SET = \\\"ip_set\\\";\\n}\\n```\\n\\n+ 用户注册时，存放验证码，**string**\\n\\n  ```java\\n  // 将验证码存入redis，设置过期时间为15分钟\\n  redisTemplate.boundValueOps(CODE_KEY + username).set(code);\\n  redisTemplate.expire(CODE_KEY + username, CODE_EXPIRE_TIME, TimeUnit.MILLISECONDS);\\n  ```\\n\\n+ 存放博客的总浏览量，**string**\\n\\n   ```java\\n   // 判断当前ip是否访问，增加访问量\\n    String ipAddr = IpUtil.getIpAddr(request);\\n    if (!ipAddr.equals(ip)) {\\n      session.setAttribute(\\\"ip\\\", ipAddr);\\n      // 博客总浏览量 +1\\n      redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n    }\\n   ```\\n\\n+ 存放文章的浏览量，**hash**\\n\\n  ```java\\n  // 判断是否第一次访问，增加浏览量\\n  Set<Integer> set = (Set<Integer>) session.getAttribute(\\\"articleSet\\\");\\n  if (Objects.isNull(set)) {\\n      set = new HashSet<>();\\n  }\\n  if (!set.contains(articleId)) {\\n      set.add(articleId);\\n      session.setAttribute(\\\"articleSet\\\", set);\\n      // 浏览量+1\\n      redisTemplate.boundHashOps(ARTICLE_VIEWS_COUNT).increment(articleId.toString(), 1);\\n  }\\n  ```\\n\\n+ 存放所有文章各自的点赞量和用户点赞的文章集合，**hash**\\n\\n```java\\n public void saveArticleLike(Integer articleId) {\\n        // 查询当前用户点赞过的文章id集合\\n        Set<Integer> articleLikeSet = (Set<Integer>) redisTemplate.boundHashOps(ARTICLE_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(articleLikeSet)) {\\n            articleLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (articleLikeSet.contains(articleId)) {\\n            // 点过赞则删除文章id\\n            articleLikeSet.remove(articleId);\\n            // 文章点赞量-1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), -1);\\n        } else {\\n            // 未点赞则增加文章id\\n            articleLikeSet.add(articleId);\\n            // 文章点赞量+1\\n            redisTemplate.boundHashOps(ARTICLE_LIKE_COUNT).increment(articleId.toString(), 1);\\n        }\\n        // 保存用户的点赞记录\\n  redisTemplate.boundHashOps(ARTICLE_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), articleLikeSet);\\n    }\\n```\\n\\n+ 存放所有评论各自的点赞量和用户点赞的评论集合，与上面类似，**hash**\\n\\n```java\\n public void saveCommentLike(Integer commentId) {\\n        // 查询当前用户点赞过的评论id集合\\n        HashSet<Integer> commentLikeSet = (HashSet<Integer>) redisTemplate.boundHashOps(COMMENT_USER_LIKE).get(UserUtil.getLoginUser().getUserInfoId().toString());\\n        // 第一次点赞则创建\\n        if (CollectionUtils.isEmpty(commentLikeSet)) {\\n            commentLikeSet = new HashSet<>();\\n        }\\n        // 判断是否点赞\\n        if (commentLikeSet.contains(commentId)) {\\n            // 点过赞则删除评论id\\n            commentLikeSet.remove(commentId);\\n            // 评论点赞量-1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), -1);\\n        } else {\\n            // 未点赞则增加评论id\\n            commentLikeSet.add(commentId);\\n            // 评论点赞量+1\\n            redisTemplate.boundHashOps(COMMENT_LIKE_COUNT).increment(commentId.toString(), 1);\\n        }\\n        // 保存点赞记录\\n  redisTemplate.boundHashOps(COMMENT_USER_LIKE).put(UserUtil.getLoginUser().getUserInfoId().toString(), commentLikeSet);\\n    }\\n```\\n\\n+ 存放关于我、公告信息，**string**\\n\\n  ```java\\n  public void updateAbout(String aboutContent) {\\n      redisTemplate.boundValueOps(ABOUT).set(aboutContent);\\n  }\\n\\n  public void updateNotice(String notice) {\\n      redisTemplate.boundValueOps(NOTICE).set(notice);\\n  }\\n\\n  ```\\n\\n+ 存放ip，统计每日用户量，**set**\\n\\n  暂时存储每天的ip集合，定时把当天的访问量存储到数据库，定时删除\\n\\n  ```java\\n\\n  /**\\n   * request监听\\n   */\\n  @Component\\n  public class ServletRequestListenerImpl implements ServletRequestListener {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n\\n      @Override\\n      public void requestInitialized(ServletRequestEvent sre) {\\n          HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\\n          HttpSession session = request.getSession();\\n          String ip = (String) session.getAttribute(\\\"ip\\\");\\n          // 判断当前ip是否访问，增加访问量\\n          String ipAddr = IpUtil.getIpAddr(request);\\n          if (!ipAddr.equals(ip)) {\\n              session.setAttribute(\\\"ip\\\", ipAddr);\\n              redisTemplate.boundValueOps(BLOG_VIEWS_COUNT).increment(1);\\n          }\\n          // 将ip存入redis，统计每日用户量\\n          redisTemplate.boundSetOps(IP_SET).add(ipAddr);\\n      }\\n\\n      // 每天凌晨0点1分执行一次\\n      @Scheduled(cron = \\\" 0 1 0 * * ?\\\")\\n      private void clear() {\\n          // 清空redis中的ip\\n          redisTemplate.delete(IP_SET);\\n      }\\n  }\\n\\n  -----------------------------------------------------------\\n  @Service\\n  public class UniqueViewServiceImpl extends ServiceImpl<UniqueViewDao, UniqueView> implements UniqueViewService {\\n      @Autowired\\n      private RedisTemplate redisTemplate;\\n      @Autowired\\n      private UniqueViewDao uniqueViewDao;\\n\\n      // 每天 0 点执行一次\\n      @Scheduled(cron = \\\" 0 0 0 * * ?\\\")\\n      @Override\\n      public void saveUniqueView() {\\n          // 获取每天用户量\\n          Long count = redisTemplate.boundSetOps(\\\"ip_set\\\").size();\\n          // 获取昨天日期插入数据\\n          UniqueView uniqueView = UniqueView.builder()\\n                  .createTime(DateUtil.getSomeDay(new Date(), -1))\\n                  .viewsCount(Objects.nonNull(count) ? count.intValue() : 0).build();\\n          uniqueViewDao.insert(uniqueView);\\n      }\\n  }\\n  ```\\n\\n## RabbitMQ使用场景\\n\\n### MQ常量类\\n\\n```java\\n/**\\n * MQ常量\\n */\\npublic class MQPrefixConst {\\n\\n    /**\\n     * email交换机\\n     */\\n    public static final String EMAIL_EXCHANGE = \\\"send\\\";\\n\\n    /**\\n     * 邮件队列\\n     */\\n    public static final String EMAIL_QUEUE = \\\"email\\\";\\n}\\n```\\n\\n### RabbitMQ配置类\\n\\n```java\\n/**\\n * Rabbitmq配置类\\n */\\n@Configuration\\npublic class RabbitConfig {\\n\\n    // 创建队列\\n    @Bean\\n    public Queue emailQueue() {\\n        return new Queue(MQPrefixConst.EMAIL_QUEUE, true);\\n    }\\n\\n    // 创建交换机\\n    @Bean\\n    public FanoutExchange emailExchange() {\\n        return new FanoutExchange(MQPrefixConst.EMAIL_EXCHANGE, true, false);\\n    }\\n\\n    // 把队列和交换机绑定在一起\\n    @Bean\\n    public Binding bindingEmailDirect() {\\n        return BindingBuilder.bind(emailQueue()).to(emailExchange());\\n    }\\n}\\n```\\n\\n### 消费者 EmailReceiver\\n\\n```java\\n/**\\n * 监听EMAIL_QUEUE，发送邮件\\n */\\n@Component\\n@RabbitListener(queues = MQPrefixConst.EMAIL_QUEUE)\\npublic class EmailReceiver {\\n    /**\\n     * 邮箱号\\n     */\\n    @Value(\\\"${spring.mail.username}\\\")\\n    private String email;\\n\\n    @Autowired\\n    private JavaMailSender javaMailSender;\\n\\n    @RabbitHandler\\n    public void process(byte[] data) {\\n        EmailDTO emailDTO = JSON.parseObject(new String(data), EmailDTO.class);\\n        SimpleMailMessage message = new SimpleMailMessage();\\n        message.setFrom(email);\\n        message.setTo(emailDTO.getEmail());\\n        message.setSubject(emailDTO.getSubject());\\n        message.setText(emailDTO.getContent());\\n        javaMailSender.send(message);\\n    }\\n}\\n```\\n\\n### 场景一\\n\\n用户注册时，对邮箱发送验证码\\n\\n```java\\nrabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", new Message(JSON.toJSONBytes(emailDTO), \\n                new MessageProperties()));\\n```\\n\\n### 场景二\\n\\n用户的评论收到回复时，发邮件进行通知\\n\\n```java\\n/**\\n * 通知评论用户\\n */\\n@Async\\npublic void notice(CommentVO commentVO) {\\n    // 判断是回复用户还是评论作者\\n    Integer userId = Objects.nonNull(commentVO.getReplyId()) ? commentVO.getReplyId() : BLOGGER_ID;\\n    // 查询邮箱号\\n    String email = userInfoDao.selectById(userId).getEmail();\\n    if (StringUtils.isNotBlank(email)) {\\n        // 判断页面路径\\n        String url = Objects.nonNull(commentVO.getArticleId()) ? URL + ARTICLE_PATH + commentVO.getArticleId() : URL + LINK_PATH;\\n        // 发送消息\\n        EmailDTO emailDTO = EmailDTO.builder()\\n            .email(email)\\n            .subject(\\\"评论提醒\\\")\\n            .content(\\\"您收到了一条新的回复，请前往\\\" + url + \\\"\\\\n页面查看\\\")\\n            .build();\\n        rabbitTemplate.convertAndSend(EMAIL_EXCHANGE, \\\"*\\\", \\n                       new Message(JSON.toJSONBytes(emailDTO), new MessageProperties()));\\n    }\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620215839705.jpg\",\"articleTitle\":\"博客中Redis和RabbitMQ的使用场景\",\"categoryId\":13,\"isDraft\":0,\"isTop\":1,\"tagIdList\":[19,21]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.179', '安徽省合肥市 联通', '2021-05-05 19:57:23');
INSERT INTO `tb_operation_log` VALUES (30, '角色模块', '新增或修改', '/admin/role', 'top.bravecoder.blog.controller.RoleController.listRoles', '保存或更新角色', '[{\"id\":1,\"menuIdList\":[1,2,6,7,8,9,10,3,11,12,202,13,14,201,4,16,15,17,18,19,20,5],\"roleLabel\":\"admin\",\"roleName\":\"管理员\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.214', '安徽省合肥市 联通', '2021-05-06 12:34:33');
INSERT INTO `tb_operation_log` VALUES (31, '博客信息模块', '修改', '/admin/about', 'top.bravecoder.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[\"双非渣本大三考研狗\\n\\n“世界上有个很可爱的人，现在这个人正在看这句话”\"]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '58.243.250.214', '安徽省合肥市 联通', '2021-05-06 13:53:13');
INSERT INTO `tb_operation_log` VALUES (32, '博客信息模块', '修改', '/admin/about', 'top.bravecoder.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[\"双非渣本大三考研狗\"]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '58.243.250.214', '安徽省合肥市 联通', '2021-05-06 13:56:44');
INSERT INTO `tb_operation_log` VALUES (33, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[35,32,34,36,37,38],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-07 08:29:48');
INSERT INTO `tb_operation_log` VALUES (34, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[38,37,36,35,34,32]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-07 08:30:01');
INSERT INTO `tb_operation_log` VALUES (35, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[41],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-07 08:30:13');
INSERT INTO `tb_operation_log` VALUES (36, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[33,31],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-07 08:32:00');
INSERT INTO `tb_operation_log` VALUES (37, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[41,33,31]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-07 08:32:06');
INSERT INTO `tb_operation_log` VALUES (38, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[39],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:56:18');
INSERT INTO `tb_operation_log` VALUES (39, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[39]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:56:25');
INSERT INTO `tb_operation_log` VALUES (40, '分类模块', '删除', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.deleteCategories', '删除分类', '[[12]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"删除成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:57:41');
INSERT INTO `tb_operation_log` VALUES (41, '标签模块', '删除', '/admin/tags', 'top.bravecoder.blog.controller.TagController.deleteTag', '删除标签', '[[18]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"删除成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:57:52');
INSERT INTO `tb_operation_log` VALUES (42, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"贪心\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:57:59');
INSERT INTO `tb_operation_log` VALUES (43, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"动态规划\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:58:05');
INSERT INTO `tb_operation_log` VALUES (44, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"二分\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:58:13');
INSERT INTO `tb_operation_log` VALUES (45, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"排序\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:58:20');
INSERT INTO `tb_operation_log` VALUES (46, '分类模块', '新增或修改', '/admin/categories', 'top.bravecoder.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"Java基础\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 14:58:54');
INSERT INTO `tb_operation_log` VALUES (47, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 1、最大值最小化\\n\\n### [POJ-3273 Monthly Expense](http://poj.org/problem?id=3273)\\n\\n**Description**\\n\\nFarmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ *moneyi* ≤ 10,000) that he will need to spend each day over the next *N* (1 ≤ *N* ≤ 100,000) days.\\n\\nFJ wants to create a budget for a sequential set of exactly *M* (1 ≤ *M* ≤ *N*) fiscal periods called \\\"fajomonths\\\". Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth.\\n\\nFJ\'s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit.\\n\\n**Input**\\n\\nLine 1: Two space-separated integers: *N* and *M*\\nLines 2..*N*+1: Line *i*+1 contains the number of dollars Farmer John spends on the *i*th day\\n\\n**Output**\\n\\nLine 1: The smallest possible monthly limit Farmer John can afford to live with.\\n\\n**Sample Input**\\n\\n```\\n7 5\\n100\\n400\\n300\\n100\\n500\\n101\\n400\\n```\\n\\n**Sample Output**\\n\\n```\\n500\\n```\\n\\n**题解：**\\n\\n题目大意：共N天，已知每天的花费，把这N天分成连续的m组，在求得各组的花费和以后，取出其中的最大值。问如何使这个最大值最小。\\n\\n分析：最大值最小化\\n\\n+ N天中最大的花费为left，N天的花费和为right\\n+ 二分，判断mid值是否符合分成m组的条件（具体细节见代码注释）\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n, m; // 分m段，则要划出m-1条线\\nint money[maxn];\\n\\nint check(int k) { // k是所有段中的最大值，希望其最小\\n\\tint sum = 0, num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\\n\\t\\tif (sum + money[i] > k) {  \\n\\t\\t\\tsum = money[i];\\n\\t\\t\\tnum++;\\n\\t\\t\\tprintf(\\\"%d %d\\\\n\\\", num, sum);\\n\\t\\t} else {\\n\\t\\t\\tsum += money[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\\n\\t\\treturn 0;\\n\\t}\\n\\treturn 1;\\n}\\n\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n\\t\\tint l = 0, r = 0, ans = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &money[i]);\\n\\t\\t\\tl = max(l, money[i]);\\n\\t\\t\\tr += money[i];\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) { // 符合，往左走\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t} else { // 不符合，往右走\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## 2、最小值最大化\\n\\n### [2018安徽省赛 J-数列分段](https://acm.webturing.com/problem.php?cid=1323&pid=9&langmask=262132&puzzle_mask=0)\\n\\n题目描述： 有n个整数，分成m段。使每一段的和的**最小值尽可能的大**。\\n\\n**输入**\\n\\n 第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有两个整数n，m，接下来一行是n个整数。其中T<=50,n,m<1e5 。\\n\\n**输出**\\n\\n 尽可能的大的每一段的和的最小值。\\n\\n**样例输入**\\n\\n```\\n1\\n5 3\\n4 5 4 5 1\\n```\\n\\n**样例输出**\\n\\n```\\n4\\n```\\n\\n**题解：**\\n\\n最小值最大化：check时，sum如果大于等于k立即划分为一段，num++，如果num大于等于m的，说明该k值一定满足。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nint T, n, m;\\nint a[maxn];\\n\\nint check(int k) {\\n\\tint num = 0, sum = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (sum + a[i] >= k) {\\n\\t\\t\\tnum++;\\n\\t\\t\\tsum = 0;\\n\\t\\t} else {\\n\\t\\t\\tsum += a[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {\\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tint r = 0;\\n\\t\\tint l = 0x3f3f3f3f;\\n\\t\\tint ans = 0;\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t\\tr += a[i];\\n\\t\\t\\tl = min(l, a[i]);\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## 3、基本思想\\n\\n### [POJ-3122 Pie](http://poj.org/problem?id=3122)\\n\\n**Description**\\n\\n我有N个不同口味、不同大小的派。\\n有F个朋友会来参加我的派对，每个人会拿到一块派（不能由几个派的小块拼成；可以是一整个派）。\\n所有人拿到的派必须是同样大小的（但不需要是同样形状的）。\\n当然，我也要给自己留一块，而这一块也要和其他人的同样大小。\\n每个派都是一个高为1，半径不等的圆柱体。\\n请问我们每个人拿到的派最大是多少？\\n\\n**Input**\\n\\n第一行输入一个T代表组数。\\n随后T组包含两个正整数N和F，1 ≤ N, F ≤ 10000和N个1到10000之间的整数，表示派的数量，朋友的数量和每个派的半径。\\n\\n**Output**\\n\\n输出每个人能得到的最大的派的体积，精确到小数点后四位。\\n\\n**Sample Input**\\n\\n3\\n3 3\\n4 3 3\\n1 24\\n5\\n10 5\\n1 4 2 3 4 5 6 5 4 2\\n\\n**Sample Output**\\n\\n25.1327\\n3.1416\\n50.2655\\n\\n#### 代码\\n\\n**思路：**找出最大的派的面积，最小则为0，进行二分，判断每次的中间值是否可行，以缩小范围\\n\\n```c++\\n#include<iostream>\\n#include<cmath>\\nusing namespace std;\\n\\nconst double PI = acos(-1.0);\\n\\ndouble pie[10001];\\nint main()\\n{\\n\\tint t, n, f;\\n\\t\\n\\tscanf(\\\"%d\\\", &t);\\n\\tfor (int i = 0; i < t; i++)\\n\\t{\\n\\t\\tscanf(\\\"%d%d\\\", &n, &f);\\n\\t\\tf++;\\n\\t\\t\\n\\t\\tdouble l = 0, r = 0;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tscanf(\\\"%lf\\\", &pie[j]);\\n\\t\\t\\tpie[j] = pie[j]*pie[j];\\n\\t\\t\\tif (r < pie[j])\\n\\t\\t\\t\\tr = pie[j];\\n\\t\\t}\\n\\t\\tdouble mid;\\n\\t\\twhile (r - l > 1e-6)\\n\\t\\t{\\n\\t\\t\\tmid = (l + r) / 2;\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt += pie[j] / mid;\\n\\t\\t\\t\\tif (cnt >= f)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tr = mid;\\n\\t\\t}\\n\\t\\tprintf(\\\"%.4lf\\\\n\\\", l*PI);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620458051532.jpeg\",\"articleTitle\":\"二分刷题记录\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[24]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:14:24');
INSERT INTO `tb_operation_log` VALUES (48, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 1、最大值最小化\\n\\n### [POJ-3273 Monthly Expense](http://poj.org/problem?id=3273)\\n\\n**Description**\\n\\nFarmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ *moneyi* ≤ 10,000) that he will need to spend each day over the next *N* (1 ≤ *N* ≤ 100,000) days.\\n\\nFJ wants to create a budget for a sequential set of exactly *M* (1 ≤ *M* ≤ *N*) fiscal periods called \\\"fajomonths\\\". Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth.\\n\\nFJ\'s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit.\\n\\n**Input**\\n\\nLine 1: Two space-separated integers: *N* and *M*\\nLines 2..*N*+1: Line *i*+1 contains the number of dollars Farmer John spends on the *i*th day\\n\\n**Output**\\n\\nLine 1: The smallest possible monthly limit Farmer John can afford to live with.\\n\\n**Sample Input**\\n\\n```bash\\n7 5\\n100\\n400\\n300\\n100\\n500\\n101\\n400\\n```\\n\\n**Sample Output**\\n\\n```bash\\n500\\n```\\n\\n**题解：**\\n\\n题目大意：共N天，已知每天的花费，把这N天分成连续的m组，在求得各组的花费和以后，取出其中的最大值。问如何使这个最大值最小。\\n\\n分析：最大值最小化\\n\\n+ N天中最大的花费为left，N天的花费和为right\\n+ 二分，判断mid值是否符合分成m组的条件（具体细节见代码注释）\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n, m; // 分m段，则要划出m-1条线\\nint money[maxn];\\n\\nint check(int k) { // k是所有段中的最大值，希望其最小\\n\\tint sum = 0, num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\\n\\t\\tif (sum + money[i] > k) {  \\n\\t\\t\\tsum = money[i];\\n\\t\\t\\tnum++;\\n\\t\\t\\tprintf(\\\"%d %d\\\\n\\\", num, sum);\\n\\t\\t} else {\\n\\t\\t\\tsum += money[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\\n\\t\\treturn 0;\\n\\t}\\n\\treturn 1;\\n}\\n\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n\\t\\tint l = 0, r = 0, ans = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &money[i]);\\n\\t\\t\\tl = max(l, money[i]);\\n\\t\\t\\tr += money[i];\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) { // 符合，往左走\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t} else { // 不符合，往右走\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## 2、最小值最大化\\n\\n### [2018安徽省赛 J-数列分段](https://acm.webturing.com/problem.php?cid=1323&pid=9&langmask=262132&puzzle_mask=0)\\n\\n题目描述： 有n个整数，分成m段。使每一段的和的**最小值尽可能的大**。\\n\\n**输入**\\n\\n 第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有两个整数n，m，接下来一行是n个整数。其中T<=50,n,m<1e5 。\\n\\n**输出**\\n\\n 尽可能的大的每一段的和的最小值。\\n\\n**样例输入**\\n\\n```bash\\n1\\n5 3\\n4 5 4 5 1\\n```\\n\\n**样例输出**\\n\\n```bash\\n4\\n```\\n\\n**题解：**\\n\\n最小值最大化：check时，sum如果大于等于k立即划分为一段，num++，如果num大于等于m的，说明该k值一定满足。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nint T, n, m;\\nint a[maxn];\\n\\nint check(int k) {\\n\\tint num = 0, sum = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (sum + a[i] >= k) {\\n\\t\\t\\tnum++;\\n\\t\\t\\tsum = 0;\\n\\t\\t} else {\\n\\t\\t\\tsum += a[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {\\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tint r = 0;\\n\\t\\tint l = 0x3f3f3f3f;\\n\\t\\tint ans = 0;\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t\\tr += a[i];\\n\\t\\t\\tl = min(l, a[i]);\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## 3、基本思想\\n\\n### [POJ-3122 Pie](http://poj.org/problem?id=3122)\\n\\n**Description**\\n\\n我有N个不同口味、不同大小的派。\\n有F个朋友会来参加我的派对，每个人会拿到一块派（不能由几个派的小块拼成；可以是一整个派）。\\n所有人拿到的派必须是同样大小的（但不需要是同样形状的）。\\n当然，我也要给自己留一块，而这一块也要和其他人的同样大小。\\n每个派都是一个高为1，半径不等的圆柱体。\\n请问我们每个人拿到的派最大是多少？\\n\\n**Input**\\n\\n第一行输入一个T代表组数。\\n随后T组包含两个正整数N和F，1 ≤ N, F ≤ 10000和N个1到10000之间的整数，表示派的数量，朋友的数量和每个派的半径。\\n\\n**Output**\\n\\n输出每个人能得到的最大的派的体积，精确到小数点后四位。\\n\\n**Sample Input**\\n\\n3\\n3 3\\n4 3 3\\n1 24\\n5\\n10 5\\n1 4 2 3 4 5 6 5 4 2\\n\\n**Sample Output**\\n\\n25.1327\\n3.1416\\n50.2655\\n\\n#### 代码\\n\\n**思路** 找出最大的派的面积，最小则为0，进行二分，判断每次的中间值是否可行，以缩小范围\\n\\n```c++\\n#include<iostream>\\n#include<cmath>\\nusing namespace std;\\n\\nconst double PI = acos(-1.0);\\n\\ndouble pie[10001];\\nint main()\\n{\\n\\tint t, n, f;\\n\\t\\n\\tscanf(\\\"%d\\\", &t);\\n\\tfor (int i = 0; i < t; i++)\\n\\t{\\n\\t\\tscanf(\\\"%d%d\\\", &n, &f);\\n\\t\\tf++;\\n\\t\\t\\n\\t\\tdouble l = 0, r = 0;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tscanf(\\\"%lf\\\", &pie[j]);\\n\\t\\t\\tpie[j] = pie[j]*pie[j];\\n\\t\\t\\tif (r < pie[j])\\n\\t\\t\\t\\tr = pie[j];\\n\\t\\t}\\n\\t\\tdouble mid;\\n\\t\\twhile (r - l > 1e-6)\\n\\t\\t{\\n\\t\\t\\tmid = (l + r) / 2;\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt += pie[j] / mid;\\n\\t\\t\\t\\tif (cnt >= f)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tr = mid;\\n\\t\\t}\\n\\t\\tprintf(\\\"%.4lf\\\\n\\\", l*PI);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620458051532.jpeg\",\"articleTitle\":\"二分刷题记录\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[24]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:16:21');
INSERT INTO `tb_operation_log` VALUES (49, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[45],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:17:08');
INSERT INTO `tb_operation_log` VALUES (50, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 1、最大值最小化\\n\\n### [POJ-3273 Monthly Expense](http://poj.org/problem?id=3273)\\n\\n**Description**\\n\\nFarmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ *moneyi* ≤ 10,000) that he will need to spend each day over the next *N* (1 ≤ *N* ≤ 100,000) days.\\n\\nFJ wants to create a budget for a sequential set of exactly *M* (1 ≤ *M* ≤ *N*) fiscal periods called \\\"fajomonths\\\". Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth.\\n\\nFJ\'s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit.\\n\\n**Input**\\n\\nLine 1: Two space-separated integers: *N* and *M*\\nLines 2..*N*+1: Line *i*+1 contains the number of dollars Farmer John spends on the *i*th day\\n\\n**Output**\\n\\nLine 1: The smallest possible monthly limit Farmer John can afford to live with.\\n\\n**Sample Input**\\n\\n```c++\\n7 5\\n100\\n400\\n300\\n100\\n500\\n101\\n400\\n```\\n\\n**Sample Output**\\n\\n```c++\\n500\\n```\\n\\n**题解：**\\n\\n题目大意：共N天，已知每天的花费，把这N天分成连续的m组，在求得各组的花费和以后，取出其中的最大值。问如何使这个最大值最小。\\n\\n分析：最大值最小化\\n\\n+ N天中最大的花费为left，N天的花费和为right\\n+ 二分，判断mid值是否符合分成m组的条件（具体细节见代码注释）\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n, m; // 分m段，则要划出m-1条线\\nint money[maxn];\\n\\nint check(int k) { // k是所有段中的最大值，希望其最小\\n\\tint sum = 0, num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\\n\\t\\tif (sum + money[i] > k) {  \\n\\t\\t\\tsum = money[i];\\n\\t\\t\\tnum++;\\n\\t\\t\\tprintf(\\\"%d %d\\\\n\\\", num, sum);\\n\\t\\t} else {\\n\\t\\t\\tsum += money[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\\n\\t\\treturn 0;\\n\\t}\\n\\treturn 1;\\n}\\n\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n\\t\\tint l = 0, r = 0, ans = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &money[i]);\\n\\t\\t\\tl = max(l, money[i]);\\n\\t\\t\\tr += money[i];\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) { // 符合，往左走\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t} else { // 不符合，往右走\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## 2、最小值最大化\\n\\n### [2018安徽省赛 J-数列分段](https://acm.webturing.com/problem.php?cid=1323&pid=9&langmask=262132&puzzle_mask=0)\\n\\n题目描述： 有n个整数，分成m段。使每一段的和的**最小值尽可能的大**。\\n\\n**输入**\\n\\n 第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有两个整数n，m，接下来一行是n个整数。其中T<=50,n,m<1e5 。\\n\\n**输出**\\n\\n 尽可能的大的每一段的和的最小值。\\n\\n**样例输入**\\n\\n```c++\\n1\\n5 3\\n4 5 4 5 1\\n```\\n\\n**样例输出**\\n\\n```c++\\n4\\n```\\n\\n**题解：**\\n\\n最小值最大化：check时，sum如果大于等于k立即划分为一段，num++，如果num大于等于m的，说明该k值一定满足。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nint T, n, m;\\nint a[maxn];\\n\\nint check(int k) {\\n\\tint num = 0, sum = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (sum + a[i] >= k) {\\n\\t\\t\\tnum++;\\n\\t\\t\\tsum = 0;\\n\\t\\t} else {\\n\\t\\t\\tsum += a[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {\\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tint r = 0;\\n\\t\\tint l = 0x3f3f3f3f;\\n\\t\\tint ans = 0;\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t\\tr += a[i];\\n\\t\\t\\tl = min(l, a[i]);\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## 3、基本思想\\n\\n### [POJ-3122 Pie](http://poj.org/problem?id=3122)\\n\\n**Description**\\n\\n我有N个不同口味、不同大小的派。\\n有F个朋友会来参加我的派对，每个人会拿到一块派（不能由几个派的小块拼成；可以是一整个派）。\\n所有人拿到的派必须是同样大小的（但不需要是同样形状的）。\\n当然，我也要给自己留一块，而这一块也要和其他人的同样大小。\\n每个派都是一个高为1，半径不等的圆柱体。\\n请问我们每个人拿到的派最大是多少？\\n\\n**Input**\\n\\n第一行输入一个T代表组数。\\n随后T组包含两个正整数N和F，1 ≤ N, F ≤ 10000和N个1到10000之间的整数，表示派的数量，朋友的数量和每个派的半径。\\n\\n**Output**\\n\\n输出每个人能得到的最大的派的体积，精确到小数点后四位。\\n\\n**Sample Input**\\n\\n3\\n3 3\\n4 3 3\\n1 24\\n5\\n10 5\\n1 4 2 3 4 5 6 5 4 2\\n\\n**Sample Output**\\n\\n25.1327\\n3.1416\\n50.2655\\n\\n#### 代码\\n\\n**思路** 找出最大的派的面积，最小则为0，进行二分，判断每次的中间值是否可行，以缩小范围\\n\\n```c++\\n#include<iostream>\\n#include<cmath>\\nusing namespace std;\\n\\nconst double PI = acos(-1.0);\\n\\ndouble pie[10001];\\nint main()\\n{\\n\\tint t, n, f;\\n\\t\\n\\tscanf(\\\"%d\\\", &t);\\n\\tfor (int i = 0; i < t; i++)\\n\\t{\\n\\t\\tscanf(\\\"%d%d\\\", &n, &f);\\n\\t\\tf++;\\n\\t\\t\\n\\t\\tdouble l = 0, r = 0;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tscanf(\\\"%lf\\\", &pie[j]);\\n\\t\\t\\tpie[j] = pie[j]*pie[j];\\n\\t\\t\\tif (r < pie[j])\\n\\t\\t\\t\\tr = pie[j];\\n\\t\\t}\\n\\t\\tdouble mid;\\n\\t\\twhile (r - l > 1e-6)\\n\\t\\t{\\n\\t\\t\\tmid = (l + r) / 2;\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt += pie[j] / mid;\\n\\t\\t\\t\\tif (cnt >= f)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tr = mid;\\n\\t\\t}\\n\\t\\tprintf(\\\"%.4lf\\\\n\\\", l*PI);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620458051532.jpeg\",\"articleTitle\":\"二分刷题记录\",\"categoryId\":15,\"id\":44,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[24]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:18:18');
INSERT INTO `tb_operation_log` VALUES (51, '留言模块', '删除', '/admin/messages', 'top.bravecoder.blog.controller.MessageController.deleteMessages', '删除留言', '[[3434,3433,3432]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:19:16');
INSERT INTO `tb_operation_log` VALUES (52, '评论模块', '修改', '/admin/comments', 'top.bravecoder.blog.controller.CommentController.deleteComment', '删除或恢复评论', '[{\"idList\":[267,266,265,264],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:19:33');
INSERT INTO `tb_operation_log` VALUES (53, '评论模块', '删除', '/admin/comments', 'top.bravecoder.blog.controller.CommentController.deleteComments', '物理删除评论', '[[267,266,265,264]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:19:37');
INSERT INTO `tb_operation_log` VALUES (54, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[45]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:19:56');
INSERT INTO `tb_operation_log` VALUES (55, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"程序设计竞赛\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:44:34');
INSERT INTO `tb_operation_log` VALUES (56, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [最多约数](https://acm.webturing.com/problem.php?cid=1643&pid=0&langmask=262141&puzzle_mask=0)\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 2000000;\\nint dp[maxn]; // dp[i] 存储 i 的约数\\n\\nint main() {\\n\\tint a, b;\\n\\tcin>>a>>b;\\n\\tint res = 0;\\n\\tfor (int i = a; i <= b; i++) {\\n        // 以 i 的倍数进行增加\\n\\t\\tfor (int j = i; j <= b; j += i) {\\n\\t\\t\\tdp[j]++; // dp[j]++是因为，i 此时是 j 的约数，j = n*i;\\n\\t\\t}\\n\\t\\tres = max(res, dp[i]);\\n\\t}\\n\\tcout<<res<<endl;\\n\\treturn 0;\\n} \\n```\\n\\n## [会场安排问题](https://acm.webturing.com/problem.php?cid=1643&pid=1&langmask=262141&puzzle_mask=0)\\n\\n每个活动都有一个开始时间和一个结束时间，所有需要的会议数是活动之间重叠的次数 + 1\\n\\n```c++\\n#include<bits/stdc++.h> \\nusing namespace std;\\n\\nconst int maxn = 1000001;\\n\\ntypedef struct node {\\n\\tint start;\\n\\tint end;\\n} Act;\\n\\nbool cmp(Act a, Act b) {\\n\\treturn a.start < b.start;\\n}\\n\\n// 活动数组 \\nAct acts[maxn];\\nint k;\\nint main()\\n{\\n\\tcin>>k;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tcin>>acts[i].start>>acts[i].end;\\n\\t}\\n\\t// 把所有活动按开始时间升序进行排列 \\n\\tsort(acts, acts + k, cmp);\\n\\tint max = 0;\\n\\tfor (int i = 1; i < k; i++) {\\n\\t\\tint count = 1;\\n\\t\\tfor (int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t// 如果两个活动时间有重叠，则需要新开会议 \\n\\t\\t\\tif (acts[i].start < acts[j].end) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (count > max) {\\n\\t\\t\\tmax = count;\\n\\t\\t}\\n\\t}\\n\\tcout<<max<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n## [数位的幂](https://acm.webturing.com/problem.php?cid=1643&pid=2&langmask=262141&puzzle_mask=0)\\n\\n快速幂 + 模运算\\n\\n1. (a + b) % p = (a % p + b % p) % p （1）\\n2. (a - b) % p = (a % p - b % p ) % p （2）\\n3. **(a \\\\* b) % p = (a % p * b % p) % p （3）**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int P = 1000000007;\\n\\nlong long fastPower(long long base, long long power) {\\n    long long result = 1;\\n    while (power > 0) {\\n        if (power & 1) {\\n            result = result * base % P;\\n        }\\n        power >>= 1;\\n        base = (base * base) % P;\\n    }\\n    return result;\\n}\\n\\n\\nint main() {\\n\\tstring s;\\n\\tcin>>s;\\n\\tlong long res = 1;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tlong long x = s[i] - \'0\';\\n\\t\\tres *= fastPower(x, i + 1);\\n\\t\\tres %= P;\\n\\t}\\n\\tcout<<res<<endl;\\n    return 0;\\n}\\n```\\n\\n## [Search - Allocation](https://acm.webturing.com/problem.php?cid=1643&pid=3&langmask=262141&puzzle_mask=0)\\n\\n二分，最大值最小化\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n, m; // 分m段，则要划出m-1条线\\nint money[maxn];\\n\\nint check(int k) { // k是所有段中的最大值，希望其最小\\n\\tint sum = 0, num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\\n\\t\\tif (sum + money[i] > k) {  \\n\\t\\t\\tsum = money[i];\\n\\t\\t\\tnum++; \\n\\t\\t} else {\\n\\t\\t\\tsum += money[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\\n\\t\\treturn 0;\\n\\t}\\n\\treturn 1;\\n}\\n\\nint main() {\\n\\tcin>>n>>m;\\n    // l，r 为左右边界\\n\\tint l = 0, r = 0, ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t    cin>>money[i];\\n\\t\\tl = max(l, money[i]);\\n\\t\\tr += money[i];\\n\\t}\\n\\twhile (l <= r) {\\n\\t\\tint mid = (l + r) >> 1;\\n\\t\\tif (check(mid)) { // 符合，往左走\\n\\t\\t\\tans = mid;\\n\\t\\t\\tr = mid - 1;  \\n\\t\\t} else { // 不符合，往右走\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}\\n\\t}\\n\\tcout<<ans<<endl;\\n\\treturn 0;\\n} \\n```\\n\\n## [火柴](https://acm.webturing.com/problem.php?cid=1643&pid=4&langmask=262141&puzzle_mask=0)\\n\\n贪心\\n\\n每个数字都有对应的火柴数量，根据输入的数可以确定总的火柴数，因为要用这些火柴拼出最大的数，所以应该从9往前尝试，但是尝试的过程中需要判断是否满足条件。2，7分别是最小、最大能拼出数字的火柴数，通过这可以确定剩余火柴数的范围。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 每个数字对应的火彩数量 \\nint hcs[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\\nint t, n, sum, k;\\nchar ch;\\n\\n// i 剩余的数字数，j剩余的火彩数 \\nbool judge(int i, int j)  {\\n\\t// 2 和 7 是数字对应的最小和最大火柴数量 \\n\\treturn i * 2 <= j && j <= i * 7;\\n}\\n\\nint main() {\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tchar x;\\n\\t\\tsum = 0; // 火柴数量 \\n\\t\\tcin>>n;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tcin>>ch;\\n\\t\\t\\tsum += hcs[ch - \'0\'];  // 总的火柴数 \\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t// 重新排列后数要最大，所以要从9开始  \\n\\t\\t\\tk = 9;  \\n\\t\\t\\t// 判断是否是最后一位，如果是最后一位，sum应该和某个数字对应的火彩数相等 \\n\\t\\t\\tif (i == n) {\\n\\t\\t\\t\\twhile (sum != hcs[k]) {\\n\\t\\t\\t\\t\\tk--;\\t\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\tcout<<k;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 剩下的火柴数量应该在最小最大直接 \\n\\t\\t\\t// 如果不满足条件，就继续往下判断 \\n\\t\\t\\twhile (!judge(n - i, sum - hcs[k])) {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\tsum -= hcs[k];\\n\\t\\t\\tcout<<k;\\n\\t\\t}\\n\\t\\tcout<<endl; \\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [异或和(xorsum)](https://acm.webturing.com/problem.php?cid=1643&pid=5&langmask=262141&puzzle_mask=0)\\n\\n[参考链接](https://blog.csdn.net/liupang14159/article/details/115607276)\\n\\n+ 异或是不进位的加法\\n+ 进位加法和不进位加法相等，说明没有发生进位\\n+ 如果[l,r]区间的加法不进位，那么以r为右端点，左端点在[l,r]中的(l,r)都可行\\n+ 新加入一个右端点，那么有可能会出现进位，往右移动左端点，使之不进位。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tlong long n;\\n\\tcin >> n;\\n\\tlong long a[n];\\n\\tfor (long long i = 0; i <n ; i++) \\n\\t\\tcin >> a[i];\\n\\tlong long s = 0, l = 0, ans = 0;\\n\\t// 异或相当于不进位的加法 \\n\\tfor (long long i = 0; i < n; i++) {\\n\\t\\twhile ((s ^ a[i]) != s + a[i]) {\\n\\t\\t\\ts ^= a[l++];\\n\\t\\t}\\n\\t\\tans += i - l + 1;\\n\\t\\ts ^= a[i];\\n\\t}\\n\\tcout<<ans<<endl;\\n\\treturn 0;\\n}\\n\\n// 前缀和的思想\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\ntypedef long long ll;\\nconst int N = 2e5 + 10;\\nll sum[N], X[N];\\nll a[N];\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    for (int i = 1; i <= n; i++) {\\n    \\tscanf(\\\"%lld\\\", &a[i]);\\n\\t}\\n    sum[1] = X[1] = a[1];\\n    // 求出前缀和，以及前几项的异或结果\\n    for (int i = 2; i <= n; i++) {\\n    \\tsum[i] = sum[i - 1] + a[i];\\n\\t\\tX[i] = X[i - 1] ^ a[i];\\n\\t}\\n    ll ans = 0;\\n    int l = 0;\\n    // 遍历依次比较即可\\n    for (int r = 1; r <= n; r++) {\\n        // sum[r] - sum[l] 为 区间(l, r]的和，左开右闭区间\\n        // X[r] ^ X[l]) 为 (l, r]的异或结果\\n        while (sum[r] - sum[l] != (X[r] ^ X[l])) {\\n        \\tl++;\\n\\t\\t}\\n\\t\\tans += r - l;\\n    }\\n    printf(\\\"%lld\\\\n\\\", ans);\\n    return 0;\\n}\\n```\\n\\n## [五个数AB_CDE乘积最小](https://acm.webturing.com/problem.php?cid=1643&pid=6&langmask=262141&puzzle_mask=0)\\n\\n全排列\\n\\n```c++\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint a[5];\\nint n = 5;\\n\\nint main() {\\n    for (int i = 0; i < n; i++) {\\n    \\tcin >> a[i];\\n\\t}\\n    // 注意需要先排序，与next_permutation函数的特性有关\\n    sort(a, a + 5);\\n    int best = INT_MAX;\\n    do {\\n        if (a[0] == 0 || a[3] == 0) {\\n        \\tcontinue;\\n\\t\\t}\\n        int cur = (a[0] * 100 + a[1] * 10 + a[2]) * (a[3] * 10 + a[4]);\\n        best = min(cur, best);\\n        // next_permutation，下一个排列，全排列函数，每次循环对应一个排列，类似与升序\\n  // 若：a[3] = {1, 2, 3}，则该函数的结果为{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}\\n  // 若：a[3] = {3,1,2}，则该函数的结果为{3,1,2},{3,2,1}，这也是前面升序排序的原因\\n  // 与之对应的还有一个prev_permutation函数，前一个排列，对a[3] = {3,1,2}，结果为{3,1,2},{2,3,1},\\n        // {2,1,3},{1,3,2},{1,2,3}，类似于降序\\n    } while (next_permutation(a, a + n));\\n    cout << best << endl;\\n    return 0;\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620460201284.jpg\",\"articleTitle\":\"2021安徽省程序设计网络赛题解\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 15:50:10');
INSERT INTO `tb_operation_log` VALUES (57, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\\n\\n**Description**\\n\\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\\n每天只能卖一个商品.\\n现在你要让超市获得最大的利润.\\n\\n**Input**\\n\\n多组数据.\\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\\n\\n**Output**\\n\\n对于每一组数据, 输出当前条件下超市的最大利润\\n\\n**Sample Input**\\n\\n4\\n50 2\\n10 1\\n20 2\\n30 1\\n\\n7\\n20 1\\n2 1\\n10 3\\n100 2\\n8 2\\n5 20\\n50 10\\n\\n**Sample Output**\\n\\n80\\n185\\n\\n**解题思路**\\n\\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\n\\nusing namespace std;\\n\\ntypedef struct Node {\\n\\tint p;\\n\\tint d;\\n} Product;\\n\\nbool cmp(Product p1, Product p2) {\\n\\treturn p1.p > p2.p;\\n}\\n\\nProduct pro[10001];\\nint visit[10001]; //标记某天是否卖过商品\\n\\nint main() {\\n\\tint n, sum;\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tcin>>pro[i].p>>pro[i].d;\\n\\t\\t// 按利润从高到低排序\\n\\t\\tsort(pro + 1, pro + n + 1, cmp);\\n\\t\\tsum = 0;\\n\\t\\tmemset(visit, 0, sizeof(visit));\\n         // 先售卖高利润的商品\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (visit[pro[i].d] == 0) {\\n\\t\\t\\t\\tvisit[pro[i].d] = 1;\\n\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t} else {\\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\\n\\t\\t\\t\\tfor (int j = pro[i].d - 1; j >= 1; j--) {\\n\\t\\t\\t\\t\\tif (visit[j] == 0) {\\n\\t\\t\\t\\t\\t\\tvisit[j] = 1;\\n\\t\\t\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\\n\\n**Problem Description**\\n\\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\\n\\n**Input**\\n\\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\\n\\n**Output**\\n\\nFor each test case, you should output the smallest total reduced score, one line per test case.\\n\\n**Sample Input**\\n\\n```c++\\n3\\n3\\n3 3 3\\n10 5 1\\n3\\n1 3 1\\n6 2 3\\n7\\n1 4 6 4 2 4 3\\n3 2 1 7 6 5 4\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n3\\n5\\n```\\n\\n**解题思路**\\n\\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint deadline;\\n\\tint score;\\n} work[1005];\\n\\nint T, N;\\nint day[1005]; // 标记当天有没有做过作业 \\n\\nint cmp(Node a, Node b) {\\n\\treturn a.score > b.score; \\n}\\n\\nint main() {\\n\\tcin>>T;\\n\\tfor (int i = 0; i < T; i++) {\\n\\t\\tint res = 0;\\n\\t\\tmemset(day, 0, sizeof(day));\\n\\t\\tcin>>N;\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].deadline;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].score;\\n\\t\\t}\\n\\t\\t// 按分数降序排列 \\n\\t\\tsort(work, work + N, cmp);\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tint d = work[j].deadline;\\n\\t\\t\\t// 若当天没做作业 \\n\\t\\t\\tif (!day[d]) {\\n\\t\\t\\t\\t// 标记做过 \\n\\t\\t\\t\\tday[d] = 1;\\n\\t\\t\\t} else { // 当天做过作业 \\n\\t\\t\\t\\tint flag = 0; // 标记有没有找到 \\n\\t\\t\\t\\t// 往前找到没有做过作业的那天 \\n\\t\\t\\t\\tfor (int k = d - 1; k >= 1; k--) {\\n\\t\\t\\t\\t\\tif (!day[k]) { \\n\\t\\t\\t\\t\\t\\tday[k] = 1;\\n\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t// 没找到，则扣分 \\n\\t\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\t\\tres += work[j].score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\\n\\n**Problem Description**\\n\\n“今年暑假不AC？”\\n“是的。”\\n“那你干什么呢？”\\n“看世界杯呀，笨蛋！”\\n“@#$%^&*%...”\\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\\n\\n**Input**\\n\\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\\n\\n**Output**\\n\\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n12\\n1 3\\n3 4\\n0 7\\n3 8\\n15 19\\n15 20\\n10 15\\n8 18\\n6 12\\n5 10\\n4 14\\n2 9\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n5\\n```\\n\\n**解题思路**\\n\\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint tis;\\n\\tint tie;\\n} p[105];\\n \\nint cmp(Node a, Node b) {\\n\\treturn a.tie < b.tie;\\n}\\n\\nint main() {\\n\\tint n;\\n\\twhile (cin>>n && n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].tis>>p[i].tie;\\n\\t\\t}\\n\\t\\t// 按结束时间升序列 \\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint res = 1;\\n\\t\\tint pTie = p[0].tie; // 记录上个节目结束的时间 \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \\n\\t\\t\\tif (p[i].tis >= pTie) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tpTie = p[i].tie; // 更新 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn  0;\\n}\\n```\\n\\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\\n\\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \\\"carbon\\\"的字串是: \\\"c\\\", \\\"ca\\\", \\\"car\\\", \\\"carb\\\", \\\"carbo\\\", 和 \\\"carbon\\\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \\\"carbohydrate\\\" 通常用\\\"carb\\\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\\n在下面的例子中，\\\"carbohydrate\\\" 能被缩略成\\\"carboh\\\", 但是不能被缩略成\\\"carbo\\\" (或其余更短的前缀) 因为已经有一个单词用\\\"carbo\\\"开始\\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\\\"car\\\"精确匹配单词\\\"car\\\". 因此 \\\"car\\\" 是 \\\"car\\\"的缩略语是没有二义性的 , “car”不会被当成\\\"carriage\\\"或者任何在列表中以\\\"car\\\"开始的单词.\\n\\n**Input**\\n\\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\\n\\n**Output**\\n\\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\\n\\n**Sample Input**\\n\\n```c++\\ncarbohydrate\\ncart\\ncarburetor\\ncaramel\\ncaribou\\ncarbonic\\ncartilage\\ncarbon\\ncarriage\\ncarton\\ncar\\ncarbonate\\n```\\n\\n**Sample Output**\\n\\n```c++\\ncarbohydrate carboh\\ncart cart\\ncarburetor carbu\\ncaramel cara\\ncaribou cari\\ncarbonic carboni\\ncartilage carti\\ncarbon carbon\\ncarriage carr\\ncarton carto\\ncar car\\ncarbonate carbona\\n```\\n\\n**解题**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstring ss[1005];\\nchar str[25];\\n\\nint main() {\\n\\tint len = 0;\\n\\tint i, j, k;\\n\\twhile (cin>>ss[len]) {\\n\\t\\tlen++;\\n\\t}\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint size = ss[i].length();\\n        // 遍历当前字符串的每个字符\\n\\t\\tfor (j = 0; j < size; j++) {\\n\\t\\t\\tmemset(str, 0, sizeof str); \\n            // 前缀\\n\\t\\t\\tfor (k = 0; k <= j; k++) {\\n\\t\\t\\t\\tstr[k] = ss[i][k];\\n\\t\\t\\t}\\n\\t\\t\\tstr[k] = \'\\\\0\';\\n            // 与其他字符串挨个比较\\n\\t\\t\\tfor (k = 0; k < len; k++) {\\n\\t\\t\\t\\tif (k != i) {\\n\\t\\t\\t\\t\\t// strstr(a, b):返回b在a中的起始位置，a是b的字串\\n\\t\\t\\t\\t\\t//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \\n\\t\\t\\t\\t\\tif (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (k == len) {\\n\\t\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i].substr(0, j + 1)<<endl;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (j == size) {\\n\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\\n\\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\\n\\n**Input**\\n\\n第一行t, 表示有t组数据；\\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\\n\\n**Output**\\n\\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\\n\\n**Sample Input**\\n\\n```\\n2\\n9128456 2\\n1444 3\\n```\\n\\n**Sample Output**\\n\\n```\\n12456\\n1\\n```\\n\\n**解题思路**\\n\\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\\n\\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\\n\\n```c++\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n\\tint t, k;\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tstring str; \\n\\t\\tcin>>str>>k;\\n\\t\\tint len = str.size();\\n\\t\\twhile (k--) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\t// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\\n\\t\\t\\t\\tif (str[i] > str[i + 1] || i == len - 1) {\\n\\t\\t\\t\\t\\tstr.erase(i, 1);\\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\n\\t\\t}\\n        // 处理一下高位为0的情况\\n\\t\\tint j = 0;\\n\\t\\tint newLen = str.size();\\n\\t\\twhile(j < newLen && str[j] == \'0\') {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == newLen) {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<str.substr(j, newLen)<<endl; \\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\\n\\n**Problem Description**\\n\\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\\n\\n**Input**\\n\\n多组数据。对于每组数据：\\n第一行为正整数n，表示菜的数量。n<=1000。\\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\\nn=0表示数据结束。\\n\\n**Output**\\n\\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\\n\\n**Sample Input**\\n\\n```c++\\n1\\n50\\n5\\n10\\n1 2 3 2 1 1 2 3 2 1\\n50\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n-45\\n32\\n```\\n\\n**解题思路**\\n\\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n, m;\\nint v[1005];\\nint dp[1005]; \\n\\nint main() {\\n\\twhile (cin>>n && n) {\\n\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>v[i];\\n\\t\\t}\\n\\t\\t// 升序排列 \\n\\t\\tsort(v, v + n);\\n\\t\\tcin>>m;\\n\\t\\t// 余额小于5直接输出 \\n\\t\\tif (m < 5) {\\n\\t\\t\\tcout<<m<<endl;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// 0/1背包，减5后的余额买最多的菜\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = m - 5; j >= v[i]; j--) {\\n\\t\\t\\t\\tdp[j] = max(dp[j], dp[j - v[i]] + v[i]);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tcout<<m-dp[m-5]-v[n-1]<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg\",\"articleTitle\":\"贪心算法刷题记录\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 16:49:02');
INSERT INTO `tb_operation_log` VALUES (58, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\\n\\n**Description**\\n\\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\\n每天只能卖一个商品.\\n现在你要让超市获得最大的利润.\\n\\n**Input**\\n\\n多组数据.\\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\\n\\n**Output**\\n\\n对于每一组数据, 输出当前条件下超市的最大利润\\n\\n**Sample Input**\\n\\n4\\n50 2\\n10 1\\n20 2\\n30 1\\n\\n7\\n20 1\\n2 1\\n10 3\\n100 2\\n8 2\\n5 20\\n50 10\\n\\n**Sample Output**\\n\\n80\\n185\\n\\n**解题思路**\\n\\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\n\\nusing namespace std;\\n\\ntypedef struct Node {\\n\\tint p;\\n\\tint d;\\n} Product;\\n\\nbool cmp(Product p1, Product p2) {\\n\\treturn p1.p > p2.p;\\n}\\n\\nProduct pro[10001];\\nint visit[10001]; //标记某天是否卖过商品\\n\\nint main() {\\n\\tint n, sum;\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tcin>>pro[i].p>>pro[i].d;\\n\\t\\t// 按利润从高到低排序\\n\\t\\tsort(pro + 1, pro + n + 1, cmp);\\n\\t\\tsum = 0;\\n\\t\\tmemset(visit, 0, sizeof(visit));\\n         // 先售卖高利润的商品\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (visit[pro[i].d] == 0) {\\n\\t\\t\\t\\tvisit[pro[i].d] = 1;\\n\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t} else {\\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\\n\\t\\t\\t\\tfor (int j = pro[i].d - 1; j >= 1; j--) {\\n\\t\\t\\t\\t\\tif (visit[j] == 0) {\\n\\t\\t\\t\\t\\t\\tvisit[j] = 1;\\n\\t\\t\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\\n\\n**Problem Description**\\n\\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\\n\\n**Input**\\n\\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\\n\\n**Output**\\n\\nFor each test case, you should output the smallest total reduced score, one line per test case.\\n\\n**Sample Input**\\n\\n```c++\\n3\\n3\\n3 3 3\\n10 5 1\\n3\\n1 3 1\\n6 2 3\\n7\\n1 4 6 4 2 4 3\\n3 2 1 7 6 5 4\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n3\\n5\\n```\\n\\n**解题思路**\\n\\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint deadline;\\n\\tint score;\\n} work[1005];\\n\\nint T, N;\\nint day[1005]; // 标记当天有没有做过作业 \\n\\nint cmp(Node a, Node b) {\\n\\treturn a.score > b.score; \\n}\\n\\nint main() {\\n\\tcin>>T;\\n\\tfor (int i = 0; i < T; i++) {\\n\\t\\tint res = 0;\\n\\t\\tmemset(day, 0, sizeof(day));\\n\\t\\tcin>>N;\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].deadline;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].score;\\n\\t\\t}\\n\\t\\t// 按分数降序排列 \\n\\t\\tsort(work, work + N, cmp);\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tint d = work[j].deadline;\\n\\t\\t\\t// 若当天没做作业 \\n\\t\\t\\tif (!day[d]) {\\n\\t\\t\\t\\t// 标记做过 \\n\\t\\t\\t\\tday[d] = 1;\\n\\t\\t\\t} else { // 当天做过作业 \\n\\t\\t\\t\\tint flag = 0; // 标记有没有找到 \\n\\t\\t\\t\\t// 往前找到没有做过作业的那天 \\n\\t\\t\\t\\tfor (int k = d - 1; k >= 1; k--) {\\n\\t\\t\\t\\t\\tif (!day[k]) { \\n\\t\\t\\t\\t\\t\\tday[k] = 1;\\n\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t// 没找到，则扣分 \\n\\t\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\t\\tres += work[j].score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\\n\\n**Problem Description**\\n\\n“今年暑假不AC？”\\n“是的。”\\n“那你干什么呢？”\\n“看世界杯呀，笨蛋！”\\n“@#$%^&*%...”\\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\\n\\n**Input**\\n\\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\\n\\n**Output**\\n\\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n12\\n1 3\\n3 4\\n0 7\\n3 8\\n15 19\\n15 20\\n10 15\\n8 18\\n6 12\\n5 10\\n4 14\\n2 9\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n5\\n```\\n\\n**解题思路**\\n\\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint tis;\\n\\tint tie;\\n} p[105];\\n \\nint cmp(Node a, Node b) {\\n\\treturn a.tie < b.tie;\\n}\\n\\nint main() {\\n\\tint n;\\n\\twhile (cin>>n && n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].tis>>p[i].tie;\\n\\t\\t}\\n\\t\\t// 按结束时间升序列 \\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint res = 1;\\n\\t\\tint pTie = p[0].tie; // 记录上个节目结束的时间 \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \\n\\t\\t\\tif (p[i].tis >= pTie) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tpTie = p[i].tie; // 更新 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn  0;\\n}\\n```\\n\\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\\n\\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \\\"carbon\\\"的字串是: \\\"c\\\", \\\"ca\\\", \\\"car\\\", \\\"carb\\\", \\\"carbo\\\", 和 \\\"carbon\\\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \\\"carbohydrate\\\" 通常用\\\"carb\\\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\\n在下面的例子中，\\\"carbohydrate\\\" 能被缩略成\\\"carboh\\\", 但是不能被缩略成\\\"carbo\\\" (或其余更短的前缀) 因为已经有一个单词用\\\"carbo\\\"开始\\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\\\"car\\\"精确匹配单词\\\"car\\\". 因此 \\\"car\\\" 是 \\\"car\\\"的缩略语是没有二义性的 , “car”不会被当成\\\"carriage\\\"或者任何在列表中以\\\"car\\\"开始的单词.\\n\\n**Input**\\n\\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\\n\\n**Output**\\n\\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\\n\\n**Sample Input**\\n\\n```c++\\ncarbohydrate\\ncart\\ncarburetor\\ncaramel\\ncaribou\\ncarbonic\\ncartilage\\ncarbon\\ncarriage\\ncarton\\ncar\\ncarbonate\\n```\\n\\n**Sample Output**\\n\\n```c++\\ncarbohydrate carboh\\ncart cart\\ncarburetor carbu\\ncaramel cara\\ncaribou cari\\ncarbonic carboni\\ncartilage carti\\ncarbon carbon\\ncarriage carr\\ncarton carto\\ncar car\\ncarbonate carbona\\n```\\n\\n**解题**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstring ss[1005];\\nchar str[25];\\n\\nint main() {\\n\\tint len = 0;\\n\\tint i, j, k;\\n\\twhile (cin>>ss[len]) {\\n\\t\\tlen++;\\n\\t}\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint size = ss[i].length();\\n        // 遍历当前字符串的每个字符\\n\\t\\tfor (j = 0; j < size; j++) {\\n\\t\\t\\tmemset(str, 0, sizeof str); \\n            // 前缀\\n\\t\\t\\tfor (k = 0; k <= j; k++) {\\n\\t\\t\\t\\tstr[k] = ss[i][k];\\n\\t\\t\\t}\\n\\t\\t\\tstr[k] = \'\\\\0\';\\n            // 与其他字符串挨个比较\\n\\t\\t\\tfor (k = 0; k < len; k++) {\\n\\t\\t\\t\\tif (k != i) {\\n\\t\\t\\t\\t\\t// strstr(a, b):返回b在a中的起始位置，a是b的字串\\n\\t\\t\\t\\t\\t//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \\n\\t\\t\\t\\t\\tif (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (k == len) {\\n\\t\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i].substr(0, j + 1)<<endl;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (j == size) {\\n\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\\n\\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\\n\\n**Input**\\n\\n第一行t, 表示有t组数据；\\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\\n\\n**Output**\\n\\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n9128456 2\\n1444 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\n12456\\n1\\n```\\n\\n**解题思路**\\n\\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\\n\\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\\n\\n```c++\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n\\tint t, k;\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tstring str; \\n\\t\\tcin>>str>>k;\\n\\t\\tint len = str.size();\\n\\t\\twhile (k--) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\t// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\\n\\t\\t\\t\\tif (str[i] > str[i + 1] || i == len - 1) {\\n\\t\\t\\t\\t\\tstr.erase(i, 1);\\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\n\\t\\t}\\n        // 处理一下高位为0的情况\\n\\t\\tint j = 0;\\n\\t\\tint newLen = str.size();\\n\\t\\twhile(j < newLen && str[j] == \'0\') {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == newLen) {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<str.substr(j, newLen)<<endl; \\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\\n\\n**Problem Description**\\n\\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\\n\\n**Input**\\n\\n多组数据。对于每组数据：\\n第一行为正整数n，表示菜的数量。n<=1000。\\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\\nn=0表示数据结束。\\n\\n**Output**\\n\\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\\n\\n**Sample Input**\\n\\n```c++\\n1\\n50\\n5\\n10\\n1 2 3 2 1 1 2 3 2 1\\n50\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n-45\\n32\\n```\\n\\n**解题思路**\\n\\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n, m;\\nint v[1005];\\nint dp[1005]; \\n\\nint main() {\\n\\twhile (cin>>n && n) {\\n\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>v[i];\\n\\t\\t}\\n\\t\\t// 升序排列 \\n\\t\\tsort(v, v + n);\\n\\t\\tcin>>m;\\n\\t\\t// 余额小于5直接输出 \\n\\t\\tif (m < 5) {\\n\\t\\t\\tcout<<m<<endl;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// 0/1背包，减5后的余额买最多的菜\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = m - 5; j >= v[i]; j--) {\\n\\t\\t\\t\\tdp[j] = max(dp[j], dp[j - v[i]] + v[i]);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tcout<<m-dp[m-5]-v[n-1]<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg\",\"articleTitle\":\"贪心算法刷题记录\",\"categoryId\":15,\"id\":47,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.81', '安徽省合肥市 联通', '2021-05-08 16:50:25');
INSERT INTO `tb_operation_log` VALUES (59, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\\n\\n**Description**\\n\\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\\n每天只能卖一个商品.\\n现在你要让超市获得最大的利润.\\n\\n**Input**\\n\\n多组数据.\\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\\n\\n**Output**\\n\\n对于每一组数据, 输出当前条件下超市的最大利润\\n\\n**Sample Input**\\n\\n4\\n50 2\\n10 1\\n20 2\\n30 1\\n\\n7\\n20 1\\n2 1\\n10 3\\n100 2\\n8 2\\n5 20\\n50 10\\n\\n**Sample Output**\\n\\n80\\n185\\n\\n**解题思路**\\n\\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\n\\nusing namespace std;\\n\\ntypedef struct Node {\\n\\tint p;\\n\\tint d;\\n} Product;\\n\\nbool cmp(Product p1, Product p2) {\\n\\treturn p1.p > p2.p;\\n}\\n\\nProduct pro[10001];\\nint visit[10001]; //标记某天是否卖过商品\\n\\nint main() {\\n\\tint n, sum;\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tcin>>pro[i].p>>pro[i].d;\\n\\t\\t// 按利润从高到低排序\\n\\t\\tsort(pro + 1, pro + n + 1, cmp);\\n\\t\\tsum = 0;\\n\\t\\tmemset(visit, 0, sizeof(visit));\\n         // 先售卖高利润的商品\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (visit[pro[i].d] == 0) {\\n\\t\\t\\t\\tvisit[pro[i].d] = 1;\\n\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t} else {\\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\\n\\t\\t\\t\\tfor (int j = pro[i].d - 1; j >= 1; j--) {\\n\\t\\t\\t\\t\\tif (visit[j] == 0) {\\n\\t\\t\\t\\t\\t\\tvisit[j] = 1;\\n\\t\\t\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\\n\\n**Problem Description**\\n\\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\\n\\n**Input**\\n\\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\\n\\n**Output**\\n\\nFor each test case, you should output the smallest total reduced score, one line per test case.\\n\\n**Sample Input**\\n\\n```c++\\n3\\n3\\n3 3 3\\n10 5 1\\n3\\n1 3 1\\n6 2 3\\n7\\n1 4 6 4 2 4 3\\n3 2 1 7 6 5 4\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n3\\n5\\n```\\n\\n**解题思路**\\n\\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint deadline;\\n\\tint score;\\n} work[1005];\\n\\nint T, N;\\nint day[1005]; // 标记当天有没有做过作业 \\n\\nint cmp(Node a, Node b) {\\n\\treturn a.score > b.score; \\n}\\n\\nint main() {\\n\\tcin>>T;\\n\\tfor (int i = 0; i < T; i++) {\\n\\t\\tint res = 0;\\n\\t\\tmemset(day, 0, sizeof(day));\\n\\t\\tcin>>N;\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].deadline;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].score;\\n\\t\\t}\\n\\t\\t// 按分数降序排列 \\n\\t\\tsort(work, work + N, cmp);\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tint d = work[j].deadline;\\n\\t\\t\\t// 若当天没做作业 \\n\\t\\t\\tif (!day[d]) {\\n\\t\\t\\t\\t// 标记做过 \\n\\t\\t\\t\\tday[d] = 1;\\n\\t\\t\\t} else { // 当天做过作业 \\n\\t\\t\\t\\tint flag = 0; // 标记有没有找到 \\n\\t\\t\\t\\t// 往前找到没有做过作业的那天 \\n\\t\\t\\t\\tfor (int k = d - 1; k >= 1; k--) {\\n\\t\\t\\t\\t\\tif (!day[k]) { \\n\\t\\t\\t\\t\\t\\tday[k] = 1;\\n\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t// 没找到，则扣分 \\n\\t\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\t\\tres += work[j].score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\\n\\n**Problem Description**\\n\\n“今年暑假不AC？”\\n“是的。”\\n“那你干什么呢？”\\n“看世界杯呀，笨蛋！”\\n“@#$%^&*%...”\\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\\n\\n**Input**\\n\\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\\n\\n**Output**\\n\\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n12\\n1 3\\n3 4\\n0 7\\n3 8\\n15 19\\n15 20\\n10 15\\n8 18\\n6 12\\n5 10\\n4 14\\n2 9\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n5\\n```\\n\\n**解题思路**\\n\\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint tis;\\n\\tint tie;\\n} p[105];\\n \\nint cmp(Node a, Node b) {\\n\\treturn a.tie < b.tie;\\n}\\n\\nint main() {\\n\\tint n;\\n\\twhile (cin>>n && n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].tis>>p[i].tie;\\n\\t\\t}\\n\\t\\t// 按结束时间升序列 \\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint res = 1;\\n\\t\\tint pTie = p[0].tie; // 记录上个节目结束的时间 \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \\n\\t\\t\\tif (p[i].tis >= pTie) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tpTie = p[i].tie; // 更新 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn  0;\\n}\\n```\\n\\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\\n\\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \\\"carbon\\\"的字串是: \\\"c\\\", \\\"ca\\\", \\\"car\\\", \\\"carb\\\", \\\"carbo\\\", 和 \\\"carbon\\\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \\\"carbohydrate\\\" 通常用\\\"carb\\\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\\n在下面的例子中，\\\"carbohydrate\\\" 能被缩略成\\\"carboh\\\", 但是不能被缩略成\\\"carbo\\\" (或其余更短的前缀) 因为已经有一个单词用\\\"carbo\\\"开始\\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\\\"car\\\"精确匹配单词\\\"car\\\". 因此 \\\"car\\\" 是 \\\"car\\\"的缩略语是没有二义性的 , “car”不会被当成\\\"carriage\\\"或者任何在列表中以\\\"car\\\"开始的单词.\\n\\n**Input**\\n\\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\\n\\n**Output**\\n\\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\\n\\n**Sample Input**\\n\\n```c++\\ncarbohydrate\\ncart\\ncarburetor\\ncaramel\\ncaribou\\ncarbonic\\ncartilage\\ncarbon\\ncarriage\\ncarton\\ncar\\ncarbonate\\n```\\n\\n**Sample Output**\\n\\n```c++\\ncarbohydrate carboh\\ncart cart\\ncarburetor carbu\\ncaramel cara\\ncaribou cari\\ncarbonic carboni\\ncartilage carti\\ncarbon carbon\\ncarriage carr\\ncarton carto\\ncar car\\ncarbonate carbona\\n```\\n\\n**解题**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstring ss[1005];\\nchar str[25];\\n\\nint main() {\\n\\tint len = 0;\\n\\tint i, j, k;\\n\\twhile (cin>>ss[len]) {\\n\\t\\tlen++;\\n\\t}\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint size = ss[i].length();\\n        // 遍历当前字符串的每个字符\\n\\t\\tfor (j = 0; j < size; j++) {\\n\\t\\t\\tmemset(str, 0, sizeof str); \\n            // 前缀\\n\\t\\t\\tfor (k = 0; k <= j; k++) {\\n\\t\\t\\t\\tstr[k] = ss[i][k];\\n\\t\\t\\t}\\n\\t\\t\\tstr[k] = \'\\\\0\';\\n            // 与其他字符串挨个比较\\n\\t\\t\\tfor (k = 0; k < len; k++) {\\n\\t\\t\\t\\tif (k != i) {\\n\\t\\t\\t\\t\\t// strstr(a, b):返回b在a中的起始位置，a是b的字串\\n\\t\\t\\t\\t\\t//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \\n\\t\\t\\t\\t\\tif (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (k == len) {\\n\\t\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i].substr(0, j + 1)<<endl;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (j == size) {\\n\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\\n\\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\\n\\n**Input**\\n\\n第一行t, 表示有t组数据；\\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\\n\\n**Output**\\n\\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n9128456 2\\n1444 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\n12456\\n1\\n```\\n\\n**解题思路**\\n\\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\\n\\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\\n\\n```c++\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n\\tint t, k;\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tstring str; \\n\\t\\tcin>>str>>k;\\n\\t\\tint len = str.size();\\n\\t\\twhile (k--) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\t// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\\n\\t\\t\\t\\tif (str[i] > str[i + 1] || i == len - 1) {\\n\\t\\t\\t\\t\\tstr.erase(i, 1);\\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\n\\t\\t}\\n        // 处理一下高位为0的情况\\n\\t\\tint j = 0;\\n\\t\\tint newLen = str.size();\\n\\t\\twhile(j < newLen && str[j] == \'0\') {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == newLen) {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<str.substr(j, newLen)<<endl; \\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\\n\\n**Problem Description**\\n\\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\\n\\n**Input**\\n\\n多组数据。对于每组数据：\\n第一行为正整数n，表示菜的数量。n<=1000。\\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\\nn=0表示数据结束。\\n\\n**Output**\\n\\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\\n\\n**Sample Input**\\n\\n```c++\\n1\\n50\\n5\\n10\\n1 2 3 2 1 1 2 3 2 1\\n50\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n-45\\n32\\n```\\n\\n**解题思路**\\n\\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n, m;\\nint v[1005];\\nint dp[1005]; \\n\\nint main() {\\n\\twhile (cin>>n && n) {\\n\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>v[i];\\n\\t\\t}\\n\\t\\t// 升序排列 \\n\\t\\tsort(v, v + n);\\n\\t\\tcin>>m;\\n\\t\\t// 余额小于5直接输出 \\n\\t\\tif (m < 5) {\\n\\t\\t\\tcout<<m<<endl;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// 0/1背包，减5后的余额买最多的菜\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = m - 5; j >= v[i]; j--) {\\n\\t\\t\\t\\tdp[j] = max(dp[j], dp[j - v[i]] + v[i]);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tcout<<m-dp[m-5]-v[n-1]<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [Task（HDU-4864）](http://acm.hdu.edu.cn/showproblem.php?pid=4864)\\n\\n**Problem Description**\\n\\nToday the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500*xi+2*yi) dollars.\\nThe company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.\\n\\n**Input**\\n\\nThe input contains several test cases.\\nThe first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 < =N <= 100000,1<=M<=100000).\\nThe following N lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the maximum time the machine can work.yi is the level of the machine.\\nThe following M lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the time we need to complete the task.yi is the level of the task.\\n\\n**Output**\\n\\nFor each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.\\n\\n**Sample Input**\\n\\n```c++\\n1 2\\n100 3\\n100 2\\n100 1\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 50004\\n```\\n\\n**题目大意**：有Ｎ个机器，机器有最大执行时间和等级；有Ｍ个任务，每个任务有执行时间和等级，只有当机器的执行时间和等级均大于等于任务的执行时间和等级时，该台机器才能执行该任务，每执行一个任务能获得500*xi+2*yi的酬劳（xi是任务时长，yi是任务等级），每台机器每天只能使用一次，问一天最多能获得多大的酬劳。(机器的数据范围：0<xi<1440，0=<yi<=100)，(任务的数据范围：0<xi<1440，0=<yi<=100)。\\n\\n**解题思路**：根据酬劳的计算公式和xi、yi的范围可知，对酬劳大小其决定作用的是执行时长xi，所以对所有机器和任务按执行时长进行降序排列，若时长相等，按等级降序排列。贪心暴力。核心点：**后面的任务必然能够被先前加进来的机器执行完毕，因为任务是按时间降序排列的**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn]; // 机器\\nP w[maxn]; // 任务\\nint level[105]; // 满足任务时长的对应等级的机器数\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(level, 0, sizeof(level));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\t// 后面的加进来的任务必然能够被先前加进来的机所完毕，因为任务是按时间降序排列的\\n\\t\\tfor (int i = 0, j = 0; i < M; i++) {\\n\\t\\t\\twhile (j < N && m[j].x >= w[i].x) {\\n\\t\\t\\t\\tlevel[m[j].y]++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k = w[i].y; k <= 100; k++) {\\n\\t\\t\\t\\tif (level[k]) {\\n\\t\\t\\t\\t\\tlevel[k]--;\\n\\t\\t\\t\\t\\tsum += w[i].x * 500 + w[i].y * 2;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n\\n---------------------------------------------------------------------------\\n// 这种写法会超时\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn];\\nP w[maxn];\\nint vis[maxn];\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tfor (int j = N - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (vis[j]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (m[j].x >= w[i].x && m[j].y >= w[i].y) {\\n\\t\\t\\t\\t\\tvis[j] = 1;\\n\\t\\t\\t\\t\\tsum += 500 * w[i].x + 2 * w[i].y;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg\",\"articleTitle\":\"贪心算法刷题记录\",\"categoryId\":15,\"id\":47,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:16:42');
INSERT INTO `tb_operation_log` VALUES (60, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 线性表的顺序存储\\n\\n### 1、顺序表的原理\\n\\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\\n\\n### 2、顺序表的特点\\n\\n1、空间是连续的；\\n\\n2、支持随机访问；\\n\\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\\n\\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\\n\\n### 3、基本存储结构\\n\\n```c++\\n#define MAXSIZE 100 // 线性表的最大长度 \\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n```\\n\\n### 4、基本功能\\n\\n- 顺序表的初始化功能       **void InitList(SeqList *L)**\\t\\n- 顺序表的判空     **int ListEmpty(SeqList L)**\\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList *L, int i, int e)**\\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList *L, int i, int *e)**\\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \\n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList *Lc)**\\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList *Lc)**\\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \\n\\n#### 1、顺序表的初始化\\n\\n将顺序表所有元素置为0，顺序表的实际长度置为0。\\n\\n```c++\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n```\\n\\n#### 2、顺序表的判空\\n\\n判断顺序表的实际长度是否等于0即可\\n\\n```c++\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n```\\n\\n#### 3、获取指定位置的元素\\n\\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\\n\\n```c++\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n```\\n\\n#### 4、在指定位置插入元素\\n\\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\\n+ 若没满足条件，即插入失败，返回0；\\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\\n\\n```c++\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n```\\n\\n#### 5、删除指定位置的元素\\n\\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\\n\\n```c++\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n```\\n\\n#### 6、返回元素的位置\\n\\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\\n\\n```c++\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n#### 7、合并顺序表\\n\\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\\n\\n```c++\\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\\n             return;\\n        }\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i]++;\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n```\\n\\n#### 8、两个顺序表的union操作（取并集，即要去重）\\n\\n```c++\\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### 9、遍历顺序表所有元素\\n\\n```c++\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n```\\n\\n### 5、完整代码和测试\\n\\n```c++\\n#include<stdio.h>\\n#define MAXSIZE 100 // 线性表的最大长度 \\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n\\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\\n// Lc中的数据元素仍然按值非递减有序排列\\n\\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i++];\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n// 并集 \\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main() {\\n    int i, n;\\n    SeqList L;\\n\\n    InitList(&L);\\n\\n    for (i = 0; i < 10; i++) {\\n        L.data[i] = i;\\n        L.length++;\\n    }\\n    printf(\\\"遍历默认创建好的顺序表：\\\\n\\\");\\n    PrintList(L);\\n\\n\\tprintf(\\\"在顺序表第4个位置插入元素11后：\\\\n\\\");\\n    InsertList(&L, 4, 11);\\n    PrintList(L);\\n\\n    DeleteList(&L, 5, &n);\\n    printf(\\\"删除顺序表中第5个元素，删除的元素为：%d\\\\n\\\", n);\\n    printf(\\\"删除过后的顺序表：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"顺序表中第6个元素：%d\\\\n\\\", GetElement(L, 6));\\n    \\n    printf(\\\"8在顺序表的位置：%d\\\\n\\\", LocateElement(L, 8));\\n    \\n    SeqList La, Lb, Lc;\\n\\n    InitList(&La);\\n    InitList(&Lb);\\n    InitList(&Lc);\\n    int j = 1;\\n    for (i = 1; i < 10; i += 2) {\\n    \\tInsertList(&La, j++, i);\\n\\t}\\n\\tprintf(\\\"顺序表La:\\\\n\\\");\\n\\tPrintList(La);\\n\\tj = 1;\\n\\tfor (i = 0; i < 10; i += 2) {\\n\\t\\tInsertList(&Lb, j++, i);\\n\\t}\\n\\tInsertList(&Lb, j++, 9);\\n\\tprintf(\\\"顺序表Lb:\\\\n\\\");\\n\\tPrintList(Lb);\\n\\t\\n\\tMergeList(La, Lb, &Lc);\\n\\tprintf(\\\"合并之后的顺序表Lc:\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n\\tInitList(&Lc);\\n\\tUnionList(La, Lb, &Lc);\\n\\tprintf(\\\"顺序表La和顺序表Lb的并集：\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200809152139.png)\\n\\n### 6、另附指针实现的动态顺序表\\n\\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType *elem**，利用`malloc`进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用`realloc`函数重新分配内存大小。\\n\\n```c++\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\\ntypedef int ElemType;\\n\\ntypedef struct Node {\\n    ElemType *elem;  // 指向顺序表的首地址\\n    int length; // 顺序表的实际长度\\n    int listSize; // 顺序表的最大长度\\n} SqList;\\n\\n// 初始化\\nvoid InitList(SqList *L) {\\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\\n    if (!L->elem) {\\n        exit(0);\\n    }\\n    L->length = 0;\\n    L->listSize = LIST_INIT_SIZE;\\n}\\n\\n// 插入元素\\nvoid InsertList(SqList *L, int i, ElemType e) {\\n    ElemType *q, *p;\\n    if (i < 1 || i > L->length + 1) {\\n        return;\\n    }\\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\\n        if (!L->elem) {\\n            exit(0);\\n        }\\n        L->listSize += LISTINCREMENT;\\n    }\\n\\n    q = L->elem + i - 1;\\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\\n        *p = *(p - 1);\\n    }\\n    *q = e;\\n    L->length++;\\n}\\n\\n// 删除元素\\nvoid ListDelete(SqList *L, int i, ElemType *e) {\\n    ElemType *p, *q;\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    p = L->elem + i - 1;\\n    *e = *p;\\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\\n        *q = *(q + 1);\\n    }\\n    L->length--;\\n}\\n\\n// 获取元素\\nvoid GetElement(SqList *L, int i, int *e) {\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    *e = *(L->elem + i - 1);\\n}\\n\\n// 遍历元素\\nvoid ListTraverse(SqList *L) {\\n    ElemType *p;\\n    if (L->length == 0) {\\n        printf(\\\"List NULL!\\\\n\\\");\\n        return;\\n    }\\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 销毁顺序表\\nvoid DestroyList(SqList *L) {\\n    free(L->elem);\\n    L->elem = NULL;\\n    L->length = 0;\\n    L->listSize = 0;\\n}\\n\\n// 合并两个顺序表\\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\\n\\n    pa = La->elem;\\n    pb = Lb->elem;\\n    Lc->listSize = Lc->length = La->length + Lb->length;\\n\\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\\n    if (!pc) {\\n        exit(0);\\n    }\\n    pa_last = La->elem + La->length - 1;\\n    pb_last = Lb->elem + Lb->length - 1;\\n\\n    while (pa <= pa_last && pb <= pb_last) {\\n        if (*pa <= *pb) {\\n            *pc++ = *pa++;\\n        } else {\\n            *pc++ = *pb++;\\n        }\\n    }\\n    while (pa <= pa_last) {\\n        *pc++ = *pa++;\\n    }\\n    while (pb <= pb_last) {\\n        *pc++ = *pb++;\\n    }\\n}\\n\\nint main() {\\n    SqList la, lb, lc;\\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\\n    ElemType e;\\n    int i;\\n\\n    InitList(La);\\n    InitList(Lb);\\n    InitList(Lc);\\n\\n    ElemType *pa = La->elem, *pb = Lb->elem;\\n\\n    for (i = 0; i < 10; i = i + 2) {\\n        *pa++ = i;\\n        La->length++;\\n    }\\n    printf(\\\"The List a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    for (i = 1; i < 10; i = i + 2) {\\n        *pb++ = i;\\n        Lb->length++;\\n    }\\n    printf(\\\"The List b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    InsertList(La, 3, 100);\\n    printf(\\\"After inserting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n    ListDelete(La, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    InsertList(Lb, 3, 99);\\n    printf(\\\"After inserting, the new list b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n    ListDelete(Lb, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"The list c is:\\\\n\\\");\\n    ListTraverse(Lc);\\n\\n    DestroyList(La);\\n    DestroyList(Lb);\\n\\n    ListTraverse(La);\\n    ListTraverse(Lb);\\n\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200808232536.png)\\n\\n### 7、注意\\n\\n本篇代码中函数参数中，顺序表的传参有两种写法：\\n\\n**SeqList L**（结构体变量），**SeqList *L** （结构体指针）\\n\\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList *L**，则使用**L->length**\",\"articleCover\":\"\",\"articleTitle\":\"线性表的顺序存储\",\"categoryId\":16,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:28:30');
INSERT INTO `tb_operation_log` VALUES (61, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"顺序表\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:28:47');
INSERT INTO `tb_operation_log` VALUES (62, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"链表\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:28:52');
INSERT INTO `tb_operation_log` VALUES (63, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"顺序栈\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:28:57');
INSERT INTO `tb_operation_log` VALUES (64, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 线性表的顺序存储\\n\\n### 1、顺序表的原理\\n\\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\\n\\n### 2、顺序表的特点\\n\\n1、空间是连续的；\\n\\n2、支持随机访问；\\n\\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\\n\\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\\n\\n### 3、基本存储结构\\n\\n```c++\\n#define MAXSIZE 100 // 线性表的最大长度 \\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n```\\n\\n### 4、基本功能\\n\\n- 顺序表的初始化功能       **void InitList(SeqList *L)**\\t\\n- 顺序表的判空     **int ListEmpty(SeqList L)**\\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList *L, int i, int e)**\\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList *L, int i, int *e)**\\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \\n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList *Lc)**\\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList *Lc)**\\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \\n\\n#### 1、顺序表的初始化\\n\\n将顺序表所有元素置为0，顺序表的实际长度置为0。\\n\\n```c++\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n```\\n\\n#### 2、顺序表的判空\\n\\n判断顺序表的实际长度是否等于0即可\\n\\n```c++\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n```\\n\\n#### 3、获取指定位置的元素\\n\\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\\n\\n```c++\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n```\\n\\n#### 4、在指定位置插入元素\\n\\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\\n+ 若没满足条件，即插入失败，返回0；\\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\\n\\n```c++\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n```\\n\\n#### 5、删除指定位置的元素\\n\\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\\n\\n```c++\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n```\\n\\n#### 6、返回元素的位置\\n\\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\\n\\n```c++\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n#### 7、合并顺序表\\n\\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\\n\\n```c++\\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\\n             return;\\n        }\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i]++;\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n```\\n\\n#### 8、两个顺序表的union操作（取并集，即要去重）\\n\\n```c++\\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### 9、遍历顺序表所有元素\\n\\n```c++\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n```\\n\\n### 5、完整代码和测试\\n\\n```c++\\n#include<stdio.h>\\n#define MAXSIZE 100 // 线性表的最大长度 \\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n\\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\\n// Lc中的数据元素仍然按值非递减有序排列\\n\\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i++];\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n// 并集 \\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main() {\\n    int i, n;\\n    SeqList L;\\n\\n    InitList(&L);\\n\\n    for (i = 0; i < 10; i++) {\\n        L.data[i] = i;\\n        L.length++;\\n    }\\n    printf(\\\"遍历默认创建好的顺序表：\\\\n\\\");\\n    PrintList(L);\\n\\n\\tprintf(\\\"在顺序表第4个位置插入元素11后：\\\\n\\\");\\n    InsertList(&L, 4, 11);\\n    PrintList(L);\\n\\n    DeleteList(&L, 5, &n);\\n    printf(\\\"删除顺序表中第5个元素，删除的元素为：%d\\\\n\\\", n);\\n    printf(\\\"删除过后的顺序表：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"顺序表中第6个元素：%d\\\\n\\\", GetElement(L, 6));\\n    \\n    printf(\\\"8在顺序表的位置：%d\\\\n\\\", LocateElement(L, 8));\\n    \\n    SeqList La, Lb, Lc;\\n\\n    InitList(&La);\\n    InitList(&Lb);\\n    InitList(&Lc);\\n    int j = 1;\\n    for (i = 1; i < 10; i += 2) {\\n    \\tInsertList(&La, j++, i);\\n\\t}\\n\\tprintf(\\\"顺序表La:\\\\n\\\");\\n\\tPrintList(La);\\n\\tj = 1;\\n\\tfor (i = 0; i < 10; i += 2) {\\n\\t\\tInsertList(&Lb, j++, i);\\n\\t}\\n\\tInsertList(&Lb, j++, 9);\\n\\tprintf(\\\"顺序表Lb:\\\\n\\\");\\n\\tPrintList(Lb);\\n\\t\\n\\tMergeList(La, Lb, &Lc);\\n\\tprintf(\\\"合并之后的顺序表Lc:\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n\\tInitList(&Lc);\\n\\tUnionList(La, Lb, &Lc);\\n\\tprintf(\\\"顺序表La和顺序表Lb的并集：\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200809152139.png)\\n\\n### 6、另附指针实现的动态顺序表\\n\\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType *elem**，利用`malloc`进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用`realloc`函数重新分配内存大小。\\n\\n```c++\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\\ntypedef int ElemType;\\n\\ntypedef struct Node {\\n    ElemType *elem;  // 指向顺序表的首地址\\n    int length; // 顺序表的实际长度\\n    int listSize; // 顺序表的最大长度\\n} SqList;\\n\\n// 初始化\\nvoid InitList(SqList *L) {\\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\\n    if (!L->elem) {\\n        exit(0);\\n    }\\n    L->length = 0;\\n    L->listSize = LIST_INIT_SIZE;\\n}\\n\\n// 插入元素\\nvoid InsertList(SqList *L, int i, ElemType e) {\\n    ElemType *q, *p;\\n    if (i < 1 || i > L->length + 1) {\\n        return;\\n    }\\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\\n        if (!L->elem) {\\n            exit(0);\\n        }\\n        L->listSize += LISTINCREMENT;\\n    }\\n\\n    q = L->elem + i - 1;\\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\\n        *p = *(p - 1);\\n    }\\n    *q = e;\\n    L->length++;\\n}\\n\\n// 删除元素\\nvoid ListDelete(SqList *L, int i, ElemType *e) {\\n    ElemType *p, *q;\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    p = L->elem + i - 1;\\n    *e = *p;\\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\\n        *q = *(q + 1);\\n    }\\n    L->length--;\\n}\\n\\n// 获取元素\\nvoid GetElement(SqList *L, int i, int *e) {\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    *e = *(L->elem + i - 1);\\n}\\n\\n// 遍历元素\\nvoid ListTraverse(SqList *L) {\\n    ElemType *p;\\n    if (L->length == 0) {\\n        printf(\\\"List NULL!\\\\n\\\");\\n        return;\\n    }\\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 销毁顺序表\\nvoid DestroyList(SqList *L) {\\n    free(L->elem);\\n    L->elem = NULL;\\n    L->length = 0;\\n    L->listSize = 0;\\n}\\n\\n// 合并两个顺序表\\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\\n\\n    pa = La->elem;\\n    pb = Lb->elem;\\n    Lc->listSize = Lc->length = La->length + Lb->length;\\n\\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\\n    if (!pc) {\\n        exit(0);\\n    }\\n    pa_last = La->elem + La->length - 1;\\n    pb_last = Lb->elem + Lb->length - 1;\\n\\n    while (pa <= pa_last && pb <= pb_last) {\\n        if (*pa <= *pb) {\\n            *pc++ = *pa++;\\n        } else {\\n            *pc++ = *pb++;\\n        }\\n    }\\n    while (pa <= pa_last) {\\n        *pc++ = *pa++;\\n    }\\n    while (pb <= pb_last) {\\n        *pc++ = *pb++;\\n    }\\n}\\n\\nint main() {\\n    SqList la, lb, lc;\\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\\n    ElemType e;\\n    int i;\\n\\n    InitList(La);\\n    InitList(Lb);\\n    InitList(Lc);\\n\\n    ElemType *pa = La->elem, *pb = Lb->elem;\\n\\n    for (i = 0; i < 10; i = i + 2) {\\n        *pa++ = i;\\n        La->length++;\\n    }\\n    printf(\\\"The List a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    for (i = 1; i < 10; i = i + 2) {\\n        *pb++ = i;\\n        Lb->length++;\\n    }\\n    printf(\\\"The List b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    InsertList(La, 3, 100);\\n    printf(\\\"After inserting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n    ListDelete(La, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    InsertList(Lb, 3, 99);\\n    printf(\\\"After inserting, the new list b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n    ListDelete(Lb, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"The list c is:\\\\n\\\");\\n    ListTraverse(Lc);\\n\\n    DestroyList(La);\\n    DestroyList(Lb);\\n\\n    ListTraverse(La);\\n    ListTraverse(Lb);\\n\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200808232536.png)\\n\\n### 7、注意\\n\\n本篇代码中函数参数中，顺序表的传参有两种写法：\\n\\n**SeqList L**（结构体变量），**SeqList *L** （结构体指针）\\n\\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList *L**，则使用**L->length**\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657093616.jpg\",\"articleTitle\":\"线性表的顺序存储\",\"categoryId\":16,\"id\":48,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[27]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:31:43');
INSERT INTO `tb_operation_log` VALUES (65, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 线性表的顺序存储\\n\\n### 1、顺序表的原理\\n\\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\\n\\n### 2、顺序表的特点\\n\\n1、空间是连续的；\\n\\n2、支持随机访问；\\n\\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\\n\\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\\n\\n### 3、基本存储结构\\n\\n```c++\\n#define MAXSIZE 100 // 线性表的最大长度 \\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n```\\n\\n### 4、基本功能\\n\\n- 顺序表的初始化功能       **void InitList(SeqList *L)**\\t\\n- 顺序表的判空     **int ListEmpty(SeqList L)**\\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList *L, int i, int e)**\\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList *L, int i, int *e)**\\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \\n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList *Lc)**\\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList *Lc)**\\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \\n\\n#### 1、顺序表的初始化\\n\\n将顺序表所有元素置为0，顺序表的实际长度置为0。\\n\\n```c++\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n```\\n\\n#### 2、顺序表的判空\\n\\n判断顺序表的实际长度是否等于0即可\\n\\n```c++\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n```\\n\\n#### 3、获取指定位置的元素\\n\\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\\n\\n```c++\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n```\\n\\n#### 4、在指定位置插入元素\\n\\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\\n+ 若没满足条件，即插入失败，返回0；\\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\\n\\n```c++\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n```\\n\\n#### 5、删除指定位置的元素\\n\\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\\n\\n```c++\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n```\\n\\n#### 6、返回元素的位置\\n\\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\\n\\n```c++\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n#### 7、合并顺序表\\n\\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\\n\\n```c++\\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\\n             return;\\n        }\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i]++;\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n```\\n\\n#### 8、两个顺序表的union操作（取并集，即要去重）\\n\\n```c++\\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### 9、遍历顺序表所有元素\\n\\n```c++\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n```\\n\\n### 5、完整代码和测试\\n\\n```c++\\n#include<stdio.h>\\n#define MAXSIZE 100 // 线性表的最大长度 \\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n\\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\\n// Lc中的数据元素仍然按值非递减有序排列\\n\\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i++];\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n// 并集 \\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main() {\\n    int i, n;\\n    SeqList L;\\n\\n    InitList(&L);\\n\\n    for (i = 0; i < 10; i++) {\\n        L.data[i] = i;\\n        L.length++;\\n    }\\n    printf(\\\"遍历默认创建好的顺序表：\\\\n\\\");\\n    PrintList(L);\\n\\n\\tprintf(\\\"在顺序表第4个位置插入元素11后：\\\\n\\\");\\n    InsertList(&L, 4, 11);\\n    PrintList(L);\\n\\n    DeleteList(&L, 5, &n);\\n    printf(\\\"删除顺序表中第5个元素，删除的元素为：%d\\\\n\\\", n);\\n    printf(\\\"删除过后的顺序表：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"顺序表中第6个元素：%d\\\\n\\\", GetElement(L, 6));\\n    \\n    printf(\\\"8在顺序表的位置：%d\\\\n\\\", LocateElement(L, 8));\\n    \\n    SeqList La, Lb, Lc;\\n\\n    InitList(&La);\\n    InitList(&Lb);\\n    InitList(&Lc);\\n    int j = 1;\\n    for (i = 1; i < 10; i += 2) {\\n    \\tInsertList(&La, j++, i);\\n\\t}\\n\\tprintf(\\\"顺序表La:\\\\n\\\");\\n\\tPrintList(La);\\n\\tj = 1;\\n\\tfor (i = 0; i < 10; i += 2) {\\n\\t\\tInsertList(&Lb, j++, i);\\n\\t}\\n\\tInsertList(&Lb, j++, 9);\\n\\tprintf(\\\"顺序表Lb:\\\\n\\\");\\n\\tPrintList(Lb);\\n\\t\\n\\tMergeList(La, Lb, &Lc);\\n\\tprintf(\\\"合并之后的顺序表Lc:\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n\\tInitList(&Lc);\\n\\tUnionList(La, Lb, &Lc);\\n\\tprintf(\\\"顺序表La和顺序表Lb的并集：\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200809152139.png)\\n\\n### 6、另附指针实现的动态顺序表\\n\\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType * elem**，利用**malloc**进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用**realloc**函数重新分配内存大小。\\n\\n```c++\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\\ntypedef int ElemType;\\n\\ntypedef struct Node {\\n    ElemType *elem;  // 指向顺序表的首地址\\n    int length; // 顺序表的实际长度\\n    int listSize; // 顺序表的最大长度\\n} SqList;\\n\\n// 初始化\\nvoid InitList(SqList *L) {\\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\\n    if (!L->elem) {\\n        exit(0);\\n    }\\n    L->length = 0;\\n    L->listSize = LIST_INIT_SIZE;\\n}\\n\\n// 插入元素\\nvoid InsertList(SqList *L, int i, ElemType e) {\\n    ElemType *q, *p;\\n    if (i < 1 || i > L->length + 1) {\\n        return;\\n    }\\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\\n        if (!L->elem) {\\n            exit(0);\\n        }\\n        L->listSize += LISTINCREMENT;\\n    }\\n\\n    q = L->elem + i - 1;\\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\\n        *p = *(p - 1);\\n    }\\n    *q = e;\\n    L->length++;\\n}\\n\\n// 删除元素\\nvoid ListDelete(SqList *L, int i, ElemType *e) {\\n    ElemType *p, *q;\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    p = L->elem + i - 1;\\n    *e = *p;\\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\\n        *q = *(q + 1);\\n    }\\n    L->length--;\\n}\\n\\n// 获取元素\\nvoid GetElement(SqList *L, int i, int *e) {\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    *e = *(L->elem + i - 1);\\n}\\n\\n// 遍历元素\\nvoid ListTraverse(SqList *L) {\\n    ElemType *p;\\n    if (L->length == 0) {\\n        printf(\\\"List NULL!\\\\n\\\");\\n        return;\\n    }\\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 销毁顺序表\\nvoid DestroyList(SqList *L) {\\n    free(L->elem);\\n    L->elem = NULL;\\n    L->length = 0;\\n    L->listSize = 0;\\n}\\n\\n// 合并两个顺序表\\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\\n\\n    pa = La->elem;\\n    pb = Lb->elem;\\n    Lc->listSize = Lc->length = La->length + Lb->length;\\n\\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\\n    if (!pc) {\\n        exit(0);\\n    }\\n    pa_last = La->elem + La->length - 1;\\n    pb_last = Lb->elem + Lb->length - 1;\\n\\n    while (pa <= pa_last && pb <= pb_last) {\\n        if (*pa <= *pb) {\\n            *pc++ = *pa++;\\n        } else {\\n            *pc++ = *pb++;\\n        }\\n    }\\n    while (pa <= pa_last) {\\n        *pc++ = *pa++;\\n    }\\n    while (pb <= pb_last) {\\n        *pc++ = *pb++;\\n    }\\n}\\n\\nint main() {\\n    SqList la, lb, lc;\\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\\n    ElemType e;\\n    int i;\\n\\n    InitList(La);\\n    InitList(Lb);\\n    InitList(Lc);\\n\\n    ElemType *pa = La->elem, *pb = Lb->elem;\\n\\n    for (i = 0; i < 10; i = i + 2) {\\n        *pa++ = i;\\n        La->length++;\\n    }\\n    printf(\\\"The List a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    for (i = 1; i < 10; i = i + 2) {\\n        *pb++ = i;\\n        Lb->length++;\\n    }\\n    printf(\\\"The List b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    InsertList(La, 3, 100);\\n    printf(\\\"After inserting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n    ListDelete(La, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    InsertList(Lb, 3, 99);\\n    printf(\\\"After inserting, the new list b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n    ListDelete(Lb, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"The list c is:\\\\n\\\");\\n    ListTraverse(Lc);\\n\\n    DestroyList(La);\\n    DestroyList(Lb);\\n\\n    ListTraverse(La);\\n    ListTraverse(Lb);\\n\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200808232536.png)\\n\\n### 7、注意\\n\\n本篇代码中函数参数中，顺序表的传参有两种写法：\\n\\n**SeqList L**（结构体变量），**SeqList * L** （结构体指针）\\n\\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList * L**，则使用**L->length**\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657093616.jpg\",\"articleTitle\":\"线性表的顺序存储\",\"categoryId\":16,\"id\":48,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[27]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:35:19');
INSERT INTO `tb_operation_log` VALUES (66, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 线性表的顺序存储\\n\\n### 1、顺序表的原理\\n\\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\\n\\n### 2、顺序表的特点\\n\\n1、空间是连续的；\\n\\n2、支持随机访问；\\n\\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\\n\\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\\n\\n### 3、基本存储结构\\n\\n```c++\\n#define MAXSIZE 100 // 线性表的最大长度 \\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n```\\n\\n### 4、基本功能\\n\\n- 顺序表的初始化功能       **void InitList(SeqList * L)**\\t\\n- 顺序表的判空     **int ListEmpty(SeqList L)**\\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList * L, int i, int e)**\\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList * L, int i, int * e)**\\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \\n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList * Lc)**\\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList * Lc)**\\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \\n\\n#### 1、顺序表的初始化\\n\\n将顺序表所有元素置为0，顺序表的实际长度置为0。\\n\\n```c++\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n```\\n\\n#### 2、顺序表的判空\\n\\n判断顺序表的实际长度是否等于0即可\\n\\n```c++\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n```\\n\\n#### 3、获取指定位置的元素\\n\\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\\n\\n```c++\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n```\\n\\n#### 4、在指定位置插入元素\\n\\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\\n+ 若没满足条件，即插入失败，返回0；\\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\\n\\n```c++\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n```\\n\\n#### 5、删除指定位置的元素\\n\\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\\n\\n```c++\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n```\\n\\n#### 6、返回元素的位置\\n\\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\\n\\n```c++\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n#### 7、合并顺序表\\n\\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\\n\\n```c++\\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\\n             return;\\n        }\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i]++;\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n```\\n\\n#### 8、两个顺序表的union操作（取并集，即要去重）\\n\\n```c++\\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### 9、遍历顺序表所有元素\\n\\n```c++\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n```\\n\\n### 5、完整代码和测试\\n\\n```c++\\n#include<stdio.h>\\n#define MAXSIZE 100 // 线性表的最大长度 \\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n\\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\\n// Lc中的数据元素仍然按值非递减有序排列\\n\\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i++];\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n// 并集 \\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main() {\\n    int i, n;\\n    SeqList L;\\n\\n    InitList(&L);\\n\\n    for (i = 0; i < 10; i++) {\\n        L.data[i] = i;\\n        L.length++;\\n    }\\n    printf(\\\"遍历默认创建好的顺序表：\\\\n\\\");\\n    PrintList(L);\\n\\n\\tprintf(\\\"在顺序表第4个位置插入元素11后：\\\\n\\\");\\n    InsertList(&L, 4, 11);\\n    PrintList(L);\\n\\n    DeleteList(&L, 5, &n);\\n    printf(\\\"删除顺序表中第5个元素，删除的元素为：%d\\\\n\\\", n);\\n    printf(\\\"删除过后的顺序表：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"顺序表中第6个元素：%d\\\\n\\\", GetElement(L, 6));\\n    \\n    printf(\\\"8在顺序表的位置：%d\\\\n\\\", LocateElement(L, 8));\\n    \\n    SeqList La, Lb, Lc;\\n\\n    InitList(&La);\\n    InitList(&Lb);\\n    InitList(&Lc);\\n    int j = 1;\\n    for (i = 1; i < 10; i += 2) {\\n    \\tInsertList(&La, j++, i);\\n\\t}\\n\\tprintf(\\\"顺序表La:\\\\n\\\");\\n\\tPrintList(La);\\n\\tj = 1;\\n\\tfor (i = 0; i < 10; i += 2) {\\n\\t\\tInsertList(&Lb, j++, i);\\n\\t}\\n\\tInsertList(&Lb, j++, 9);\\n\\tprintf(\\\"顺序表Lb:\\\\n\\\");\\n\\tPrintList(Lb);\\n\\t\\n\\tMergeList(La, Lb, &Lc);\\n\\tprintf(\\\"合并之后的顺序表Lc:\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n\\tInitList(&Lc);\\n\\tUnionList(La, Lb, &Lc);\\n\\tprintf(\\\"顺序表La和顺序表Lb的并集：\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200809152139.png)\\n\\n### 6、另附指针实现的动态顺序表\\n\\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType * elem**，利用**malloc**进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用**realloc**函数重新分配内存大小。\\n\\n```c++\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\\ntypedef int ElemType;\\n\\ntypedef struct Node {\\n    ElemType *elem;  // 指向顺序表的首地址\\n    int length; // 顺序表的实际长度\\n    int listSize; // 顺序表的最大长度\\n} SqList;\\n\\n// 初始化\\nvoid InitList(SqList *L) {\\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\\n    if (!L->elem) {\\n        exit(0);\\n    }\\n    L->length = 0;\\n    L->listSize = LIST_INIT_SIZE;\\n}\\n\\n// 插入元素\\nvoid InsertList(SqList *L, int i, ElemType e) {\\n    ElemType *q, *p;\\n    if (i < 1 || i > L->length + 1) {\\n        return;\\n    }\\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\\n        if (!L->elem) {\\n            exit(0);\\n        }\\n        L->listSize += LISTINCREMENT;\\n    }\\n\\n    q = L->elem + i - 1;\\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\\n        *p = *(p - 1);\\n    }\\n    *q = e;\\n    L->length++;\\n}\\n\\n// 删除元素\\nvoid ListDelete(SqList *L, int i, ElemType *e) {\\n    ElemType *p, *q;\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    p = L->elem + i - 1;\\n    *e = *p;\\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\\n        *q = *(q + 1);\\n    }\\n    L->length--;\\n}\\n\\n// 获取元素\\nvoid GetElement(SqList *L, int i, int *e) {\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    *e = *(L->elem + i - 1);\\n}\\n\\n// 遍历元素\\nvoid ListTraverse(SqList *L) {\\n    ElemType *p;\\n    if (L->length == 0) {\\n        printf(\\\"List NULL!\\\\n\\\");\\n        return;\\n    }\\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 销毁顺序表\\nvoid DestroyList(SqList *L) {\\n    free(L->elem);\\n    L->elem = NULL;\\n    L->length = 0;\\n    L->listSize = 0;\\n}\\n\\n// 合并两个顺序表\\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\\n\\n    pa = La->elem;\\n    pb = Lb->elem;\\n    Lc->listSize = Lc->length = La->length + Lb->length;\\n\\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\\n    if (!pc) {\\n        exit(0);\\n    }\\n    pa_last = La->elem + La->length - 1;\\n    pb_last = Lb->elem + Lb->length - 1;\\n\\n    while (pa <= pa_last && pb <= pb_last) {\\n        if (*pa <= *pb) {\\n            *pc++ = *pa++;\\n        } else {\\n            *pc++ = *pb++;\\n        }\\n    }\\n    while (pa <= pa_last) {\\n        *pc++ = *pa++;\\n    }\\n    while (pb <= pb_last) {\\n        *pc++ = *pb++;\\n    }\\n}\\n\\nint main() {\\n    SqList la, lb, lc;\\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\\n    ElemType e;\\n    int i;\\n\\n    InitList(La);\\n    InitList(Lb);\\n    InitList(Lc);\\n\\n    ElemType *pa = La->elem, *pb = Lb->elem;\\n\\n    for (i = 0; i < 10; i = i + 2) {\\n        *pa++ = i;\\n        La->length++;\\n    }\\n    printf(\\\"The List a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    for (i = 1; i < 10; i = i + 2) {\\n        *pb++ = i;\\n        Lb->length++;\\n    }\\n    printf(\\\"The List b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    InsertList(La, 3, 100);\\n    printf(\\\"After inserting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n    ListDelete(La, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    InsertList(Lb, 3, 99);\\n    printf(\\\"After inserting, the new list b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n    ListDelete(Lb, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"The list c is:\\\\n\\\");\\n    ListTraverse(Lc);\\n\\n    DestroyList(La);\\n    DestroyList(Lb);\\n\\n    ListTraverse(La);\\n    ListTraverse(Lb);\\n\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200808232536.png)\\n\\n### 7、注意\\n\\n本篇代码中函数参数中，顺序表的传参有两种写法：\\n\\n**SeqList L**（结构体变量），**SeqList * L** （结构体指针）\\n\\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList * L**，则使用**L->length**\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657093616.jpg\",\"articleTitle\":\"线性表的顺序存储\",\"categoryId\":16,\"id\":48,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[27]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:36:42');
INSERT INTO `tb_operation_log` VALUES (67, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 线性表的顺序存储\\n\\n### 1、顺序表的原理\\n\\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\\n\\n### 2、顺序表的特点\\n\\n1、空间是连续的；\\n\\n2、支持随机访问；\\n\\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\\n\\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\\n\\n### 3、基本存储结构\\n\\n```c++\\n#define MAXSIZE 100 // 线性表的最大长度 \\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n```\\n\\n### 4、基本功能\\n\\n- 顺序表的初始化功能       **void InitList(SeqList * L)**\\t\\n- 顺序表的判空     **int ListEmpty(SeqList L)**\\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList * L, int i, int e)**\\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList * L, int i, int * e)**\\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \\n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList * Lc)**\\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList * Lc)**\\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \\n\\n#### 1、顺序表的初始化\\n\\n将顺序表所有元素置为0，顺序表的实际长度置为0。\\n\\n```c++\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n```\\n\\n#### 2、顺序表的判空\\n\\n判断顺序表的实际长度是否等于0即可\\n\\n```c++\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n```\\n\\n#### 3、获取指定位置的元素\\n\\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\\n\\n```c++\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n```\\n\\n#### 4、在指定位置插入元素\\n\\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\\n+ 若没满足条件，即插入失败，返回0；\\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\\n\\n```c++\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n```\\n\\n#### 5、删除指定位置的元素\\n\\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\\n\\n```c++\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n```\\n\\n#### 6、返回元素的位置\\n\\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\\n\\n```c++\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n#### 7、合并顺序表\\n\\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\\n\\n```c++\\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\\n             return;\\n        }\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i]++;\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n```\\n\\n#### 8、两个顺序表的union操作（取并集，即要去重）\\n\\n```c++\\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### 9、遍历顺序表所有元素\\n\\n```c++\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n```\\n\\n### 5、完整代码和测试\\n\\n```c++\\n#include<stdio.h>\\n#define MAXSIZE 100 // 线性表的最大长度 \\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n\\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\\n// Lc中的数据元素仍然按值非递减有序排列\\n\\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i++];\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n// 并集 \\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main() {\\n    int i, n;\\n    SeqList L;\\n\\n    InitList(&L);\\n\\n    for (i = 0; i < 10; i++) {\\n        L.data[i] = i;\\n        L.length++;\\n    }\\n    printf(\\\"遍历默认创建好的顺序表：\\\\n\\\");\\n    PrintList(L);\\n\\n\\tprintf(\\\"在顺序表第4个位置插入元素11后：\\\\n\\\");\\n    InsertList(&L, 4, 11);\\n    PrintList(L);\\n\\n    DeleteList(&L, 5, &n);\\n    printf(\\\"删除顺序表中第5个元素，删除的元素为：%d\\\\n\\\", n);\\n    printf(\\\"删除过后的顺序表：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"顺序表中第6个元素：%d\\\\n\\\", GetElement(L, 6));\\n    \\n    printf(\\\"8在顺序表的位置：%d\\\\n\\\", LocateElement(L, 8));\\n    \\n    SeqList La, Lb, Lc;\\n\\n    InitList(&La);\\n    InitList(&Lb);\\n    InitList(&Lc);\\n    int j = 1;\\n    for (i = 1; i < 10; i += 2) {\\n    \\tInsertList(&La, j++, i);\\n\\t}\\n\\tprintf(\\\"顺序表La:\\\\n\\\");\\n\\tPrintList(La);\\n\\tj = 1;\\n\\tfor (i = 0; i < 10; i += 2) {\\n\\t\\tInsertList(&Lb, j++, i);\\n\\t}\\n\\tInsertList(&Lb, j++, 9);\\n\\tprintf(\\\"顺序表Lb:\\\\n\\\");\\n\\tPrintList(Lb);\\n\\t\\n\\tMergeList(La, Lb, &Lc);\\n\\tprintf(\\\"合并之后的顺序表Lc:\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n\\tInitList(&Lc);\\n\\tUnionList(La, Lb, &Lc);\\n\\tprintf(\\\"顺序表La和顺序表Lb的并集：\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n    return 0;\\n}\\n```\\n![QQ截图20200809152139.png]( https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657507455.png)\\n\\n### 6、另附指针实现的动态顺序表\\n\\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType * elem**，利用**malloc**进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用**realloc**函数重新分配内存大小。\\n\\n```c++\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\\ntypedef int ElemType;\\n\\ntypedef struct Node {\\n    ElemType *elem;  // 指向顺序表的首地址\\n    int length; // 顺序表的实际长度\\n    int listSize; // 顺序表的最大长度\\n} SqList;\\n\\n// 初始化\\nvoid InitList(SqList *L) {\\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\\n    if (!L->elem) {\\n        exit(0);\\n    }\\n    L->length = 0;\\n    L->listSize = LIST_INIT_SIZE;\\n}\\n\\n// 插入元素\\nvoid InsertList(SqList *L, int i, ElemType e) {\\n    ElemType *q, *p;\\n    if (i < 1 || i > L->length + 1) {\\n        return;\\n    }\\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\\n        if (!L->elem) {\\n            exit(0);\\n        }\\n        L->listSize += LISTINCREMENT;\\n    }\\n\\n    q = L->elem + i - 1;\\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\\n        *p = *(p - 1);\\n    }\\n    *q = e;\\n    L->length++;\\n}\\n\\n// 删除元素\\nvoid ListDelete(SqList *L, int i, ElemType *e) {\\n    ElemType *p, *q;\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    p = L->elem + i - 1;\\n    *e = *p;\\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\\n        *q = *(q + 1);\\n    }\\n    L->length--;\\n}\\n\\n// 获取元素\\nvoid GetElement(SqList *L, int i, int *e) {\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    *e = *(L->elem + i - 1);\\n}\\n\\n// 遍历元素\\nvoid ListTraverse(SqList *L) {\\n    ElemType *p;\\n    if (L->length == 0) {\\n        printf(\\\"List NULL!\\\\n\\\");\\n        return;\\n    }\\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 销毁顺序表\\nvoid DestroyList(SqList *L) {\\n    free(L->elem);\\n    L->elem = NULL;\\n    L->length = 0;\\n    L->listSize = 0;\\n}\\n\\n// 合并两个顺序表\\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\\n\\n    pa = La->elem;\\n    pb = Lb->elem;\\n    Lc->listSize = Lc->length = La->length + Lb->length;\\n\\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\\n    if (!pc) {\\n        exit(0);\\n    }\\n    pa_last = La->elem + La->length - 1;\\n    pb_last = Lb->elem + Lb->length - 1;\\n\\n    while (pa <= pa_last && pb <= pb_last) {\\n        if (*pa <= *pb) {\\n            *pc++ = *pa++;\\n        } else {\\n            *pc++ = *pb++;\\n        }\\n    }\\n    while (pa <= pa_last) {\\n        *pc++ = *pa++;\\n    }\\n    while (pb <= pb_last) {\\n        *pc++ = *pb++;\\n    }\\n}\\n\\nint main() {\\n    SqList la, lb, lc;\\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\\n    ElemType e;\\n    int i;\\n\\n    InitList(La);\\n    InitList(Lb);\\n    InitList(Lc);\\n\\n    ElemType *pa = La->elem, *pb = Lb->elem;\\n\\n    for (i = 0; i < 10; i = i + 2) {\\n        *pa++ = i;\\n        La->length++;\\n    }\\n    printf(\\\"The List a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    for (i = 1; i < 10; i = i + 2) {\\n        *pb++ = i;\\n        Lb->length++;\\n    }\\n    printf(\\\"The List b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    InsertList(La, 3, 100);\\n    printf(\\\"After inserting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n    ListDelete(La, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    InsertList(Lb, 3, 99);\\n    printf(\\\"After inserting, the new list b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n    ListDelete(Lb, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"The list c is:\\\\n\\\");\\n    ListTraverse(Lc);\\n\\n    DestroyList(La);\\n    DestroyList(Lb);\\n\\n    ListTraverse(La);\\n    ListTraverse(Lb);\\n\\n    return 0;\\n}\\n```\\n\\n![](QQ截图20200808232536.png)\\n\\n### 7、注意\\n\\n本篇代码中函数参数中，顺序表的传参有两种写法：\\n\\n**SeqList L**（结构体变量），**SeqList * L** （结构体指针）\\n\\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList * L**，则使用**L->length**\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657093616.jpg\",\"articleTitle\":\"线性表的顺序存储\",\"categoryId\":16,\"id\":48,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[27]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:38:39');
INSERT INTO `tb_operation_log` VALUES (68, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 线性表的顺序存储\\n\\n### 1、顺序表的原理\\n\\n顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。\\n\\n### 2、顺序表的特点\\n\\n1、空间是连续的；\\n\\n2、支持随机访问；\\n\\n3、在中间或前面部分的插入或删除时间复杂度为O(n)，效率低；\\n\\n4、根据下标随机访问时间复杂度为O（1），更适合频繁访问第n个元素，读取效率高\\n\\n### 3、基本存储结构\\n\\n```c++\\n#define MAXSIZE 100 // 线性表的最大长度 \\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n```\\n\\n### 4、基本功能\\n\\n- 顺序表的初始化功能       **void InitList(SeqList * L)**\\t\\n- 顺序表的判空     **int ListEmpty(SeqList L)**\\n- 获取顺序表指定位置的元素     **int GetElement(SeqList L, int i)**\\n- 在顺序表的指定位置上插入元素     **int InsertList(SeqList * L, int i, int e)**\\n- 删除顺序表中指定位置的元素      **int DeleteList(SeqList * L, int i, int * e)**\\n- 返回指定元素在顺序表中的位置      **int LocateElement(SeqList L, int e)** \\n- 合并两个非递减的顺序表，新的顺序表保持非递减     **void MerGeList(SeqList La, SeqList Lb, SeqList * Lc)**\\n- 两个顺序表取并集，即新的顺序表要进行去重     **void UnionList(SeqList La, SeqList Lb, SeqList * Lc)**\\n- 遍历输出顺序表的所有元素     **void PrintList(SeqList L)**   \\n\\n#### 1、顺序表的初始化\\n\\n将顺序表所有元素置为0，顺序表的实际长度置为0。\\n\\n```c++\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n```\\n\\n#### 2、顺序表的判空\\n\\n判断顺序表的实际长度是否等于0即可\\n\\n```c++\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n```\\n\\n#### 3、获取指定位置的元素\\n\\n首先对传入的下标进行判断，符合边界条件才能返回正确的值，否则返回0\\n\\n```c++\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n```\\n\\n#### 4、在指定位置插入元素\\n\\n+ 首先判断传入的下标是否合法，顺序表长度不能达到最大限制，不能小于0，不能大于实际长度；\\n+ 若没满足条件，即插入失败，返回0；\\n+ 若满足条件，将数组的元素**从后向前遍历**，依次将插入位置（包括插入位置）的元素**后移一位**，这样，待插入位置就会空闲下来，再将待插入元素赋值到数组对应下标的地方，并将顺序表长度+1。\\n\\n```c++\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n```\\n\\n#### 5、删除指定位置的元素\\n\\n+ 判断删除位置是否合法，不能小于0，不能大于顺序表实际长度-1，因为下标最大为L->length-1;\\n+ 将待删除的元素赋值给参数e，*e = L->data[i];\\n+ 将顺序表的所有元素，自删除位置开始，**从前向后遍历**，依次**前移一位**，则删除位置的元素被覆盖\\n\\n```c++\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n```\\n\\n#### 6、返回元素的位置\\n\\n遍历所有元素，若与参数元素相等，则返回其对应的位置（下标+1），查找不到，返回0\\n\\n```c++\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n#### 7、合并顺序表\\n\\n已知线性表La和Lb中的数据元素按值非递减排列，将La和Lb归并为一个新的线性表Lc，Lc中的数据元素仍然按值非递减有序排列\\n\\n```c++\\nvoid MerGeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n        if (L->length > MAXSIZE) { // 长度超过最大值，直接结束\\n             return;\\n        }\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i]++;\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n```\\n\\n#### 8、两个顺序表的union操作（取并集，即要去重）\\n\\n```c++\\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc){\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### 9、遍历顺序表所有元素\\n\\n```c++\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n```\\n\\n### 5、完整代码和测试\\n\\n```c++\\n#include<stdio.h>\\n#define MAXSIZE 100 // 线性表的最大长度 \\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n\\tDataType data[MAXSIZE]; // 线性表占用的数组空间 \\n\\tint length; // 线性表的实际长度 \\n} SeqList;\\n\\n// 初始化顺序表 \\nvoid InitList(SeqList *L) {\\n\\tfor (int i = 0; i < MAXSIZE; i++) {\\n\\t\\tL->data[i] = 0;\\n\\t}\\n\\tL->length = 0;\\n}\\n\\n// 判断顺序表是否为空 \\nint ListEmpty(SeqList L) {\\n    return L.length == 0;\\n}\\n\\n// 获取某个位置对应元素的值\\nint GetElement(SeqList L, int i) {\\n\\tif (L.length == 0 || i < 1 || i > L.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\treturn L.data[i-1];\\n}\\n\\n// 在某个位置插入元素 e \\nint InsertList(SeqList *L, int i, int e) {\\n\\tif (L->length == MAXSIZE || i < 1 || i > L->length + 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int k = L->length; k >= i; k--) {\\n\\t\\tL->data[k] = L->data[k-1];\\n\\t}\\n\\tL->data[i-1] = e;\\n\\tL->length++;\\n\\treturn 1;\\n}\\n\\n// 删除指定位置的元素 \\nint DeleteList(SeqList *L, int i, int *e)\\n{\\n\\tif (i < 1 || i > L->length) {\\n\\t\\treturn 0;\\n\\t}\\n\\t*e = L->data[i-1];\\n\\tfor (int k = i - 1; k < L->length - 1; k++) {\\n\\t\\tL->data[k] = L->data[k+1];\\n\\t}\\n\\tL->length--;\\n\\treturn 1;\\n}\\n\\n//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，\\n// Lc中的数据元素仍然按值非递减有序排列\\n\\nvoid MergeList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tint i = 0, j = 0;\\n\\tLc->length = La.length + Lb.length;//初始化Lc\\n\\tint k = 0;\\n\\twhile (i < La.length && j < Lb.length) {\\n\\t\\tif (La.data[i] <= Lb.data[j]) {\\n\\t\\t\\tLc->data[k++] = La.data[i++];\\n\\t\\t} else {\\n\\t\\t\\tLc->data[k++] = Lb.data[j++];\\n\\t\\t}\\n\\t}\\n\\twhile (i < La.length){\\n\\t\\tLc->data[k++] = La.data[i++];\\n\\t}\\n\\twhile (j < Lb.length) {\\n\\t\\tLc->data[k++] = Lb.data[j++];\\t\\n\\t}\\n}\\n\\n// 返回指定元素在顺序表中的位置 \\nint LocateElement(SeqList L, int e) {\\n\\tfor (int i = 0; i < L.length; i++) {\\n\\t\\tif (L.data[i] == e) {\\n\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n// 并集 \\nvoid UnionList(SeqList La, SeqList Lb, SeqList *Lc) {\\n\\tfor(int i = 0; i < La.length; i++) {\\n\\t\\tDataType e = La.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < Lb.length; i++) {\\n\\t\\tDataType e = Lb.data[i];\\n\\t\\tif (!LocateElement(*Lc, e)) {   \\n\\t\\t\\tInsertList(Lc, Lc->length + 1, e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// 遍历输出顺序表所有元素 \\nvoid PrintList(SeqList L) {\\n    for (int i = 0; i < L.length; i++) {\\n        printf(\\\"%d \\\", L.data[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main() {\\n    int i, n;\\n    SeqList L;\\n\\n    InitList(&L);\\n\\n    for (i = 0; i < 10; i++) {\\n        L.data[i] = i;\\n        L.length++;\\n    }\\n    printf(\\\"遍历默认创建好的顺序表：\\\\n\\\");\\n    PrintList(L);\\n\\n\\tprintf(\\\"在顺序表第4个位置插入元素11后：\\\\n\\\");\\n    InsertList(&L, 4, 11);\\n    PrintList(L);\\n\\n    DeleteList(&L, 5, &n);\\n    printf(\\\"删除顺序表中第5个元素，删除的元素为：%d\\\\n\\\", n);\\n    printf(\\\"删除过后的顺序表：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"顺序表中第6个元素：%d\\\\n\\\", GetElement(L, 6));\\n    \\n    printf(\\\"8在顺序表的位置：%d\\\\n\\\", LocateElement(L, 8));\\n    \\n    SeqList La, Lb, Lc;\\n\\n    InitList(&La);\\n    InitList(&Lb);\\n    InitList(&Lc);\\n    int j = 1;\\n    for (i = 1; i < 10; i += 2) {\\n    \\tInsertList(&La, j++, i);\\n\\t}\\n\\tprintf(\\\"顺序表La:\\\\n\\\");\\n\\tPrintList(La);\\n\\tj = 1;\\n\\tfor (i = 0; i < 10; i += 2) {\\n\\t\\tInsertList(&Lb, j++, i);\\n\\t}\\n\\tInsertList(&Lb, j++, 9);\\n\\tprintf(\\\"顺序表Lb:\\\\n\\\");\\n\\tPrintList(Lb);\\n\\t\\n\\tMergeList(La, Lb, &Lc);\\n\\tprintf(\\\"合并之后的顺序表Lc:\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n\\tInitList(&Lc);\\n\\tUnionList(La, Lb, &Lc);\\n\\tprintf(\\\"顺序表La和顺序表Lb的并集：\\\\n\\\");\\n\\tPrintList(Lc);\\n\\t\\n    return 0;\\n}\\n```\\n![QQ截图20200809152139.png]( https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657507455.png)\\n\\n### 6、另附指针实现的动态顺序表\\n\\n上一种顺序表的实现方式为静态顺序表，顺序表的最大长度指定以后，其大小不能动态改变。而动态顺序表存储的是顺序表的首地址**ElemType * elem**，利用**malloc**进行初始化开辟初始顺序表大小，对顺序表进行插入时，若当前顺序表空间已满，则可以利用**realloc**函数重新分配内存大小。\\n\\n```c++\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define LIST_INIT_SIZE 100  // 顺序表的初始大小\\n#define LISTINCREMENT 10  // 顺序表长度不够，每次增加的长度\\ntypedef int ElemType;\\n\\ntypedef struct Node {\\n    ElemType *elem;  // 指向顺序表的首地址\\n    int length; // 顺序表的实际长度\\n    int listSize; // 顺序表的最大长度\\n} SqList;\\n\\n// 初始化\\nvoid InitList(SqList *L) {\\n    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));// 开辟初始空间大小\\n    if (!L->elem) {\\n        exit(0);\\n    }\\n    L->length = 0;\\n    L->listSize = LIST_INIT_SIZE;\\n}\\n\\n// 插入元素\\nvoid InsertList(SqList *L, int i, ElemType e) {\\n    ElemType *q, *p;\\n    if (i < 1 || i > L->length + 1) {\\n        return;\\n    }\\n    if (L->length >= L->listSize) { // 若当前顺序表长度不够，则重新分配大小\\n        L->elem = realloc(L->elem, (L->listSize + LISTINCREMENT) * sizeof(ElemType));\\n        if (!L->elem) {\\n            exit(0);\\n        }\\n        L->listSize += LISTINCREMENT;\\n    }\\n\\n    q = L->elem + i - 1;\\n    for (p = L->elem + L->length; p > q; p--) { // 元素后移\\n        *p = *(p - 1);\\n    }\\n    *q = e;\\n    L->length++;\\n}\\n\\n// 删除元素\\nvoid ListDelete(SqList *L, int i, ElemType *e) {\\n    ElemType *p, *q;\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    p = L->elem + i - 1;\\n    *e = *p;\\n    for (q = p; q <= L->length + L->elem - 2; q++) { // 元素前移\\n        *q = *(q + 1);\\n    }\\n    L->length--;\\n}\\n\\n// 获取元素\\nvoid GetElement(SqList *L, int i, int *e) {\\n    if (i < 1 || i > L->length) {\\n        return;\\n    }\\n    *e = *(L->elem + i - 1);\\n}\\n\\n// 遍历元素\\nvoid ListTraverse(SqList *L) {\\n    ElemType *p;\\n    if (L->length == 0) {\\n        printf(\\\"List NULL!\\\\n\\\");\\n        return;\\n    }\\n    for (p = L->elem; p <= L->elem + L->length - 1; p++) {\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 销毁顺序表\\nvoid DestroyList(SqList *L) {\\n    free(L->elem);\\n    L->elem = NULL;\\n    L->length = 0;\\n    L->listSize = 0;\\n}\\n\\n// 合并两个顺序表\\nvoid MergeList(SqList *La, SqList *Lb, SqList *Lc) {\\n    ElemType *pa, *pb, *pc, *pa_last, *pb_last;\\n\\n    pa = La->elem;\\n    pb = Lb->elem;\\n    Lc->listSize = Lc->length = La->length + Lb->length;\\n\\n    pc = Lc->elem = (ElemType *) malloc(Lc->listSize * sizeof(ElemType));\\n    if (!pc) {\\n        exit(0);\\n    }\\n    pa_last = La->elem + La->length - 1;\\n    pb_last = Lb->elem + Lb->length - 1;\\n\\n    while (pa <= pa_last && pb <= pb_last) {\\n        if (*pa <= *pb) {\\n            *pc++ = *pa++;\\n        } else {\\n            *pc++ = *pb++;\\n        }\\n    }\\n    while (pa <= pa_last) {\\n        *pc++ = *pa++;\\n    }\\n    while (pb <= pb_last) {\\n        *pc++ = *pb++;\\n    }\\n}\\n\\nint main() {\\n    SqList la, lb, lc;\\n    SqList *La = &la, *Lb = &lb, *Lc = &lc;\\n    ElemType e;\\n    int i;\\n\\n    InitList(La);\\n    InitList(Lb);\\n    InitList(Lc);\\n\\n    ElemType *pa = La->elem, *pb = Lb->elem;\\n\\n    for (i = 0; i < 10; i = i + 2) {\\n        *pa++ = i;\\n        La->length++;\\n    }\\n    printf(\\\"The List a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    for (i = 1; i < 10; i = i + 2) {\\n        *pb++ = i;\\n        Lb->length++;\\n    }\\n    printf(\\\"The List b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    InsertList(La, 3, 100);\\n    printf(\\\"After inserting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n    ListDelete(La, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(La);\\n\\n    InsertList(Lb, 3, 99);\\n    printf(\\\"After inserting, the new list b is:\\\\n\\\");\\n    ListTraverse(Lb);\\n    ListDelete(Lb, 3, &e);\\n    printf(\\\"The deleted number is: \\\");\\n    printf(\\\"%d\\\\n\\\", e);\\n    printf(\\\"After deleting, the new list a is:\\\\n\\\");\\n    ListTraverse(Lb);\\n\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"The list c is:\\\\n\\\");\\n    ListTraverse(Lc);\\n\\n    DestroyList(La);\\n    DestroyList(Lb);\\n\\n    ListTraverse(La);\\n    ListTraverse(Lb);\\n\\n    return 0;\\n}\\n```\\n![QQ截图20200808232536.png]( https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657604480.png)\\n\\n### 7、注意\\n\\n本篇代码中函数参数中，顺序表的传参有两种写法：\\n\\n**SeqList L**（结构体变量），**SeqList * L** （结构体指针）\\n\\n+ 若在分函数中修改了顺序表L的内容（插入、删除、初始化等），则必须使用**SeqList *L**这种形式（当然也可以使用c++的引用参数写法  **SeqList &L**），这样分函数的修改才能对主函数的顺序表起作用。\\n+ 若分函数的操作为一些读操作，即不影响顺序表的内容，则采用两种方式均可以；若使用**SeqList L**，则在访问顺序表的元素采用**L.length**的形式，若使用**SeqList * L**，则使用**L->length**\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620657093616.jpg\",\"articleTitle\":\"线性表的顺序存储\",\"categoryId\":16,\"id\":48,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[27]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:40:07');
INSERT INTO `tb_operation_log` VALUES (69, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n## 1、存储结构\\n\\n```c\\ntypedef int DataType;  // 数据类型\\ntypedef struct Node {\\n    DataType data;   // 结点数据\\n    struct Node *next; // 指向下一个结点的指针\\n} Node, *LinkList;\\n```\\n\\n## 2、基本功能\\n\\n+ 头插法创建单链表   **void CreateListHead(LinkList &head)**\\n+ 尾插法创建单链表     **void CreateListTail(LinkList &head)**\\n+ 获取指定位置的元素   **int GetElement(LinkList head, int i, DataType &e)**\\n+ 获取指定元素的位置   **int LocateElement(LinkList head, int e)**\\n+ 在指定位置插入元素  **int InsertList(LinkList head, int i, DataType e)**\\n+ 删除指定位置的元素   **int DeleteList(LinkList head, int i, DataType &e)**\\n+ 获取单链表的长度       **int LengthLinkList(LinkList head)**\\n+ 合并两个非递减的单链表  **void MergeList(LinkList La, LinkList Lb, LinkList &Lc)**\\n+ 销毁链表                      **void Destroy(LinkList &L)**\\n+ 遍历打印单链表中的所有元素   **void PrintList(LinkList head)**\\n\\n### 1、头插法创建单链表\\n\\n每次新增的结点能放在头结点后面的第1号位置，所以创建好的单链表中的元素的顺序是输入元素的逆序。\\n\\n```c\\n/**\\n * 头插法创建单链表，输入以-1结束\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next; // 新增的结点指向头结点的下一个结点\\n        head->next = p;  // 头结点指向新增的结点\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n```\\n\\n### 2、尾插法创建单链表\\n\\n每次新增的结点都放在单链表的尾部，所以顺序和输入顺序保持一致。\\n\\n```c\\n/**\\n * 尾插法创建单链表，输入以-1结束\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n```\\n\\n### 3、获取指定位置的元素  \\n\\n```c\\n/**\\n * 获取指定位置的元素\\n * @param head 指向单链表头结点的指针（头指针）\\n * @param i 位置\\n * @param e 用来存放对应位置的元素值\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) { // 依次后移，直至为空或到达位置\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空表示位置超过最大位置，j > i表示位置不合法(i < 1)\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n```\\n\\n### 4、获取指定元素的位置 \\n\\n```c\\n/**\\n * 获取某个元素的位置\\n * @param head 头指针\\n * @param e 元素\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) { // 挨个遍历，依次比较\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {  // 查找不到该元素\\n        return 0;\\n    }\\n    return j;\\n}\\n```\\n\\n### 5、在指定位置插入元素 \\n\\n```c\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head; // 从头结点开始\\n    int j = 1;\\n\\n    while (p && j < i) { // 找到插入位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空或i < 1，插入位置不合法\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN); // 创建新结点\\n    q->data = e;\\n    q->next = p->next; // 将新结点指向前一个结点的后一个结点\\n    p->next = q; // 前一个结点指向新结点\\n    // 执行上述两个操作后，达到的效果是新结点插入到了前一个结点的后面\\n}\\n```\\n\\n### 6、删除指定位置的元素  \\n\\n```c\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {  // 找到位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next; // 改变前一个结点的指向，使其指向删除结点的后一个结点\\n    free(s); \\n    return 1;\\n}\\n```\\n\\n### 7、获取单链表的长度      \\n\\n```c\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return 单链表的长度\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n```\\n\\n### 8、合并两个非递减的单链表 \\n\\n合并两个非递减的单链表，新链表仍然保持非递减\\n\\n```c\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n```\\n\\n### 9、销毁链表  \\n\\n```c\\n/**\\n * 销毁链表\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) { // 遍历所有结点，释放内存\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL; // L置为NULL\\n}\\n```\\n\\n### 10、遍历打印单链表\\n\\n```c\\n/**\\n * 遍历打印单链表的所有元素\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n```\\n\\n## 3、完整代码及测试\\n\\n```c\\n#include<iostream>\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\n#define LEN sizeof(Node)\\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n    DataType data;\\n    struct Node *next;\\n} Node, *LinkList;\\n\\n/**\\n * 头插法创建单链表\\n * @param head\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n\\n/**\\n * 尾插法创建单链表\\n * @param head\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n/**\\n * 获取指定位置的元素\\n * @param head 单链表头指针\\n * @param i 位置\\n * @param e 获取的元素赋值该参数\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n\\n/**\\n * 获取某个元素的位置\\n * @param head\\n * @param e\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {\\n        return 0;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN);\\n    q->data = e;\\n    q->next = p->next;\\n    p->next = q;\\n}\\n\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next;\\n    free(s);\\n    return 1;\\n}\\n\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n\\n/**\\n * 销毁链表\\n * @param L\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) {\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL;\\n}\\n\\n/**\\n * 遍历打印单链表的所有元素\\n * @param head\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    LinkList L;\\n\\n    printf(\\\"头插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListHead(L);\\n    PrintList(L);\\n\\n    printf(\\\"尾插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListTail(L);\\n    PrintList(L);\\n\\n    InsertList(L, 1, 100);\\n    printf(\\\"在1号位置插入100后，单链表如下：\\\\n\\\");\\n    PrintList(L);\\n\\n    DataType e;\\n    DeleteList(L, 1, e); \\n    printf(\\\"删除1号位置的元素，被删除的元素为：\\\\n\\\");\\n    printf(\\\"删除后的单链表为：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"单链表的长度为：%d\\\\n\\\", LengthLinkList(L));\\n    \\n    GetElement(L, 1, e);\\n    printf(\\\"1号位置的元素为：%d\\\\n\\\");\\n    \\n    printf(\\\"元素4在单链表中的位置为：%d\\\\n\\\", LocateElement(L, 4));\\n\\n\\tcout << endl;\\n    LinkList La, Lb, Lc;\\n    printf(\\\"尾插法创建单链表La：\\\\n\\\");\\n    CreateListTail(La);\\n    PrintList(La);\\n    printf(\\\"尾插法创建单链表Lb：\\\\n\\\");\\n    CreateListTail(Lb);\\n    PrintList(Lb);\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"合并单链表La和Lb后的新单链表Lc如下：\\\\n\\\");\\n    PrintList(Lc);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081022033553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\\n\\n**注意：**\\n\\n上述函数采用了 C++ 引用参数的写法，**LinkList &head**，C语言下不支持这种写法，需要在 C++ 环境下使用，即.cpp文件。**下面附上C语言的写法：**\\n\\n```c\\n/**\\n * LinkList 本身已经是结构体指针，参数再使用LinkList *的形式\\n * 可以理解为要想改变一个结构体指针，则需要取指针的指针。\\n * 类似于改变int a，则需要使用 int *a，这里要改变LinkList head，则需要使用LinkList *head\\n */\\nvoid CreatListTail(LinkList *head) {\\n    int x;\\n    LinkList *p, *q;\\n\\n    *head = (LinkList *) malloc(LEN);\\n    q = *head;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n\\n// 可以不传参，函数里面定义头指针，创建链表，然后把头指针返回，主函数用结构体指针接收即可\\nLinkList CreateListhead() {\\n    int x;\\n    LinkList *head, *p;\\n\\n    head = (LinkList *) malloc(LEN);\\n    head->next = NULL;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n    }\\n    return head;\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658155146.jpg\",\"articleTitle\":\"2021-05-10\",\"categoryId\":16,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:49:28');
INSERT INTO `tb_operation_log` VALUES (70, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n## 1、存储结构\\n\\n```c\\ntypedef int DataType;  // 数据类型\\ntypedef struct Node {\\n    DataType data;   // 结点数据\\n    struct Node *next; // 指向下一个结点的指针\\n} Node, *LinkList;\\n```\\n\\n## 2、基本功能\\n\\n+ 头插法创建单链表   **void CreateListHead(LinkList &head)**\\n+ 尾插法创建单链表     **void CreateListTail(LinkList &head)**\\n+ 获取指定位置的元素   **int GetElement(LinkList head, int i, DataType &e)**\\n+ 获取指定元素的位置   **int LocateElement(LinkList head, int e)**\\n+ 在指定位置插入元素  **int InsertList(LinkList head, int i, DataType e)**\\n+ 删除指定位置的元素   **int DeleteList(LinkList head, int i, DataType &e)**\\n+ 获取单链表的长度       **int LengthLinkList(LinkList head)**\\n+ 合并两个非递减的单链表  **void MergeList(LinkList La, LinkList Lb, LinkList &Lc)**\\n+ 销毁链表                      **void Destroy(LinkList &L)**\\n+ 遍历打印单链表中的所有元素   **void PrintList(LinkList head)**\\n\\n### 1、头插法创建单链表\\n\\n每次新增的结点能放在头结点后面的第1号位置，所以创建好的单链表中的元素的顺序是输入元素的逆序。\\n\\n```c\\n/**\\n * 头插法创建单链表，输入以-1结束\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next; // 新增的结点指向头结点的下一个结点\\n        head->next = p;  // 头结点指向新增的结点\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n```\\n\\n### 2、尾插法创建单链表\\n\\n每次新增的结点都放在单链表的尾部，所以顺序和输入顺序保持一致。\\n\\n```c\\n/**\\n * 尾插法创建单链表，输入以-1结束\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n```\\n\\n### 3、获取指定位置的元素  \\n\\n```c\\n/**\\n * 获取指定位置的元素\\n * @param head 指向单链表头结点的指针（头指针）\\n * @param i 位置\\n * @param e 用来存放对应位置的元素值\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) { // 依次后移，直至为空或到达位置\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空表示位置超过最大位置，j > i表示位置不合法(i < 1)\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n```\\n\\n### 4、获取指定元素的位置 \\n\\n```c\\n/**\\n * 获取某个元素的位置\\n * @param head 头指针\\n * @param e 元素\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) { // 挨个遍历，依次比较\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {  // 查找不到该元素\\n        return 0;\\n    }\\n    return j;\\n}\\n```\\n\\n### 5、在指定位置插入元素 \\n\\n```c\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head; // 从头结点开始\\n    int j = 1;\\n\\n    while (p && j < i) { // 找到插入位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空或i < 1，插入位置不合法\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN); // 创建新结点\\n    q->data = e;\\n    q->next = p->next; // 将新结点指向前一个结点的后一个结点\\n    p->next = q; // 前一个结点指向新结点\\n    // 执行上述两个操作后，达到的效果是新结点插入到了前一个结点的后面\\n}\\n```\\n\\n### 6、删除指定位置的元素  \\n\\n```c\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {  // 找到位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next; // 改变前一个结点的指向，使其指向删除结点的后一个结点\\n    free(s); \\n    return 1;\\n}\\n```\\n\\n### 7、获取单链表的长度      \\n\\n```c\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return 单链表的长度\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n```\\n\\n### 8、合并两个非递减的单链表 \\n\\n合并两个非递减的单链表，新链表仍然保持非递减\\n\\n```c\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n```\\n\\n### 9、销毁链表  \\n\\n```c\\n/**\\n * 销毁链表\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) { // 遍历所有结点，释放内存\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL; // L置为NULL\\n}\\n```\\n\\n### 10、遍历打印单链表\\n\\n```c\\n/**\\n * 遍历打印单链表的所有元素\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n```\\n\\n## 3、完整代码及测试\\n\\n```c\\n#include<iostream>\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\n#define LEN sizeof(Node)\\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n    DataType data;\\n    struct Node *next;\\n} Node, *LinkList;\\n\\n/**\\n * 头插法创建单链表\\n * @param head\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n\\n/**\\n * 尾插法创建单链表\\n * @param head\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n/**\\n * 获取指定位置的元素\\n * @param head 单链表头指针\\n * @param i 位置\\n * @param e 获取的元素赋值该参数\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n\\n/**\\n * 获取某个元素的位置\\n * @param head\\n * @param e\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {\\n        return 0;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN);\\n    q->data = e;\\n    q->next = p->next;\\n    p->next = q;\\n}\\n\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next;\\n    free(s);\\n    return 1;\\n}\\n\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n\\n/**\\n * 销毁链表\\n * @param L\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) {\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL;\\n}\\n\\n/**\\n * 遍历打印单链表的所有元素\\n * @param head\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    LinkList L;\\n\\n    printf(\\\"头插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListHead(L);\\n    PrintList(L);\\n\\n    printf(\\\"尾插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListTail(L);\\n    PrintList(L);\\n\\n    InsertList(L, 1, 100);\\n    printf(\\\"在1号位置插入100后，单链表如下：\\\\n\\\");\\n    PrintList(L);\\n\\n    DataType e;\\n    DeleteList(L, 1, e); \\n    printf(\\\"删除1号位置的元素，被删除的元素为：\\\\n\\\");\\n    printf(\\\"删除后的单链表为：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"单链表的长度为：%d\\\\n\\\", LengthLinkList(L));\\n    \\n    GetElement(L, 1, e);\\n    printf(\\\"1号位置的元素为：%d\\\\n\\\");\\n    \\n    printf(\\\"元素4在单链表中的位置为：%d\\\\n\\\", LocateElement(L, 4));\\n\\n\\tcout << endl;\\n    LinkList La, Lb, Lc;\\n    printf(\\\"尾插法创建单链表La：\\\\n\\\");\\n    CreateListTail(La);\\n    PrintList(La);\\n    printf(\\\"尾插法创建单链表Lb：\\\\n\\\");\\n    CreateListTail(Lb);\\n    PrintList(Lb);\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"合并单链表La和Lb后的新单链表Lc如下：\\\\n\\\");\\n    PrintList(Lc);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081022033553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\\n\\n**注意：**\\n\\n上述函数采用了 C++ 引用参数的写法，**LinkList &head**，C语言下不支持这种写法，需要在 C++ 环境下使用，即.cpp文件。**下面附上C语言的写法：**\\n\\n```c\\n/**\\n * LinkList 本身已经是结构体指针，参数再使用LinkList *的形式\\n * 可以理解为要想改变一个结构体指针，则需要取指针的指针。\\n * 类似于改变int a，则需要使用 int *a，这里要改变LinkList head，则需要使用LinkList *head\\n */\\nvoid CreatListTail(LinkList *head) {\\n    int x;\\n    LinkList *p, *q;\\n\\n    *head = (LinkList *) malloc(LEN);\\n    q = *head;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n\\n// 可以不传参，函数里面定义头指针，创建链表，然后把头指针返回，主函数用结构体指针接收即可\\nLinkList CreateListhead() {\\n    int x;\\n    LinkList *head, *p;\\n\\n    head = (LinkList *) malloc(LEN);\\n    head->next = NULL;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n    }\\n    return head;\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658155146.jpg\",\"articleTitle\":\"单链表c/c++实现\",\"categoryId\":16,\"id\":49,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:50:16');
INSERT INTO `tb_operation_log` VALUES (71, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n### 1、存储结构\\n\\n```c\\n#define Stack_Init_Size 100\\n#define StackIncrement 10\\ntypedef int ElemType;\\ntypedef int Status;\\n\\n// 方式一（本文采取）\\ntypedef struct {\\n    ElemType *base; // 栈底指针\\n    ElemType *top; // 栈顶指针\\n    int stacksize; // 栈的最大容量\\n} SqStack;\\n\\n// 方式二\\ntypedef struct {\\n    int data[MaxSize];\\n    int top;\\n} SeqStack;\\n```\\n\\n### 2、函数列表\\n\\n+ ==Status InitStack(SqStack *S)==  初始化栈\\n+ `Status GetTopStack(SqStack *S, ElemType *e)`  获取栈顶元素，参数e存放栈顶元素的值\\n+ `Status PushStack(SqStack *S, ElemType e) `  进栈，将元素e入栈\\n+ `Status PopStack(SqStack *S, ElemType *e) `  出栈，出栈的元素存放在参数e中\\n+ `Status EmptyStack(SqStack *S)`  判断栈是否为空\\n+ `Status LengthStack(SqStack *S)`  获取栈的实际长度\\n+ `Status DestroyStack(SqStack *S)` 销毁栈\\n+ `Status StackTraverse(SqStack *S)` 遍历栈，打印每个元素\\n\\n### 3、完整代码\\n\\n```c\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define Stack_Init_Size 10 // 初始化栈的最大长度\\n#define StackIncrement 10 // 若栈最大空间不够时，需要增加的长度\\ntypedef int ElemType;\\ntypedef int Status;\\n\\ntypedef struct {\\n    ElemType *base; // 栈底指针\\n    ElemType *top; // 栈顶指针\\n    int stack_size; // 栈的最大长度\\n} SqStack;\\n\\n// 初始化栈\\nStatus InitStack(SqStack *S) {\\n    // 分配初始空间\\n    S->base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType));\\n    if (!S->base) {\\n        exit(0);\\n    }\\n    S->top = S->base; /// 栈顶与栈底相同\\n    S->stack_size = Stack_Init_Size; // 栈的最大长度等于初始长度\\n    return 1;\\n}\\n\\n// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可\\nStatus EmptyStack(SqStack *S) {\\n    return S->base == S->top;\\n}\\n\\n// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度\\nStatus LengthStack(SqStack *S) {\\n    if (S->top == S->base) {\\n        return 0;\\n    }\\n    return (Status) (S->top - S->base);\\n}\\n\\n// 获取栈顶的元素，参数e用来存放栈顶的元素\\nStatus GetTopStack(SqStack *S, ElemType *e) {\\n    if (S->top == S->base) {\\n        return 0;\\n    } \\n    *e = *(S->top - 1);\\n    return 1;\\n}\\n\\n// 进栈，参数e是要进栈的元素\\nStatus PushStack(SqStack *S, ElemType e) {\\n    // 若栈的最大长度不会够用时，重新开辟，增大长度\\n    if (S->top - S->base >= S->stack_size) {\\n        S->base = (ElemType *)realloc(S->base, (S->stack_size + StackIncrement) * sizeof(ElemType));\\n        if (!S->base) {\\n            return 0;\\n        }\\n        // 栈顶指针为栈底指针加上栈之前的最大长度\\n        S->top = S->base + S->stack_size;\\n        // 栈当前的最大长度等于栈之前的最大长度与增加的长度之和\\n        S->stack_size += StackIncrement;\\n    }\\n    *S->top++ = e; // 先赋值，后栈顶指针上移\\n    return 1;\\n}\\n\\n// 出栈，参数e用来存放出栈的元素\\nStatus PopStack(SqStack *S, ElemType *e) {\\n    if (S->base == S->top) {\\n        return 0;\\n    }\\n    *e = *--S->top; // 栈顶指针先下移，后赋值\\n    return 1;\\n}\\n\\n// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0\\nStatus DestroyStack(SqStack *S) {\\n    free(S->base);\\n    S->base = S->top = NULL;\\n    S->stack_size = 0;\\n    return 1;\\n}\\n\\n// 遍历栈，依次打印每个元素\\nStatus StackTraverse(SqStack *S) {\\n    ElemType *p;\\n\\n    if (S->top == S->base) {\\n        printf(\\\"Stack is NULL.\\\\n\\\");\\n        return 0;\\n    }\\n    p = S->top;\\n    // 由栈顶依次向下遍历\\n    while (p > S->base) {\\n        p--;\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    return 1;\\n}\\n\\nint main() {\\n    SqStack q, *S;\\n    S = &q;\\n\\n    int i, n, e;\\n\\n    printf(\\\"Creat a NULL Stack :\\\\n\\\");\\n    InitStack(S);\\n\\n    printf(\\\"input the length of the Stack :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    for (i = 1; i <= n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        PushStack(S, e);\\n    }\\n    printf(\\\"Is the stack NULL?\\\\n\\\");\\n\\n    if (EmptyStack(S)) {\\n        printf(\\\"Yes!\\\\n\\\");\\n    } else {\\n        printf(\\\"No!\\\\n\\\");\\n    }\\n    printf(\\\"The length of stack is %d.\\\\n\\\", LengthStack(S));\\n\\n    printf(\\\"The stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    e = GetTopStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"input the data to the stack :\\\\n\\\");\\n    scanf(\\\"%d\\\", &e);\\n    PushStack(S, e);\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    printf(\\\"Delete the top data : \\\");\\n    e = PopStack(S, &e);\\n    printf(\\\"%d\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    printf(\\\"Destroy the stack :\\\\n\\\");\\n    DestroyStack(S);\\n    StackTraverse(S);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819094841609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658455779.jpeg\",\"articleTitle\":\"顺序栈基本操作的C语言实现\",\"categoryId\":16,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[29]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:54:22');
INSERT INTO `tb_operation_log` VALUES (72, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n### 1、存储结构\\n\\n```c\\n#define Stack_Init_Size 100\\n#define StackIncrement 10\\ntypedef int ElemType;\\ntypedef int Status;\\n\\n// 方式一（本文采取）\\ntypedef struct {\\n    ElemType *base; // 栈底指针\\n    ElemType *top; // 栈顶指针\\n    int stacksize; // 栈的最大容量\\n} SqStack;\\n\\n// 方式二\\ntypedef struct {\\n    int data[MaxSize];\\n    int top;\\n} SeqStack;\\n```\\n\\n### 2、函数列表\\n\\n+ **Status InitStack(SqStack * S)**  初始化栈\\n+ **Status GetTopStack(SqStack * S, ElemType * e)**  获取栈顶元素，参数e存放栈顶元素的值\\n+ **Status PushStack(SqStack * S, ElemType e)**   进栈，将元素e入栈\\n+ **Status PopStack(SqStack * S, ElemType * e)**   出栈，出栈的元素存放在参数e中\\n+ **Status EmptyStack(SqStack * S)**  判断栈是否为空\\n+ **Status LengthStack(SqStack * S)** 获取栈的实际长度\\n+ **Status DestroyStack(SqStack * S)** 销毁栈\\n+ **Status StackTraverse(SqStack * S)** 遍历栈，打印每个元素\\n\\n### 3、完整代码\\n\\n```c\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define Stack_Init_Size 10 // 初始化栈的最大长度\\n#define StackIncrement 10 // 若栈最大空间不够时，需要增加的长度\\ntypedef int ElemType;\\ntypedef int Status;\\n\\ntypedef struct {\\n    ElemType *base; // 栈底指针\\n    ElemType *top; // 栈顶指针\\n    int stack_size; // 栈的最大长度\\n} SqStack;\\n\\n// 初始化栈\\nStatus InitStack(SqStack *S) {\\n    // 分配初始空间\\n    S->base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType));\\n    if (!S->base) {\\n        exit(0);\\n    }\\n    S->top = S->base; /// 栈顶与栈底相同\\n    S->stack_size = Stack_Init_Size; // 栈的最大长度等于初始长度\\n    return 1;\\n}\\n\\n// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可\\nStatus EmptyStack(SqStack *S) {\\n    return S->base == S->top;\\n}\\n\\n// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度\\nStatus LengthStack(SqStack *S) {\\n    if (S->top == S->base) {\\n        return 0;\\n    }\\n    return (Status) (S->top - S->base);\\n}\\n\\n// 获取栈顶的元素，参数e用来存放栈顶的元素\\nStatus GetTopStack(SqStack *S, ElemType *e) {\\n    if (S->top == S->base) {\\n        return 0;\\n    } \\n    *e = *(S->top - 1);\\n    return 1;\\n}\\n\\n// 进栈，参数e是要进栈的元素\\nStatus PushStack(SqStack *S, ElemType e) {\\n    // 若栈的最大长度不会够用时，重新开辟，增大长度\\n    if (S->top - S->base >= S->stack_size) {\\n        S->base = (ElemType *)realloc(S->base, (S->stack_size + StackIncrement) * sizeof(ElemType));\\n        if (!S->base) {\\n            return 0;\\n        }\\n        // 栈顶指针为栈底指针加上栈之前的最大长度\\n        S->top = S->base + S->stack_size;\\n        // 栈当前的最大长度等于栈之前的最大长度与增加的长度之和\\n        S->stack_size += StackIncrement;\\n    }\\n    *S->top++ = e; // 先赋值，后栈顶指针上移\\n    return 1;\\n}\\n\\n// 出栈，参数e用来存放出栈的元素\\nStatus PopStack(SqStack *S, ElemType *e) {\\n    if (S->base == S->top) {\\n        return 0;\\n    }\\n    *e = *--S->top; // 栈顶指针先下移，后赋值\\n    return 1;\\n}\\n\\n// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0\\nStatus DestroyStack(SqStack *S) {\\n    free(S->base);\\n    S->base = S->top = NULL;\\n    S->stack_size = 0;\\n    return 1;\\n}\\n\\n// 遍历栈，依次打印每个元素\\nStatus StackTraverse(SqStack *S) {\\n    ElemType *p;\\n\\n    if (S->top == S->base) {\\n        printf(\\\"Stack is NULL.\\\\n\\\");\\n        return 0;\\n    }\\n    p = S->top;\\n    // 由栈顶依次向下遍历\\n    while (p > S->base) {\\n        p--;\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    return 1;\\n}\\n\\nint main() {\\n    SqStack q, *S;\\n    S = &q;\\n\\n    int i, n, e;\\n\\n    printf(\\\"Creat a NULL Stack :\\\\n\\\");\\n    InitStack(S);\\n\\n    printf(\\\"input the length of the Stack :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    for (i = 1; i <= n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        PushStack(S, e);\\n    }\\n    printf(\\\"Is the stack NULL?\\\\n\\\");\\n\\n    if (EmptyStack(S)) {\\n        printf(\\\"Yes!\\\\n\\\");\\n    } else {\\n        printf(\\\"No!\\\\n\\\");\\n    }\\n    printf(\\\"The length of stack is %d.\\\\n\\\", LengthStack(S));\\n\\n    printf(\\\"The stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    e = GetTopStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"input the data to the stack :\\\\n\\\");\\n    scanf(\\\"%d\\\", &e);\\n    PushStack(S, e);\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    printf(\\\"Delete the top data : \\\");\\n    e = PopStack(S, &e);\\n    printf(\\\"%d\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    printf(\\\"Destroy the stack :\\\\n\\\");\\n    DestroyStack(S);\\n    StackTraverse(S);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819094841609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658675963.jpeg\",\"articleTitle\":\"顺序栈基本操作的C语言实现\",\"categoryId\":16,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[29]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-10 22:58:02');
INSERT INTO `tb_operation_log` VALUES (73, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\\n\\n**Description**\\n\\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\\n每天只能卖一个商品.\\n现在你要让超市获得最大的利润.\\n\\n**Input**\\n\\n多组数据.\\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\\n\\n**Output**\\n\\n对于每一组数据, 输出当前条件下超市的最大利润\\n\\n**Sample Input**\\n\\n4\\n50 2\\n10 1\\n20 2\\n30 1\\n\\n7\\n20 1\\n2 1\\n10 3\\n100 2\\n8 2\\n5 20\\n50 10\\n\\n**Sample Output**\\n\\n80\\n185\\n\\n**解题思路**\\n\\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\n\\nusing namespace std;\\n\\ntypedef struct Node {\\n\\tint p;\\n\\tint d;\\n} Product;\\n\\nbool cmp(Product p1, Product p2) {\\n\\treturn p1.p > p2.p;\\n}\\n\\nProduct pro[10001];\\nint visit[10001]; //标记某天是否卖过商品\\n\\nint main() {\\n\\tint n, sum;\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tcin>>pro[i].p>>pro[i].d;\\n\\t\\t// 按利润从高到低排序\\n\\t\\tsort(pro + 1, pro + n + 1, cmp);\\n\\t\\tsum = 0;\\n\\t\\tmemset(visit, 0, sizeof(visit));\\n         // 先售卖高利润的商品\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (visit[pro[i].d] == 0) {\\n\\t\\t\\t\\tvisit[pro[i].d] = 1;\\n\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t} else {\\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\\n\\t\\t\\t\\tfor (int j = pro[i].d - 1; j >= 1; j--) {\\n\\t\\t\\t\\t\\tif (visit[j] == 0) {\\n\\t\\t\\t\\t\\t\\tvisit[j] = 1;\\n\\t\\t\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\\n\\n**Problem Description**\\n\\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\\n\\n**Input**\\n\\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\\n\\n**Output**\\n\\nFor each test case, you should output the smallest total reduced score, one line per test case.\\n\\n**Sample Input**\\n\\n```c++\\n3\\n3\\n3 3 3\\n10 5 1\\n3\\n1 3 1\\n6 2 3\\n7\\n1 4 6 4 2 4 3\\n3 2 1 7 6 5 4\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n3\\n5\\n```\\n\\n**解题思路**\\n\\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint deadline;\\n\\tint score;\\n} work[1005];\\n\\nint T, N;\\nint day[1005]; // 标记当天有没有做过作业 \\n\\nint cmp(Node a, Node b) {\\n\\treturn a.score > b.score; \\n}\\n\\nint main() {\\n\\tcin>>T;\\n\\tfor (int i = 0; i < T; i++) {\\n\\t\\tint res = 0;\\n\\t\\tmemset(day, 0, sizeof(day));\\n\\t\\tcin>>N;\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].deadline;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].score;\\n\\t\\t}\\n\\t\\t// 按分数降序排列 \\n\\t\\tsort(work, work + N, cmp);\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tint d = work[j].deadline;\\n\\t\\t\\t// 若当天没做作业 \\n\\t\\t\\tif (!day[d]) {\\n\\t\\t\\t\\t// 标记做过 \\n\\t\\t\\t\\tday[d] = 1;\\n\\t\\t\\t} else { // 当天做过作业 \\n\\t\\t\\t\\tint flag = 0; // 标记有没有找到 \\n\\t\\t\\t\\t// 往前找到没有做过作业的那天 \\n\\t\\t\\t\\tfor (int k = d - 1; k >= 1; k--) {\\n\\t\\t\\t\\t\\tif (!day[k]) { \\n\\t\\t\\t\\t\\t\\tday[k] = 1;\\n\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t// 没找到，则扣分 \\n\\t\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\t\\tres += work[j].score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\\n\\n**Problem Description**\\n\\n“今年暑假不AC？”\\n“是的。”\\n“那你干什么呢？”\\n“看世界杯呀，笨蛋！”\\n“@#$%^&*%...”\\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\\n\\n**Input**\\n\\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\\n\\n**Output**\\n\\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n12\\n1 3\\n3 4\\n0 7\\n3 8\\n15 19\\n15 20\\n10 15\\n8 18\\n6 12\\n5 10\\n4 14\\n2 9\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n5\\n```\\n\\n**解题思路**\\n\\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint tis;\\n\\tint tie;\\n} p[105];\\n \\nint cmp(Node a, Node b) {\\n\\treturn a.tie < b.tie;\\n}\\n\\nint main() {\\n\\tint n;\\n\\twhile (cin>>n && n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].tis>>p[i].tie;\\n\\t\\t}\\n\\t\\t// 按结束时间升序列 \\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint res = 1;\\n\\t\\tint pTie = p[0].tie; // 记录上个节目结束的时间 \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \\n\\t\\t\\tif (p[i].tis >= pTie) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tpTie = p[i].tie; // 更新 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn  0;\\n}\\n```\\n\\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\\n\\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \\\"carbon\\\"的字串是: \\\"c\\\", \\\"ca\\\", \\\"car\\\", \\\"carb\\\", \\\"carbo\\\", 和 \\\"carbon\\\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \\\"carbohydrate\\\" 通常用\\\"carb\\\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\\n在下面的例子中，\\\"carbohydrate\\\" 能被缩略成\\\"carboh\\\", 但是不能被缩略成\\\"carbo\\\" (或其余更短的前缀) 因为已经有一个单词用\\\"carbo\\\"开始\\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\\\"car\\\"精确匹配单词\\\"car\\\". 因此 \\\"car\\\" 是 \\\"car\\\"的缩略语是没有二义性的 , “car”不会被当成\\\"carriage\\\"或者任何在列表中以\\\"car\\\"开始的单词.\\n\\n**Input**\\n\\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\\n\\n**Output**\\n\\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\\n\\n**Sample Input**\\n\\n```c++\\ncarbohydrate\\ncart\\ncarburetor\\ncaramel\\ncaribou\\ncarbonic\\ncartilage\\ncarbon\\ncarriage\\ncarton\\ncar\\ncarbonate\\n```\\n\\n**Sample Output**\\n\\n```c++\\ncarbohydrate carboh\\ncart cart\\ncarburetor carbu\\ncaramel cara\\ncaribou cari\\ncarbonic carboni\\ncartilage carti\\ncarbon carbon\\ncarriage carr\\ncarton carto\\ncar car\\ncarbonate carbona\\n```\\n\\n**解题**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstring ss[1005];\\nchar str[25];\\n\\nint main() {\\n\\tint len = 0;\\n\\tint i, j, k;\\n\\twhile (cin>>ss[len]) {\\n\\t\\tlen++;\\n\\t}\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint size = ss[i].length();\\n        // 遍历当前字符串的每个字符\\n\\t\\tfor (j = 0; j < size; j++) {\\n\\t\\t\\tmemset(str, 0, sizeof str); \\n            // 前缀\\n\\t\\t\\tfor (k = 0; k <= j; k++) {\\n\\t\\t\\t\\tstr[k] = ss[i][k];\\n\\t\\t\\t}\\n\\t\\t\\tstr[k] = \'\\\\0\';\\n            // 与其他字符串挨个比较\\n\\t\\t\\tfor (k = 0; k < len; k++) {\\n\\t\\t\\t\\tif (k != i) {\\n\\t\\t\\t\\t\\t// strstr(a, b):返回b在a中的起始位置，a是b的字串\\n\\t\\t\\t\\t\\t//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \\n\\t\\t\\t\\t\\tif (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (k == len) {\\n\\t\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i].substr(0, j + 1)<<endl;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (j == size) {\\n\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\\n\\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\\n\\n**Input**\\n\\n第一行t, 表示有t组数据；\\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\\n\\n**Output**\\n\\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n9128456 2\\n1444 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\n12456\\n1\\n```\\n\\n**解题思路**\\n\\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\\n\\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\\n\\n```c++\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n\\tint t, k;\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tstring str; \\n\\t\\tcin>>str>>k;\\n\\t\\tint len = str.size();\\n\\t\\twhile (k--) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\t// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\\n\\t\\t\\t\\tif (str[i] > str[i + 1] || i == len - 1) {\\n\\t\\t\\t\\t\\tstr.erase(i, 1);\\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\n\\t\\t}\\n        // 处理一下高位为0的情况\\n\\t\\tint j = 0;\\n\\t\\tint newLen = str.size();\\n\\t\\twhile(j < newLen && str[j] == \'0\') {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == newLen) {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<str.substr(j, newLen)<<endl; \\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\\n\\n**Problem Description**\\n\\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\\n\\n**Input**\\n\\n多组数据。对于每组数据：\\n第一行为正整数n，表示菜的数量。n<=1000。\\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\\nn=0表示数据结束。\\n\\n**Output**\\n\\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\\n\\n**Sample Input**\\n\\n```c++\\n1\\n50\\n5\\n10\\n1 2 3 2 1 1 2 3 2 1\\n50\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n-45\\n32\\n```\\n\\n**解题思路**\\n\\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n, m;\\nint v[1005];\\nint dp[1005]; \\n\\nint main() {\\n\\twhile (cin>>n && n) {\\n\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>v[i];\\n\\t\\t}\\n\\t\\t// 升序排列 \\n\\t\\tsort(v, v + n);\\n\\t\\tcin>>m;\\n\\t\\t// 余额小于5直接输出 \\n\\t\\tif (m < 5) {\\n\\t\\t\\tcout<<m<<endl;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// 0/1背包，减5后的余额买最多的菜\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = m - 5; j >= v[i]; j--) {\\n\\t\\t\\t\\tdp[j] = max(dp[j], dp[j - v[i]] + v[i]);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tcout<<m-dp[m-5]-v[n-1]<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [Task（HDU-4864）](http://acm.hdu.edu.cn/showproblem.php?pid=4864)\\n\\n**Problem Description**\\n\\nToday the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500*xi+2*yi) dollars.\\nThe company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.\\n\\n**Input**\\n\\nThe input contains several test cases.\\nThe first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 < =N <= 100000,1<=M<=100000).\\nThe following N lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the maximum time the machine can work.yi is the level of the machine.\\nThe following M lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the time we need to complete the task.yi is the level of the task.\\n\\n**Output**\\n\\nFor each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.\\n\\n**Sample Input**\\n\\n```c++\\n1 2\\n100 3\\n100 2\\n100 1\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 50004\\n```\\n\\n**题目大意**：有Ｎ个机器，机器有最大执行时间和等级；有Ｍ个任务，每个任务有执行时间和等级，只有当机器的执行时间和等级均大于等于任务的执行时间和等级时，该台机器才能执行该任务，每执行一个任务能获得500*xi+2*yi的酬劳（xi是任务时长，yi是任务等级），每台机器每天只能使用一次，问一天最多能获得多大的酬劳。(机器的数据范围：0<xi<1440，0=<yi<=100)，(任务的数据范围：0<xi<1440，0=<yi<=100)。\\n\\n**解题思路**：根据酬劳的计算公式和xi、yi的范围可知，对酬劳大小其决定作用的是执行时长xi，所以对所有机器和任务按执行时长进行降序排列，若时长相等，按等级降序排列。贪心暴力。核心点：**后面的任务必然能够被先前加进来的机器执行完毕，因为任务是按时间降序排列的**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn]; // 机器\\nP w[maxn]; // 任务\\nint level[105]; // 满足任务时长的对应等级的机器数\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(level, 0, sizeof(level));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\t// 后面的加进来的任务必然能够被先前加进来的机所完毕，因为任务是按时间降序排列的\\n\\t\\tfor (int i = 0, j = 0; i < M; i++) {\\n\\t\\t\\twhile (j < N && m[j].x >= w[i].x) {\\n\\t\\t\\t\\tlevel[m[j].y]++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k = w[i].y; k <= 100; k++) {\\n\\t\\t\\t\\tif (level[k]) {\\n\\t\\t\\t\\t\\tlevel[k]--;\\n\\t\\t\\t\\t\\tsum += w[i].x * 500 + w[i].y * 2;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n\\n---------------------------------------------------------------------------\\n// 这种写法会超时\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn];\\nP w[maxn];\\nint vis[maxn];\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tfor (int j = N - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (vis[j]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (m[j].x >= w[i].x && m[j].y >= w[i].y) {\\n\\t\\t\\t\\t\\tvis[j] = 1;\\n\\t\\t\\t\\t\\tsum += 500 * w[i].x + 2 * w[i].y;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## [Intervals POJ-1089](http://poj.org/problem?id=1089)\\n\\n**Description**\\n\\nThere is given the series of n closed intervals [ai; bi], where i=1,2,...,n. The sum of those intervals may be represented as a sum of closed pairwise non−intersecting intervals. The task is to find such representation with the minimal number of intervals. The intervals of this representation should be written in the output file in acceding order. We say that the intervals [a; b] and [c; d] are in ascending order if, and only if a <= b < c <= d.\\nTask\\nWrite a program which:\\nreads from the std input the description of the series of intervals,\\ncomputes pairwise non−intersecting intervals satisfying the conditions given above,\\nwrites the computed intervals in ascending order into std output\\n\\n**Input**\\n\\nIn the first line of input there is one integer n, 3 <= n <= 50000. This is the number of intervals. In the (i+1)−st line, 1 <= i <= n, there is a description of the interval [ai; bi] in the form of two integers ai and bi separated by a single space, which are respectively the beginning and the end of the interval,1 <= ai <= bi <= 1000000.\\n\\n**Output**\\n\\nThe output should contain descriptions of all computed pairwise non−intersecting intervals. In each line should be written a description of one interval. It should be composed of two integers, separated by a single space, the beginning and the end of the interval respectively. The intervals should be written into the output in ascending order.\\n\\n**Sample Input**\\n\\n```c++\\n5\\n5 6\\n1 4\\n10 10\\n6 9\\n8 10\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 4\\n5 10\\n```\\n\\n**题目大意**：输入n个区间，求出最大的区间覆盖\\n\\n**解题思路**：对所有区间按左端点升序排列，遍历所有区间， 如果当前区间的左端点大于上一区间的右端点，则形成新的区间，否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 50005;\\n\\nstruct Node {\\n\\tint x;\\n\\tint y;\\n} p[maxn], r[maxn]; \\n\\n// 按左端点大小升序排列 \\nint cmp(Node a, Node b) {\\n\\treturn a.x < b.x;\\n}\\n\\nint n;\\nint main() {\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].x>>p[i].y;\\n\\t\\t}\\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint cnt = 0;\\n\\t\\tr[0].x = p[0].x;\\n\\t\\tr[0].y = p[0].y; \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前区间的左端点大于上一区间的右端点，则形成新的区间 \\n\\t\\t\\tif (p[i].x > r[cnt].y) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tr[cnt].x = p[i].x;\\n\\t\\t\\t\\tr[cnt].y = p[i].y;\\n             // 否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \\n\\t\\t\\t} else if (p[i].y > r[cnt].y ) { \\n\\t\\t\\t\\tr[cnt].y = p[i].y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= cnt; i++) {\\n\\t\\t\\tcout<<r[i].x<<\\\" \\\"<<r[i].y<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg\",\"articleTitle\":\"贪心算法刷题记录\",\"categoryId\":15,\"id\":47,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:18:32');
INSERT INTO `tb_operation_log` VALUES (74, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n## 1、存储结构\\n\\n```c\\ntypedef int DataType;  // 数据类型\\ntypedef struct Node {\\n    DataType data;   // 结点数据\\n    struct Node *next; // 指向下一个结点的指针\\n} Node, *LinkList;\\n```\\n\\n## 2、基本功能\\n\\n+ 头插法创建单链表   **void CreateListHead(LinkList &head)**\\n+ 尾插法创建单链表     **void CreateListTail(LinkList &head)**\\n+ 获取指定位置的元素   **int GetElement(LinkList head, int i, DataType &e)**\\n+ 获取指定元素的位置   **int LocateElement(LinkList head, int e)**\\n+ 在指定位置插入元素  **int InsertList(LinkList head, int i, DataType e)**\\n+ 删除指定位置的元素   **int DeleteList(LinkList head, int i, DataType &e)**\\n+ 获取单链表的长度       **int LengthLinkList(LinkList head)**\\n+ 合并两个非递减的单链表  **void MergeList(LinkList La, LinkList Lb, LinkList &Lc)**\\n+ 销毁链表                      **void Destroy(LinkList &L)**\\n+ 遍历打印单链表中的所有元素   **void PrintList(LinkList head)**\\n\\n### 1、头插法创建单链表\\n\\n每次新增的结点能放在头结点后面的第1号位置，所以创建好的单链表中的元素的顺序是输入元素的逆序。\\n\\n```c\\n/**\\n * 头插法创建单链表，输入以-1结束\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next; // 新增的结点指向头结点的下一个结点\\n        head->next = p;  // 头结点指向新增的结点\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n```\\n\\n### 2、尾插法创建单链表\\n\\n每次新增的结点都放在单链表的尾部，所以顺序和输入顺序保持一致。\\n\\n```c\\n/**\\n * 尾插法创建单链表，输入以-1结束\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n```\\n\\n### 3、获取指定位置的元素  \\n\\n```c\\n/**\\n * 获取指定位置的元素\\n * @param head 指向单链表头结点的指针（头指针）\\n * @param i 位置\\n * @param e 用来存放对应位置的元素值\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) { // 依次后移，直至为空或到达位置\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空表示位置超过最大位置，j > i表示位置不合法(i < 1)\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n```\\n\\n### 4、获取指定元素的位置 \\n\\n```c\\n/**\\n * 获取某个元素的位置\\n * @param head 头指针\\n * @param e 元素\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) { // 挨个遍历，依次比较\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {  // 查找不到该元素\\n        return 0;\\n    }\\n    return j;\\n}\\n```\\n\\n### 5、在指定位置插入元素 \\n\\n```c\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head; // 从头结点开始\\n    int j = 1;\\n\\n    while (p && j < i) { // 找到插入位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空或i < 1，插入位置不合法\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN); // 创建新结点\\n    q->data = e;\\n    q->next = p->next; // 将新结点指向前一个结点的后一个结点\\n    p->next = q; // 前一个结点指向新结点\\n    // 执行上述两个操作后，达到的效果是新结点插入到了前一个结点的后面\\n}\\n```\\n\\n### 6、删除指定位置的元素  \\n\\n```c\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {  // 找到位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next; // 改变前一个结点的指向，使其指向删除结点的后一个结点\\n    free(s); \\n    return 1;\\n}\\n```\\n\\n### 7、获取单链表的长度      \\n\\n```c\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return 单链表的长度\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n```\\n\\n### 8、合并两个非递减的单链表 \\n\\n合并两个非递减的单链表，新链表仍然保持非递减\\n\\n```c\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n```\\n\\n### 9、销毁链表  \\n\\n```c\\n/**\\n * 销毁链表\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) { // 遍历所有结点，释放内存\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL; // L置为NULL\\n}\\n```\\n\\n### 10、遍历打印单链表\\n\\n```c\\n/**\\n * 遍历打印单链表的所有元素\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n```\\n\\n## 3、完整代码及测试\\n\\n```c\\n#include<iostream>\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\n#define LEN sizeof(Node)\\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n    DataType data;\\n    struct Node *next;\\n} Node, *LinkList;\\n\\n/**\\n * 头插法创建单链表\\n * @param head\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n\\n/**\\n * 尾插法创建单链表\\n * @param head\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n/**\\n * 获取指定位置的元素\\n * @param head 单链表头指针\\n * @param i 位置\\n * @param e 获取的元素赋值该参数\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n\\n/**\\n * 获取某个元素的位置\\n * @param head\\n * @param e\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {\\n        return 0;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN);\\n    q->data = e;\\n    q->next = p->next;\\n    p->next = q;\\n}\\n\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next;\\n    free(s);\\n    return 1;\\n}\\n\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n\\n/**\\n * 销毁链表\\n * @param L\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) {\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL;\\n}\\n\\n/**\\n * 遍历打印单链表的所有元素\\n * @param head\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    LinkList L;\\n\\n    printf(\\\"头插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListHead(L);\\n    PrintList(L);\\n\\n    printf(\\\"尾插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListTail(L);\\n    PrintList(L);\\n\\n    InsertList(L, 1, 100);\\n    printf(\\\"在1号位置插入100后，单链表如下：\\\\n\\\");\\n    PrintList(L);\\n\\n    DataType e;\\n    DeleteList(L, 1, e); \\n    printf(\\\"删除1号位置的元素，被删除的元素为：\\\\n\\\");\\n    printf(\\\"删除后的单链表为：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"单链表的长度为：%d\\\\n\\\", LengthLinkList(L));\\n    \\n    GetElement(L, 1, e);\\n    printf(\\\"1号位置的元素为：%d\\\\n\\\");\\n    \\n    printf(\\\"元素4在单链表中的位置为：%d\\\\n\\\", LocateElement(L, 4));\\n\\n\\tcout << endl;\\n    LinkList La, Lb, Lc;\\n    printf(\\\"尾插法创建单链表La：\\\\n\\\");\\n    CreateListTail(La);\\n    PrintList(La);\\n    printf(\\\"尾插法创建单链表Lb：\\\\n\\\");\\n    CreateListTail(Lb);\\n    PrintList(Lb);\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"合并单链表La和Lb后的新单链表Lc如下：\\\\n\\\");\\n    PrintList(Lc);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081022033553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\\n\\n**注意：**\\n\\n上述函数采用了 C++ 引用参数的写法，**LinkList &head**，C语言下不支持这种写法，需要在 C++ 环境下使用，即.cpp文件。**下面附上C语言的写法：**\\n\\n```c\\n/**\\n * LinkList 本身已经是结构体指针，参数再使用LinkList *的形式\\n * 可以理解为要想改变一个结构体指针，则需要取指针的指针。\\n * 类似于改变int a，则需要使用 int *a，这里要改变LinkList head，则需要使用LinkList *head\\n */\\nvoid CreatListTail(LinkList *head) {\\n    int x;\\n    LinkList *p, *q;\\n\\n    *head = (LinkList *) malloc(LEN);\\n    q = *head;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n\\n// 可以不传参，函数里面定义头指针，创建链表，然后把头指针返回，主函数用结构体指针接收即可\\nLinkList CreateListhead() {\\n    int x;\\n    LinkList *head, *p;\\n\\n    head = (LinkList *) malloc(LEN);\\n    head->next = NULL;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n    }\\n    return head;\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658155146.jpg\",\"articleTitle\":\"x线性表的链式实现 - 单链表\",\"categoryId\":16,\"id\":49,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:19:38');
INSERT INTO `tb_operation_log` VALUES (75, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n## 1、存储结构\\n\\n```c\\ntypedef int DataType;  // 数据类型\\ntypedef struct Node {\\n    DataType data;   // 结点数据\\n    struct Node *next; // 指向下一个结点的指针\\n} Node, *LinkList;\\n```\\n\\n## 2、基本功能\\n\\n+ 头插法创建单链表   **void CreateListHead(LinkList &head)**\\n+ 尾插法创建单链表     **void CreateListTail(LinkList &head)**\\n+ 获取指定位置的元素   **int GetElement(LinkList head, int i, DataType &e)**\\n+ 获取指定元素的位置   **int LocateElement(LinkList head, int e)**\\n+ 在指定位置插入元素  **int InsertList(LinkList head, int i, DataType e)**\\n+ 删除指定位置的元素   **int DeleteList(LinkList head, int i, DataType &e)**\\n+ 获取单链表的长度       **int LengthLinkList(LinkList head)**\\n+ 合并两个非递减的单链表  **void MergeList(LinkList La, LinkList Lb, LinkList &Lc)**\\n+ 销毁链表                      **void Destroy(LinkList &L)**\\n+ 遍历打印单链表中的所有元素   **void PrintList(LinkList head)**\\n\\n### 1、头插法创建单链表\\n\\n每次新增的结点能放在头结点后面的第1号位置，所以创建好的单链表中的元素的顺序是输入元素的逆序。\\n\\n```c\\n/**\\n * 头插法创建单链表，输入以-1结束\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next; // 新增的结点指向头结点的下一个结点\\n        head->next = p;  // 头结点指向新增的结点\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n```\\n\\n### 2、尾插法创建单链表\\n\\n每次新增的结点都放在单链表的尾部，所以顺序和输入顺序保持一致。\\n\\n```c\\n/**\\n * 尾插法创建单链表，输入以-1结束\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n```\\n\\n### 3、获取指定位置的元素  \\n\\n```c\\n/**\\n * 获取指定位置的元素\\n * @param head 指向单链表头结点的指针（头指针）\\n * @param i 位置\\n * @param e 用来存放对应位置的元素值\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) { // 依次后移，直至为空或到达位置\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空表示位置超过最大位置，j > i表示位置不合法(i < 1)\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n```\\n\\n### 4、获取指定元素的位置 \\n\\n```c\\n/**\\n * 获取某个元素的位置\\n * @param head 头指针\\n * @param e 元素\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) { // 挨个遍历，依次比较\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {  // 查找不到该元素\\n        return 0;\\n    }\\n    return j;\\n}\\n```\\n\\n### 5、在指定位置插入元素 \\n\\n```c\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head; // 从头结点开始\\n    int j = 1;\\n\\n    while (p && j < i) { // 找到插入位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空或i < 1，插入位置不合法\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN); // 创建新结点\\n    q->data = e;\\n    q->next = p->next; // 将新结点指向前一个结点的后一个结点\\n    p->next = q; // 前一个结点指向新结点\\n    // 执行上述两个操作后，达到的效果是新结点插入到了前一个结点的后面\\n}\\n```\\n\\n### 6、删除指定位置的元素  \\n\\n```c\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {  // 找到位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next; // 改变前一个结点的指向，使其指向删除结点的后一个结点\\n    free(s); \\n    return 1;\\n}\\n```\\n\\n### 7、获取单链表的长度      \\n\\n```c\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return 单链表的长度\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n```\\n\\n### 8、合并两个非递减的单链表 \\n\\n合并两个非递减的单链表，新链表仍然保持非递减\\n\\n```c\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n```\\n\\n### 9、销毁链表  \\n\\n```c\\n/**\\n * 销毁链表\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) { // 遍历所有结点，释放内存\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL; // L置为NULL\\n}\\n```\\n\\n### 10、遍历打印单链表\\n\\n```c\\n/**\\n * 遍历打印单链表的所有元素\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n```\\n\\n## 3、完整代码及测试\\n\\n```c\\n#include<iostream>\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\n#define LEN sizeof(Node)\\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n    DataType data;\\n    struct Node *next;\\n} Node, *LinkList;\\n\\n/**\\n * 头插法创建单链表\\n * @param head\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n\\n/**\\n * 尾插法创建单链表\\n * @param head\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n/**\\n * 获取指定位置的元素\\n * @param head 单链表头指针\\n * @param i 位置\\n * @param e 获取的元素赋值该参数\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n\\n/**\\n * 获取某个元素的位置\\n * @param head\\n * @param e\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {\\n        return 0;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN);\\n    q->data = e;\\n    q->next = p->next;\\n    p->next = q;\\n}\\n\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next;\\n    free(s);\\n    return 1;\\n}\\n\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n\\n/**\\n * 销毁链表\\n * @param L\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) {\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL;\\n}\\n\\n/**\\n * 遍历打印单链表的所有元素\\n * @param head\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    LinkList L;\\n\\n    printf(\\\"头插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListHead(L);\\n    PrintList(L);\\n\\n    printf(\\\"尾插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListTail(L);\\n    PrintList(L);\\n\\n    InsertList(L, 1, 100);\\n    printf(\\\"在1号位置插入100后，单链表如下：\\\\n\\\");\\n    PrintList(L);\\n\\n    DataType e;\\n    DeleteList(L, 1, e); \\n    printf(\\\"删除1号位置的元素，被删除的元素为：\\\\n\\\");\\n    printf(\\\"删除后的单链表为：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"单链表的长度为：%d\\\\n\\\", LengthLinkList(L));\\n    \\n    GetElement(L, 1, e);\\n    printf(\\\"1号位置的元素为：%d\\\\n\\\");\\n    \\n    printf(\\\"元素4在单链表中的位置为：%d\\\\n\\\", LocateElement(L, 4));\\n\\n\\tcout << endl;\\n    LinkList La, Lb, Lc;\\n    printf(\\\"尾插法创建单链表La：\\\\n\\\");\\n    CreateListTail(La);\\n    PrintList(La);\\n    printf(\\\"尾插法创建单链表Lb：\\\\n\\\");\\n    CreateListTail(Lb);\\n    PrintList(Lb);\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"合并单链表La和Lb后的新单链表Lc如下：\\\\n\\\");\\n    PrintList(Lc);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081022033553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\\n\\n**注意：**\\n\\n上述函数采用了 C++ 引用参数的写法，**LinkList &head**，C语言下不支持这种写法，需要在 C++ 环境下使用，即.cpp文件。**下面附上C语言的写法：**\\n\\n```c\\n/**\\n * LinkList 本身已经是结构体指针，参数再使用LinkList *的形式\\n * 可以理解为要想改变一个结构体指针，则需要取指针的指针。\\n * 类似于改变int a，则需要使用 int *a，这里要改变LinkList head，则需要使用LinkList *head\\n */\\nvoid CreatListTail(LinkList *head) {\\n    int x;\\n    LinkList *p, *q;\\n\\n    *head = (LinkList *) malloc(LEN);\\n    q = *head;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n\\n// 可以不传参，函数里面定义头指针，创建链表，然后把头指针返回，主函数用结构体指针接收即可\\nLinkList CreateListhead() {\\n    int x;\\n    LinkList *head, *p;\\n\\n    head = (LinkList *) malloc(LEN);\\n    head->next = NULL;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n    }\\n    return head;\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658155146.jpg\",\"articleTitle\":\"线性表的链式实现 - 单链表\",\"categoryId\":16,\"id\":49,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:19:58');
INSERT INTO `tb_operation_log` VALUES (76, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n### 1、存储结构\\n\\n```c\\n#define Stack_Init_Size 100\\n#define StackIncrement 10\\ntypedef int ElemType;\\ntypedef int Status;\\n\\n// 方式一（本文采取）\\ntypedef struct {\\n    ElemType *base; // 栈底指针\\n    ElemType *top; // 栈顶指针\\n    int stacksize; // 栈的最大容量\\n} SqStack;\\n\\n// 方式二\\ntypedef struct {\\n    int data[MaxSize];\\n    int top;\\n} SeqStack;\\n```\\n\\n### 2、函数列表\\n\\n+ ==Status InitStack(SqStack *S)==  初始化栈\\n+ `Status GetTopStack(SqStack *S, ElemType *e)`  获取栈顶元素，参数e存放栈顶元素的值\\n+ `Status PushStack(SqStack *S, ElemType e) `  进栈，将元素e入栈\\n+ `Status PopStack(SqStack *S, ElemType *e) `  出栈，出栈的元素存放在参数e中\\n+ `Status EmptyStack(SqStack *S)`  判断栈是否为空\\n+ `Status LengthStack(SqStack *S)`  获取栈的实际长度\\n+ `Status DestroyStack(SqStack *S)` 销毁栈\\n+ `Status StackTraverse(SqStack *S)` 遍历栈，打印每个元素\\n\\n### 3、完整代码\\n\\n```c\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define Stack_Init_Size 10 // 初始化栈的最大长度\\n#define StackIncrement 10 // 若栈最大空间不够时，需要增加的长度\\ntypedef int ElemType;\\ntypedef int Status;\\n\\ntypedef struct {\\n    ElemType *base; // 栈底指针\\n    ElemType *top; // 栈顶指针\\n    int stack_size; // 栈的最大长度\\n} SqStack;\\n\\n// 初始化栈\\nStatus InitStack(SqStack *S) {\\n    // 分配初始空间\\n    S->base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType));\\n    if (!S->base) {\\n        exit(0);\\n    }\\n    S->top = S->base; /// 栈顶与栈底相同\\n    S->stack_size = Stack_Init_Size; // 栈的最大长度等于初始长度\\n    return 1;\\n}\\n\\n// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可\\nStatus EmptyStack(SqStack *S) {\\n    return S->base == S->top;\\n}\\n\\n// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度\\nStatus LengthStack(SqStack *S) {\\n    if (S->top == S->base) {\\n        return 0;\\n    }\\n    return (Status) (S->top - S->base);\\n}\\n\\n// 获取栈顶的元素，参数e用来存放栈顶的元素\\nStatus GetTopStack(SqStack *S, ElemType *e) {\\n    if (S->top == S->base) {\\n        return 0;\\n    } \\n    *e = *(S->top - 1);\\n    return 1;\\n}\\n\\n// 进栈，参数e是要进栈的元素\\nStatus PushStack(SqStack *S, ElemType e) {\\n    // 若栈的最大长度不会够用时，重新开辟，增大长度\\n    if (S->top - S->base >= S->stack_size) {\\n        S->base = (ElemType *)realloc(S->base, (S->stack_size + StackIncrement) * sizeof(ElemType));\\n        if (!S->base) {\\n            return 0;\\n        }\\n        // 栈顶指针为栈底指针加上栈之前的最大长度\\n        S->top = S->base + S->stack_size;\\n        // 栈当前的最大长度等于栈之前的最大长度与增加的长度之和\\n        S->stack_size += StackIncrement;\\n    }\\n    *S->top++ = e; // 先赋值，后栈顶指针上移\\n    return 1;\\n}\\n\\n// 出栈，参数e用来存放出栈的元素\\nStatus PopStack(SqStack *S, ElemType *e) {\\n    if (S->base == S->top) {\\n        return 0;\\n    }\\n    *e = *--S->top; // 栈顶指针先下移，后赋值\\n    return 1;\\n}\\n\\n// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0\\nStatus DestroyStack(SqStack *S) {\\n    free(S->base);\\n    S->base = S->top = NULL;\\n    S->stack_size = 0;\\n    return 1;\\n}\\n\\n// 遍历栈，依次打印每个元素\\nStatus StackTraverse(SqStack *S) {\\n    ElemType *p;\\n\\n    if (S->top == S->base) {\\n        printf(\\\"Stack is NULL.\\\\n\\\");\\n        return 0;\\n    }\\n    p = S->top;\\n    // 由栈顶依次向下遍历\\n    while (p > S->base) {\\n        p--;\\n        printf(\\\"%d \\\", *p);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    return 1;\\n}\\n\\nint main() {\\n    SqStack q, *S;\\n    S = &q;\\n\\n    int i, n, e;\\n\\n    printf(\\\"Creat a NULL Stack :\\\\n\\\");\\n    InitStack(S);\\n\\n    printf(\\\"input the length of the Stack :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    for (i = 1; i <= n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        PushStack(S, e);\\n    }\\n    printf(\\\"Is the stack NULL?\\\\n\\\");\\n\\n    if (EmptyStack(S)) {\\n        printf(\\\"Yes!\\\\n\\\");\\n    } else {\\n        printf(\\\"No!\\\\n\\\");\\n    }\\n    printf(\\\"The length of stack is %d.\\\\n\\\", LengthStack(S));\\n\\n    printf(\\\"The stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    e = GetTopStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"input the data to the stack :\\\\n\\\");\\n    scanf(\\\"%d\\\", &e);\\n    PushStack(S, e);\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    printf(\\\"Delete the top data : \\\");\\n    e = PopStack(S, &e);\\n    printf(\\\"%d\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    StackTraverse(S);\\n\\n    printf(\\\"Destroy the stack :\\\\n\\\");\\n    DestroyStack(S);\\n    StackTraverse(S);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819094841609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658455779.jpeg\",\"articleTitle\":\"顺序栈基本操作的C语言实现\",\"categoryId\":16,\"id\":50,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[29]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:20:49');
INSERT INTO `tb_operation_log` VALUES (77, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[50],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:21:02');
INSERT INTO `tb_operation_log` VALUES (78, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[50]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:21:07');
INSERT INTO `tb_operation_log` VALUES (79, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n## 1、存储结构\\n\\n```c\\ntypedef int DataType;  // 数据类型\\ntypedef struct Node {\\n    DataType data;   // 结点数据\\n    struct Node *next; // 指向下一个结点的指针\\n} Node, *LinkList;\\n```\\n\\n## 2、基本功能\\n\\n+ 头插法创建单链表   **void CreateListHead(LinkList &head)**\\n+ 尾插法创建单链表     **void CreateListTail(LinkList &head)**\\n+ 获取指定位置的元素   **int GetElement(LinkList head, int i, DataType &e)**\\n+ 获取指定元素的位置   **int LocateElement(LinkList head, int e)**\\n+ 在指定位置插入元素  **int InsertList(LinkList head, int i, DataType e)**\\n+ 删除指定位置的元素   **int DeleteList(LinkList head, int i, DataType &e)**\\n+ 获取单链表的长度       **int LengthLinkList(LinkList head)**\\n+ 合并两个非递减的单链表  **void MergeList(LinkList La, LinkList Lb, LinkList &Lc)**\\n+ 销毁链表                      **void Destroy(LinkList &L)**\\n+ 遍历打印单链表中的所有元素   **void PrintList(LinkList head)**\\n\\n### 1、头插法创建单链表\\n\\n每次新增的结点能放在头结点后面的第1号位置，所以创建好的单链表中的元素的顺序是输入元素的逆序。\\n\\n```c\\n/**\\n * 头插法创建单链表，输入以-1结束\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next; // 新增的结点指向头结点的下一个结点\\n        head->next = p;  // 头结点指向新增的结点\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n```\\n\\n### 2、尾插法创建单链表\\n\\n每次新增的结点都放在单链表的尾部，所以顺序和输入顺序保持一致。\\n\\n```c\\n/**\\n * 尾插法创建单链表，输入以-1结束\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n```\\n\\n### 3、获取指定位置的元素  \\n\\n```c\\n/**\\n * 获取指定位置的元素\\n * @param head 指向单链表头结点的指针（头指针）\\n * @param i 位置\\n * @param e 用来存放对应位置的元素值\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) { // 依次后移，直至为空或到达位置\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空表示位置超过最大位置，j > i表示位置不合法(i < 1)\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n```\\n\\n### 4、获取指定元素的位置 \\n\\n```c\\n/**\\n * 获取某个元素的位置\\n * @param head 头指针\\n * @param e 元素\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) { // 挨个遍历，依次比较\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {  // 查找不到该元素\\n        return 0;\\n    }\\n    return j;\\n}\\n```\\n\\n### 5、在指定位置插入元素 \\n\\n```c\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head; // 从头结点开始\\n    int j = 1;\\n\\n    while (p && j < i) { // 找到插入位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) { // p为空或i < 1，插入位置不合法\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN); // 创建新结点\\n    q->data = e;\\n    q->next = p->next; // 将新结点指向前一个结点的后一个结点\\n    p->next = q; // 前一个结点指向新结点\\n    // 执行上述两个操作后，达到的效果是新结点插入到了前一个结点的后面\\n}\\n```\\n\\n### 6、删除指定位置的元素  \\n\\n```c\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {  // 找到位置的前一个结点\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next; // 改变前一个结点的指向，使其指向删除结点的后一个结点\\n    free(s); \\n    return 1;\\n}\\n```\\n\\n### 7、获取单链表的长度      \\n\\n```c\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return 单链表的长度\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n```\\n\\n### 8、合并两个非递减的单链表 \\n\\n合并两个非递减的单链表，新链表仍然保持非递减\\n\\n```c\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n```\\n\\n### 9、销毁链表  \\n\\n```c\\n/**\\n * 销毁链表\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) { // 遍历所有结点，释放内存\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL; // L置为NULL\\n}\\n```\\n\\n### 10、遍历打印单链表\\n\\n```c\\n/**\\n * 遍历打印单链表的所有元素\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n```\\n\\n## 3、完整代码及测试\\n\\n```c\\n#include<iostream>\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\n#define LEN sizeof(Node)\\n\\ntypedef int DataType;\\n\\ntypedef struct Node {\\n    DataType data;\\n    struct Node *next;\\n} Node, *LinkList;\\n\\n/**\\n * 头插法创建单链表\\n * @param head\\n */\\nvoid CreateListHead(LinkList &head) {\\n    DataType x;\\n    LinkList p;\\n\\n    head = (LinkList)malloc(LEN);\\n    head->next = NULL;\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n}\\n\\n/**\\n * 尾插法创建单链表\\n * @param head\\n */\\nvoid CreateListTail(LinkList &head) {\\n    LinkList p, q;\\n    DataType x;\\n\\n    head = (LinkList)malloc(LEN);\\n    q = head;\\n  \\tscanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList)malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n/**\\n * 获取指定位置的元素\\n * @param head 单链表头指针\\n * @param i 位置\\n * @param e 获取的元素赋值该参数\\n * @return 0：获取失败；1：获取成功\\n */\\nint GetElement(LinkList head, int i, DataType &e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    e = p->data;\\n    return 1;\\n}\\n\\n/**\\n * 获取某个元素的位置\\n * @param head\\n * @param e\\n * @return 元素的位置\\n */\\nint LocateElement(LinkList head, int e) {\\n    LinkList p = head->next;\\n    int j = 1;\\n\\n    while (p && p->data != e) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p) {\\n        return 0;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 在单链表插入元素到位置i\\n * @param head 单链表的头指针\\n * @param i 插入位置\\n * @param e 插入元素\\n * @return 1：插入成功，0：插入失败\\n */\\nint InsertList(LinkList head, int i, DataType e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList q = (LinkList)malloc(LEN);\\n    q->data = e;\\n    q->next = p->next;\\n    p->next = q;\\n}\\n\\n/**\\n * 删除指定位置的元素\\n * @param head\\n * @param i 位置\\n * @param e 被删除的元素的值存放在e中\\n * @return 1：删除成功，0：删除失败\\n */\\nint DeleteList(LinkList head, int i, DataType &e) {\\n    LinkList p = head;\\n    int j = 1;\\n\\n    while (p && j < i) {\\n        p = p->next;\\n        j++;\\n    }\\n    if (!p || j > i) {\\n        return 0;\\n    }\\n    LinkList s = p->next;\\n    e = s->data;\\n    p->next = s->next;\\n    free(s);\\n    return 1;\\n}\\n\\n/**\\n * 获取单链表的长度\\n * @param head\\n * @return\\n */\\nint LengthLinkList(LinkList head) {\\n    LinkList p = head->next;\\n    int count = 0;\\n\\n    while (p) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n/**\\n * 合并两个非递减的单链表，新的链表仍然非递减\\n * @param La\\n * @param Lb\\n * @param Lc\\n */\\nvoid MergeList(LinkList La, LinkList Lb, LinkList &Lc) {\\n    LinkList pa, pb, pc;\\n\\n    pa = La->next;\\n    pb = Lb->next;\\n    pc = Lc = (LinkList)malloc(LEN);\\n\\n    while (pa && pb) {\\n        if (pa->data <= pb->data) {\\n            pc->next = pa;\\n            pc = pa;\\n            pa = pa->next;\\n        } else {\\n            pc->next = pb;\\n            pc = pb;\\n            pb = pb->next;\\n        }\\n    }\\n    pc->next = pa ? pa : pb;\\n    free(Lb);\\n}\\n\\n/**\\n * 销毁链表\\n * @param L\\n */\\nvoid Destroy(LinkList &L) {\\n    LinkList p, q;\\n    p = L;\\n    while (p) {\\n        q = p;\\n        p = p->next;\\n        free(q);\\n    }\\n    L = NULL;\\n}\\n\\n/**\\n * 遍历打印单链表的所有元素\\n * @param head\\n */\\nvoid PrintList(LinkList head) {\\n    LinkList p = head->next;\\n\\n    if (p == NULL) {\\n        cout << \\\"List is NULL!\\\" <<endl;\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    LinkList L;\\n\\n    printf(\\\"头插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListHead(L);\\n    PrintList(L);\\n\\n    printf(\\\"尾插法创建单链表：（输入以-1结束）\\\\n\\\");\\n    CreateListTail(L);\\n    PrintList(L);\\n\\n    InsertList(L, 1, 100);\\n    printf(\\\"在1号位置插入100后，单链表如下：\\\\n\\\");\\n    PrintList(L);\\n\\n    DataType e;\\n    DeleteList(L, 1, e); \\n    printf(\\\"删除1号位置的元素，被删除的元素为：\\\\n\\\");\\n    printf(\\\"删除后的单链表为：\\\\n\\\"); \\n    PrintList(L);\\n\\n    printf(\\\"单链表的长度为：%d\\\\n\\\", LengthLinkList(L));\\n    \\n    GetElement(L, 1, e);\\n    printf(\\\"1号位置的元素为：%d\\\\n\\\");\\n    \\n    printf(\\\"元素4在单链表中的位置为：%d\\\\n\\\", LocateElement(L, 4));\\n\\n\\tcout << endl;\\n    LinkList La, Lb, Lc;\\n    printf(\\\"尾插法创建单链表La：\\\\n\\\");\\n    CreateListTail(La);\\n    PrintList(La);\\n    printf(\\\"尾插法创建单链表Lb：\\\\n\\\");\\n    CreateListTail(Lb);\\n    PrintList(Lb);\\n    MergeList(La, Lb, Lc);\\n    printf(\\\"合并单链表La和Lb后的新单链表Lc如下：\\\\n\\\");\\n    PrintList(Lc);\\n\\n    return 0;\\n}\\n```\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081022033553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\\n\\n**注意：**\\n\\n上述函数采用了 C++ 引用参数的写法，**LinkList &head**，C语言下不支持这种写法，需要在 C++ 环境下使用，即.cpp文件。**下面附上C语言的写法：**\\n\\n```c\\n/**\\n * LinkList 本身已经是结构体指针，参数再使用LinkList *的形式\\n * 可以理解为要想改变一个结构体指针，则需要取指针的指针。\\n * 类似于改变int a，则需要使用 int *a，这里要改变LinkList head，则需要使用LinkList *head\\n */\\nvoid CreatListTail(LinkList *head) {\\n    int x;\\n    LinkList *p, *q;\\n\\n    *head = (LinkList *) malloc(LEN);\\n    q = *head;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        q->next = p;\\n        q = p;\\n        scanf(\\\"%d\\\", &x);\\n    }\\n    q->next = NULL;\\n}\\n\\n\\n// 可以不传参，函数里面定义头指针，创建链表，然后把头指针返回，主函数用结构体指针接收即可\\nLinkList CreateListhead() {\\n    int x;\\n    LinkList *head, *p;\\n\\n    head = (LinkList *) malloc(LEN);\\n    head->next = NULL;\\n\\n    scanf(\\\"%d\\\", &x);\\n    while (x != -1) {\\n        p = (LinkList *) malloc(LEN);\\n        p->data = x;\\n        p->next = head->next;\\n        head->next = p;\\n    }\\n    return head;\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620658155146.jpg\",\"articleTitle\":\"单链表基本操作的c语言实现\",\"categoryId\":16,\"id\":49,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:25:19');
INSERT INTO `tb_operation_log` VALUES (80, '评论模块', '修改', '/admin/comments', 'top.bravecoder.blog.controller.CommentController.deleteComment', '删除或恢复评论', '[{\"idList\":[271,270,269,268],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:59:17');
INSERT INTO `tb_operation_log` VALUES (81, '评论模块', '删除', '/admin/comments', 'top.bravecoder.blog.controller.CommentController.deleteComments', '物理删除评论', '[[271,270,269,268]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:59:20');
INSERT INTO `tb_operation_log` VALUES (82, '留言模块', '删除', '/admin/messages', 'top.bravecoder.blog.controller.MessageController.deleteMessages', '删除留言', '[[3435]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.232', '安徽省合肥市 联通', '2021-05-11 15:59:26');
INSERT INTO `tb_operation_log` VALUES (83, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```c\\n#include<stdio.h>\\n#include<stdlib.h>\\n\\n// 链表中的结点结构 \\ntypedef struct Node {\\n    int data;  // 数据元素 \\n    struct Node *next; // 指向下一个结点 \\n} StackNode, *PStackNode;\\n\\ntypedef struct {\\n    PStackNode top; // 指向栈顶结点 \\n    int count; //  栈的大小 \\n} LinkStack, *PLinkStack;\\n\\n// 初始化链栈，栈顶指针置为NULL，栈的大小置为0 \\nPLinkStack Init_LinkStack() {\\n    PLinkStack S;\\n\\n    S = (PLinkStack)malloc(sizeof(LinkStack));\\n    if (!S) {\\n        return NULL;\\n    }\\n    S->top = NULL;\\n    S->count = 0;\\n\\n    return S;\\n}\\n\\n// 判断栈是否为空 \\nint Empty_LinkStack(PLinkStack S) {\\n    return (S->top == NULL);\\n}\\n\\n// 入栈，参数e为入栈的元素 \\nvoid Push_LinkStack(PLinkStack S, int e) {\\n    PStackNode p;\\n\\n    p = (PStackNode)malloc(sizeof(StackNode)); // 创建新的结点 \\n    if (!p) {\\n        return;\\n    }\\n    p->data = e; // 赋值元素e \\n    p->next = S->top; // 新的结点next指向栈顶结点 \\n    S->top = p; // 更新栈顶结点为新的结点 \\n    S->count++; // 栈的大小加一 \\n}\\n\\n// 出栈，出栈的元素存放在参数e中 \\nint Pop_LinkStack(PLinkStack S, int *e) {\\n    PStackNode p;\\n\\t\\n    if (Empty_LinkStack(S)) { // 判断栈是否为空 \\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data; // 将栈顶元素赋值给参数e \\n    p = S->top; // 临时存储久的栈顶结点 \\n    S->top = S->top->next; // 将栈顶结点更新为久的栈顶结点的下一个结点 \\n    free(p); // 释放久的栈顶结点 \\n    S->count--; // 栈的大小减一 \\n\\n    return 1;\\n}\\n\\n// 获取栈顶的元素，存放在参数e中 \\nint GetTop_LinkStack(PLinkStack S, int *e) {\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data;\\n\\n    return 1;\\n}\\n\\n// 遍历打印栈的所有元素 \\nvoid Print_LinkStack(PLinkStack S) {\\n    PStackNode p;\\n\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return;\\n    }\\n    p = S->top;\\n    while (p) {\\n        printf(\\\"%d \\\", p->data);\\n        p = p->next;\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 清空栈 \\nvoid Clear_LinkStack(PLinkStack S) {\\n    if (Empty_LinkStack(S)) {\\n        return;\\n    }\\n    while (S->count) {\\n        PStackNode p = S->top;\\n        S->top = p->next;\\n        free(p);\\n        S->count--;\\n    }\\n}\\n\\n// 返回栈的大小 \\nint Length_LinkStack(PLinkStack S) {\\n    if (!S) {\\n        return 0;\\n    }\\n    return S->count;\\n}\\n\\nint main() {\\n    PLinkStack S;\\n    int n, e, i;\\n\\n    printf(\\\"input the number of datas :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    S = Init_LinkStack();\\n    printf(\\\"input datas :\\\\n\\\");\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        Push_LinkStack(S, e);\\n    }\\n    printf(\\\"The Stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    Pop_LinkStack(S, &e);\\n    printf(\\\"The pop data is %d.\\\\n\\\", e);\\n\\n    GetTop_LinkStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The length of stack is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    printf(\\\"Clear the stack :\\\\n\\\");\\n    Clear_LinkStack(S);\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The new stack length is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819225512569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\"\",\"articleTitle\":\"链栈基本操作的C语言实现\",\"categoryId\":16,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.41', '安徽省合肥市 联通', '2021-05-11 23:04:08');
INSERT INTO `tb_operation_log` VALUES (84, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"栈\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.41', '安徽省合肥市 联通', '2021-05-11 23:04:24');
INSERT INTO `tb_operation_log` VALUES (85, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"链栈\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.41', '安徽省合肥市 联通', '2021-05-11 23:04:28');
INSERT INTO `tb_operation_log` VALUES (86, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```c\\n#include<stdio.h>\\n#include<stdlib.h>\\n\\n// 链表中的结点结构 \\ntypedef struct Node {\\n    int data;  // 数据元素 \\n    struct Node *next; // 指向下一个结点 \\n} StackNode, *PStackNode;\\n\\ntypedef struct {\\n    PStackNode top; // 指向栈顶结点 \\n    int count; //  栈的大小 \\n} LinkStack, *PLinkStack;\\n\\n// 初始化链栈，栈顶指针置为NULL，栈的大小置为0 \\nPLinkStack Init_LinkStack() {\\n    PLinkStack S;\\n\\n    S = (PLinkStack)malloc(sizeof(LinkStack));\\n    if (!S) {\\n        return NULL;\\n    }\\n    S->top = NULL;\\n    S->count = 0;\\n\\n    return S;\\n}\\n\\n// 判断栈是否为空 \\nint Empty_LinkStack(PLinkStack S) {\\n    return (S->top == NULL);\\n}\\n\\n// 入栈，参数e为入栈的元素 \\nvoid Push_LinkStack(PLinkStack S, int e) {\\n    PStackNode p;\\n\\n    p = (PStackNode)malloc(sizeof(StackNode)); // 创建新的结点 \\n    if (!p) {\\n        return;\\n    }\\n    p->data = e; // 赋值元素e \\n    p->next = S->top; // 新的结点next指向栈顶结点 \\n    S->top = p; // 更新栈顶结点为新的结点 \\n    S->count++; // 栈的大小加一 \\n}\\n\\n// 出栈，出栈的元素存放在参数e中 \\nint Pop_LinkStack(PLinkStack S, int *e) {\\n    PStackNode p;\\n\\t\\n    if (Empty_LinkStack(S)) { // 判断栈是否为空 \\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data; // 将栈顶元素赋值给参数e \\n    p = S->top; // 临时存储久的栈顶结点 \\n    S->top = S->top->next; // 将栈顶结点更新为久的栈顶结点的下一个结点 \\n    free(p); // 释放久的栈顶结点 \\n    S->count--; // 栈的大小减一 \\n\\n    return 1;\\n}\\n\\n// 获取栈顶的元素，存放在参数e中 \\nint GetTop_LinkStack(PLinkStack S, int *e) {\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data;\\n\\n    return 1;\\n}\\n\\n// 遍历打印栈的所有元素 \\nvoid Print_LinkStack(PLinkStack S) {\\n    PStackNode p;\\n\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return;\\n    }\\n    p = S->top;\\n    while (p) {\\n        printf(\\\"%d \\\", p->data);\\n        p = p->next;\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 清空栈 \\nvoid Clear_LinkStack(PLinkStack S) {\\n    if (Empty_LinkStack(S)) {\\n        return;\\n    }\\n    while (S->count) {\\n        PStackNode p = S->top;\\n        S->top = p->next;\\n        free(p);\\n        S->count--;\\n    }\\n}\\n\\n// 返回栈的大小 \\nint Length_LinkStack(PLinkStack S) {\\n    if (!S) {\\n        return 0;\\n    }\\n    return S->count;\\n}\\n\\nint main() {\\n    PLinkStack S;\\n    int n, e, i;\\n\\n    printf(\\\"input the number of datas :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    S = Init_LinkStack();\\n    printf(\\\"input datas :\\\\n\\\");\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        Push_LinkStack(S, e);\\n    }\\n    printf(\\\"The Stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    Pop_LinkStack(S, &e);\\n    printf(\\\"The pop data is %d.\\\\n\\\", e);\\n\\n    GetTop_LinkStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The length of stack is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    printf(\\\"Clear the stack :\\\\n\\\");\\n    Clear_LinkStack(S);\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The new stack length is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819225512569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\"\",\"articleTitle\":\"链栈基本操作的C语言实现\",\"categoryId\":16,\"id\":52,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.41', '安徽省合肥市 联通', '2021-05-11 23:04:38');
INSERT INTO `tb_operation_log` VALUES (87, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```c\\n#include<stdio.h>\\n#include<stdlib.h>\\n\\n// 链表中的结点结构 \\ntypedef struct Node {\\n    int data;  // 数据元素 \\n    struct Node *next; // 指向下一个结点 \\n} StackNode, *PStackNode;\\n\\ntypedef struct {\\n    PStackNode top; // 指向栈顶结点 \\n    int count; //  栈的大小 \\n} LinkStack, *PLinkStack;\\n\\n// 初始化链栈，栈顶指针置为NULL，栈的大小置为0 \\nPLinkStack Init_LinkStack() {\\n    PLinkStack S;\\n\\n    S = (PLinkStack)malloc(sizeof(LinkStack));\\n    if (!S) {\\n        return NULL;\\n    }\\n    S->top = NULL;\\n    S->count = 0;\\n\\n    return S;\\n}\\n\\n// 判断栈是否为空 \\nint Empty_LinkStack(PLinkStack S) {\\n    return (S->top == NULL);\\n}\\n\\n// 入栈，参数e为入栈的元素 \\nvoid Push_LinkStack(PLinkStack S, int e) {\\n    PStackNode p;\\n\\n    p = (PStackNode)malloc(sizeof(StackNode)); // 创建新的结点 \\n    if (!p) {\\n        return;\\n    }\\n    p->data = e; // 赋值元素e \\n    p->next = S->top; // 新的结点next指向栈顶结点 \\n    S->top = p; // 更新栈顶结点为新的结点 \\n    S->count++; // 栈的大小加一 \\n}\\n\\n// 出栈，出栈的元素存放在参数e中 \\nint Pop_LinkStack(PLinkStack S, int *e) {\\n    PStackNode p;\\n\\t\\n    if (Empty_LinkStack(S)) { // 判断栈是否为空 \\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data; // 将栈顶元素赋值给参数e \\n    p = S->top; // 临时存储久的栈顶结点 \\n    S->top = S->top->next; // 将栈顶结点更新为久的栈顶结点的下一个结点 \\n    free(p); // 释放久的栈顶结点 \\n    S->count--; // 栈的大小减一 \\n\\n    return 1;\\n}\\n\\n// 获取栈顶的元素，存放在参数e中 \\nint GetTop_LinkStack(PLinkStack S, int *e) {\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data;\\n\\n    return 1;\\n}\\n\\n// 遍历打印栈的所有元素 \\nvoid Print_LinkStack(PLinkStack S) {\\n    PStackNode p;\\n\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return;\\n    }\\n    p = S->top;\\n    while (p) {\\n        printf(\\\"%d \\\", p->data);\\n        p = p->next;\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 清空栈 \\nvoid Clear_LinkStack(PLinkStack S) {\\n    if (Empty_LinkStack(S)) {\\n        return;\\n    }\\n    while (S->count) {\\n        PStackNode p = S->top;\\n        S->top = p->next;\\n        free(p);\\n        S->count--;\\n    }\\n}\\n\\n// 返回栈的大小 \\nint Length_LinkStack(PLinkStack S) {\\n    if (!S) {\\n        return 0;\\n    }\\n    return S->count;\\n}\\n\\nint main() {\\n    PLinkStack S;\\n    int n, e, i;\\n\\n    printf(\\\"input the number of datas :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    S = Init_LinkStack();\\n    printf(\\\"input datas :\\\\n\\\");\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        Push_LinkStack(S, e);\\n    }\\n    printf(\\\"The Stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    Pop_LinkStack(S, &e);\\n    printf(\\\"The pop data is %d.\\\\n\\\", e);\\n\\n    GetTop_LinkStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The length of stack is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    printf(\\\"Clear the stack :\\\\n\\\");\\n    Clear_LinkStack(S);\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The new stack length is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819225512569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\"\",\"articleTitle\":\"链栈基本操作的C语言实现\",\"categoryId\":16,\"id\":52,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.41', '安徽省合肥市 联通', '2021-05-11 23:04:38');
INSERT INTO `tb_operation_log` VALUES (88, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```c\\n#include<stdio.h>\\n#include<stdlib.h>\\n\\n// 链表中的结点结构 \\ntypedef struct Node {\\n    int data;  // 数据元素 \\n    struct Node *next; // 指向下一个结点 \\n} StackNode, *PStackNode;\\n\\ntypedef struct {\\n    PStackNode top; // 指向栈顶结点 \\n    int count; //  栈的大小 \\n} LinkStack, *PLinkStack;\\n\\n// 初始化链栈，栈顶指针置为NULL，栈的大小置为0 \\nPLinkStack Init_LinkStack() {\\n    PLinkStack S;\\n\\n    S = (PLinkStack)malloc(sizeof(LinkStack));\\n    if (!S) {\\n        return NULL;\\n    }\\n    S->top = NULL;\\n    S->count = 0;\\n\\n    return S;\\n}\\n\\n// 判断栈是否为空 \\nint Empty_LinkStack(PLinkStack S) {\\n    return (S->top == NULL);\\n}\\n\\n// 入栈，参数e为入栈的元素 \\nvoid Push_LinkStack(PLinkStack S, int e) {\\n    PStackNode p;\\n\\n    p = (PStackNode)malloc(sizeof(StackNode)); // 创建新的结点 \\n    if (!p) {\\n        return;\\n    }\\n    p->data = e; // 赋值元素e \\n    p->next = S->top; // 新的结点next指向栈顶结点 \\n    S->top = p; // 更新栈顶结点为新的结点 \\n    S->count++; // 栈的大小加一 \\n}\\n\\n// 出栈，出栈的元素存放在参数e中 \\nint Pop_LinkStack(PLinkStack S, int *e) {\\n    PStackNode p;\\n\\t\\n    if (Empty_LinkStack(S)) { // 判断栈是否为空 \\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data; // 将栈顶元素赋值给参数e \\n    p = S->top; // 临时存储久的栈顶结点 \\n    S->top = S->top->next; // 将栈顶结点更新为久的栈顶结点的下一个结点 \\n    free(p); // 释放久的栈顶结点 \\n    S->count--; // 栈的大小减一 \\n\\n    return 1;\\n}\\n\\n// 获取栈顶的元素，存放在参数e中 \\nint GetTop_LinkStack(PLinkStack S, int *e) {\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = S->top->data;\\n\\n    return 1;\\n}\\n\\n// 遍历打印栈的所有元素 \\nvoid Print_LinkStack(PLinkStack S) {\\n    PStackNode p;\\n\\n    if (Empty_LinkStack(S)) {\\n        printf(\\\"Stack NULL!\\\\n\\\");\\n        return;\\n    }\\n    p = S->top;\\n    while (p) {\\n        printf(\\\"%d \\\", p->data);\\n        p = p->next;\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// 清空栈 \\nvoid Clear_LinkStack(PLinkStack S) {\\n    if (Empty_LinkStack(S)) {\\n        return;\\n    }\\n    while (S->count) {\\n        PStackNode p = S->top;\\n        S->top = p->next;\\n        free(p);\\n        S->count--;\\n    }\\n}\\n\\n// 返回栈的大小 \\nint Length_LinkStack(PLinkStack S) {\\n    if (!S) {\\n        return 0;\\n    }\\n    return S->count;\\n}\\n\\nint main() {\\n    PLinkStack S;\\n    int n, e, i;\\n\\n    printf(\\\"input the number of datas :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    S = Init_LinkStack();\\n    printf(\\\"input datas :\\\\n\\\");\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        Push_LinkStack(S, e);\\n    }\\n    printf(\\\"The Stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    Pop_LinkStack(S, &e);\\n    printf(\\\"The pop data is %d.\\\\n\\\", e);\\n\\n    GetTop_LinkStack(S, &e);\\n    printf(\\\"The top data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"The new stack is :\\\\n\\\");\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The length of stack is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    printf(\\\"Clear the stack :\\\\n\\\");\\n    Clear_LinkStack(S);\\n    Print_LinkStack(S);\\n\\n    printf(\\\"The new stack length is %d.\\\\n\\\", Length_LinkStack(S));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200819225512569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620745608171.jpg\",\"articleTitle\":\"链栈基本操作的C语言实现\",\"categoryId\":16,\"id\":52,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[31]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.41', '安徽省合肥市 联通', '2021-05-11 23:06:53');
INSERT INTO `tb_operation_log` VALUES (89, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [问题 A: 数7](https://acm.webturing.com/problem.php?cid=1323&pid=0&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n求整数序列A 中位置L 到R中间一共有多少个7，（每一个位上的7和能被7整除的次数）    \\n\\n**输入**\\n\\n第一行是T(T<=50)\\n然后是T行 L R (L<R<1e5)\\n\\n**输出**\\n\\n输出7的个数\\n\\n**样例输入**\\n\\n```c++\\n2\\n1 10\\n47 50\\n```\\n\\n**样例输出**\\n\\n```c++\\n2\\n3\\n```\\n\\n**提示**\\n\\n第二组数据解释  47 中含有一个7， 49含有2个7 所以输出3\\n\\n**题解**：直接暴力求解即可。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint count7(int x) {\\n\\tint y = x, ans = 0;\\n\\twhile (x != 0) {\\n\\t\\tif (x%10 == 7) {\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\tx /= 10;\\n\\t}\\n\\twhile (y % 7 == 0) {\\n\\t\\tans++;\\n\\t\\ty /= 7;\\n\\t}\\n\\treturn ans;\\n}\\n\\nint main() {\\n\\tint T, L, R;\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tscanf(\\\"%d%d\\\", &L, &R);\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = L; i <= R; i++) {\\n\\t\\t\\tsum += count7(i);\\n\\t\\t}\\t\\n\\t\\tprintf(\\\"%d\\\\n\\\", sum);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 B: 编译错误](https://acm.webturing.com/problem.php?cid=1323&pid=1&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n​ 在程序员编写程序的时候，通常会引用其他文件，而引用的文件也会引用其它的头文件。但是出现循环引用的现象编译时便会报错。例如A引用了B，B引用了C，C引用了A，那么就产生了循环引用（Circular reference）。考虑另外一个情况，A引用了B和C，B引用D，C引用D，虽然D被引用了两次，但是没有出现循环引用 。\\n\\n**输入**\\n\\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是一个整数n，代表有多少个引用关系。接下来n行每行有2个字符串a,b，用空格分隔，代表a引用了b。其中T<=50, n<=10^5，每个字符串的长度不超过100。\\n\\n**输出**\\n\\n​ 共T行。若不会产生编译错误则输出Passed，否则输出Failed。\\n\\n**样例输入**\\n\\n```c++\\n2\\n8\\nclient.cpp client.h\\nclient.h server.h\\nserver.cpp server.h\\nserver.h common.h\\nclient.h common.h\\ncommon.cpp common.h\\ncommon.h gtest.h\\ncommon.h glog.h\\n4\\nwork.cpp client.cpp\\nclient.cpp server.cpp\\nserver.cpp adhoc.cpp\\nadhoc.cpp work.cpp\\n```\\n\\n**样例输出**\\n\\n```c++\\nPassed\\nFailed\\n```\\n\\n**解题思路**：利用拓扑排序进行求解，若能够进行拓扑排序则说明不会出现编译错误，否则说明出现了循环应用。为了方便使用拓扑排序，先对字符串进行处理，将每个字符串分配唯一的序号。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nvector<int> g[maxn]; // 图\\nint degree[maxn], n, T, m, cnt; // degree入度\\nmap<string, int> mp; // 存储字符串及其序号 \\nchar a[50], b[50];\\n\\n// 拓扑排序\\nbool topoSort() {\\t\\t\\t\\t\\n\\tcnt = 0;\\n\\tqueue<int> q;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (!degree[i])\\n\\t\\t\\tq.push(i);\\n\\t}\\n\\twhile (!q.empty()) {\\n\\t\\tint x = q.front();\\n\\t\\tq.pop();\\n\\t\\tcnt++;\\n\\t\\tfor (int i = 0; i < g[x].size(); i++) {\\n\\t\\t\\tint t = g[x][i];\\n\\t\\t\\tdegree[t]--;\\n\\t\\t\\tif (!degree[t])\\n\\t\\t\\t\\tq.push(t);\\n\\t\\t}\\n\\t}\\n\\tif (cnt == n)\\n\\t\\treturn 1;\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) { \\n\\t\\tint total = 0, u, v; // 利用total为字符串分配序号，u，v是对应字符串的序号 \\n\\t\\tmp.clear();\\n\\t\\tmemset(degree, 0, sizeof(degree));\\n\\t\\tscanf(\\\"%d\\\", &n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tg[i].clear();\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%s%s\\\", a, b);\\n\\t\\t\\t// 判断 a 是否已经存在 \\n\\t\\t\\tif (mp.find(a) == mp.end()) {\\n\\t\\t\\t\\t// 不存在，存入 map，分配序号 \\n\\t\\t\\t\\tmp.insert(pair<string,int>(a, ++total));\\n\\t\\t\\t\\t// 获取该字符串对应的序号 \\n\\t\\t\\t\\tu = total;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tu = mp[a];\\n\\t\\t\\t}\\n\\t\\t\\t// 判断 b 是否已经存在 \\n\\t\\t\\tif (mp.find(b) == mp.end()) {\\n\\t\\t\\t\\tmp.insert(pair<string,int>(b, ++total));\\n\\t\\t\\t\\tv = total;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tv = mp[b];\\t\\n\\t\\t\\t}\\n\\t\\t\\t// 存入图中 \\n\\t\\t\\tg[u].push_back(v);\\n\\t\\t\\tdegree[v]++;\\n\\t\\t}\\n\\t\\t// 拓扑排序判断 \\n\\t\\tif (topoSort()) {\\n\\t\\t\\tprintf(\\\"Passed\\\\n\\\");\\n\\t\\t} else {\\n\\t\\t\\tprintf(\\\"Failed\\\\n\\\");\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 C: 做操的时候要排好队](https://acm.webturing.com/problem.php?cid=1323&pid=2&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n同学们在做早操时，应该按照身高从低到高排好队。但是总是有人不好好排队，老师在审查时会对没有排好的队伍扣除一定的分数。扣的分数被定义为，找到三个人Ai,Aj,Ak，其中i<j<k，分数为max(0,(Ai-Aj))+max(0,(Aj-Ak))。找到一组i,j,k使这个分数最大即是扣除的分数。\\n\\n**输入**\\n\\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是一个整数n，代表有一共有多少个人。第二行共有n个整数，代表n个人的身高。其中1<=T<=50,3<=n<=10^6 每个数的大小不超过1000。\\n\\n**输出**\\n​ 共T行。扣除的分数。\\n\\n**样例输入**\\n\\n```c++\\n2\\n4\\n150 160 170 180\\n4\\n160 150 170 180\\n```\\n\\n**样例输出**\\n\\n```c++\\n0\\n10\\n```\\n\\n**题解：**\\n\\n该题是寻找一个 i , j , k 满足（i < j < k）但 i , j , k 并不一定连续,如果我们枚举中间数 j , 从 2 到 n - 2 , 对于每一次枚举，我们都需要对 i，k 分别枚举，时间复杂度为 **O(n2),** 肯定不能通过。我们其实在枚举过程中重复了很多计算，对于每一个 j, 我们的目的是寻找 i < j 的 a[i] 最大值，k > j 的 a[k] 最小值。\\n\\n​ 我们可以预先处理，用两个数组 maxx[i], minx[i],  maxx[i] 表示i之前 a[i] 的最大值（不包括 a[i]）, minx[i] 表示以 i 之后a[i] 的最小值。然后我们直接枚举 max(maxx[i] - a[i], 0) + max(a[i] - minx[i])，时间复杂度为 **O(n);**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1e6 + 5;\\nint T, n;\\nint a[maxn], minx[maxn], maxx[maxn];\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tscanf(\\\"%d\\\", &n);\\n\\t\\ta[0] = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tmaxx[1] = a[1];\\n        // i 之前的最大值\\n\\t\\tfor (int i = 2; i <= n - 1; i++) {\\n\\t\\t\\tmaxx[i] = max(maxx[i-1], a[i-1]);\\n\\t\\t}\\n\\t\\tminx[n] = a[n];\\n        // i 之后的最小值\\n\\t\\tfor (int i = n - 1; i >= 2; i--) {\\n\\t\\t\\tminx[i] = min(a[i+1], minx[i+1]);\\n\\t\\t}\\n\\t\\tint res = 0;\\n        // 最后结果\\n\\t\\tfor (int i = 2; i <= n - 1; i++) {\\n\\t\\t\\tres = max(res, max(0, maxx[i] - a[i]) + max(0, a[i] - minx[i]));\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", res);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 D: 判重](https://acm.webturing.com/problem.php?cid=1323&pid=3&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n小七初始有n个数的样本集。现在又新加了m个数，他想知道这m个数是否已经在这n个数之中了。但是他判断是否有重复的方式和常人有些不同。对于样本集内的任意一个数x，他先将x二进制的第2, 5, 7, 10, 13, 14, 17, 18位取反，生成新的8个数。例如x是7（00111），那么第一个数就是5（00101），第二个数是23（10111）…依次类推。然后将他表格上这8个数的位置全部变为1（初始整个表格全部为0）。判断重复时，若一个数x产生的8个数，在表格内全部为1，就认为这个数x和样本集内的数有重复，否则认为没有重复\\n\\n**输入**\\n\\n输入T，代表T组数据。每组数据初始输入n, m。代表n个样本以及m个需要判断的数。接下来两行，第一行是n个样本，第二行m个需要判断的数，样本在前。对于这m个数，每个数输出yes 或者 no。m组数据相互独立，即这m个数都不会新加入到样本集内。其中T<=50 ,n,m<1e5 。\\n\\n**输出**\\n\\n输出一行，共m个字符串，重复输出yes，否则输出no，空格隔开\\n\\n**样例输入**\\n\\n```c++\\n1\\n2 2\\n2 1\\n3 2\\n```\\n\\n**样例输出**\\n\\n```c++\\nno yes\\n```\\n\\n**解题思路：** 利用 STL 的 set 进行判重，将每个数按位异或放进 set 中，判重时，查询对应的数在不咋 set 中即可。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint a[] = {2, 5, 7, 10, 13, 14, 17, 18};\\nint T, n, m;\\nset<int> s;\\n\\nint main() {\\n\\tint x;\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\ts.clear();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &x);\\n\\t\\t\\tfor (int j = 0; j < 8; j++) {\\n                // 按位取反，1^1 = 0, 1^0 = 1\\n\\t\\t\\t\\tint y = x^(1 << (a[j] - 1));\\n                // 存进 set \\n\\t\\t\\t\\ts.insert(y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &x);\\n\\t\\t\\tint flag = 1;\\n\\t\\t\\tfor (int j = 0; j < 8; j++) {\\n                // 按位取反后，查询 set 集合即可\\n\\t\\t\\t\\tint y = x^(1 << (a[j] - 1));\\n\\t\\t\\t\\tif (s.find(y) == s.end()) {\\n\\t\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (flag) {\\n\\t\\t\\t\\tprintf(\\\"yes \\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tprintf(\\\"no \\\");\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 E: 最长上升字串](https://acm.webturing.com/problem.php?cid=1323&pid=4&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n给定n个整数，对其进行m次查询。每次查询是一个范围l到r，求出l到r的最长上升连续子串。上升连续子串的定义为一个连续的子串且严格递增。\\n\\n**输入**\\n\\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是一个整数n,m，代表有一共有n个人，m个查询。第二行共有n个整数，接下来m行是m次查询，每行两个整数l,r。\\n\\n**输出**\\n\\n共T行，每行m个整数，代表最长上升连续字串。其中T<=50,n,m<1e5,每个数的大小不超过1e9。\\n\\n**样例输入**\\n\\n```c++\\n1\\n4 2\\n3 2 4 5\\n1 3\\n1 4\\n```\\n\\n**样例输出**\\n\\n```c++\\n2 3\\n```\\n\\n**解题思路：**\\n\\n最长连续上升字串，直接求解的话很容易。但本题数据量太大，有 m 次查询，时间复杂度有点高，可能会超时。涉及到区间查询，可以想到用线段树进行求解，而且本题没有更新操作。\\n\\n线段树结点维护三个值，lv 是区间左端点开始的最长上升连续值，rv 是以区间右端点结束的最长上升连续值，mv是该区间的最长上升连续值，pushup 时分类讨论，当 a[mid] < a[mid+1] 时，该区间中间两个点是递增的，需要进行线段树的区间合并操作。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nconst int maxn = 1e5 + 5;\\n\\nstruct Tree {\\n\\tint l, r;\\n\\tint lv, mv, rv;\\n} tree[maxn<<2];\\n\\nint T, n, m; \\nint a[maxn];\\n\\nvoid pushup(int l, int r, int rt) {\\n\\ttree[rt].lv = tree[rt<<1].lv;\\n\\ttree[rt].rv = tree[rt<<1|1].rv;\\n\\ttree[rt].mv = max(tree[rt].mv, tree[rt].mv);\\n\\tint mid = (l + r) >> 1;\\n\\t// 合并区间 \\n\\tif (a[mid] < a[mid+1]) {\\n\\t\\t// 以左区间的左端点开始的最长上升字串的长度等于左区间的长度，则可以合并 \\n\\t\\tif (tree[rt<<1].lv == mid - l + 1) {\\n\\t\\t\\t// 左区间的左端点和右区间的左端点合并 \\n\\t\\t\\ttree[rt].lv = tree[rt<<1].lv + tree[rt<<1|1].lv;\\n\\t\\t}\\n\\t\\t// 以右区间的右端点结束的最长上升字串的长度等于右区间的长度，则可以合并 \\n\\t\\tif (tree[rt<<1|1].r == r - mid) {\\n\\t\\t\\t// 左区间的右端点和右区间的右端点合并 \\n\\t\\t\\ttree[rt].rv = tree[rt<<1].rv + tree[rt<<1|1].rv;\\n\\t\\t}\\n\\t\\t// 更新区间的最大值，与合并后的比较，左区间右端点和右区间左端点合并 \\n\\t\\ttree[rt].mv = max(tree[rt].mv, tree[rt<<1].rv + tree[rt<<1|1].lv);\\n\\t}\\n}\\n\\nvoid build(int l, int r, int rt) {\\n\\ttree[rt].l = l;\\n\\ttree[rt].r = r;\\n\\tif (l == r) {\\n\\t\\ttree[rt].lv = tree[rt].mv = tree[rt].rv = 1;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, rt<<1);\\n\\tbuild(mid + 1, r, rt<<1|1);\\n\\tpushup(l, r, rt);\\n}\\n\\nint query(int l, int r, int rt) {\\n\\tif (tree[rt].l >= l && tree[rt].r <= r) {\\n\\t\\treturn tree[rt].mv;\\n\\t}\\n\\tint mid = (tree[rt].l + tree[rt].r) >> 1;\\n\\tint ans = 0;\\n\\tif (l <= mid) {\\n\\t\\tans = max(ans, query(l, r, rt<<1));\\n\\t} \\n\\tif (r > mid) {\\n\\t\\tans = max(ans, query(l, r, rt<<1|1));\\n\\t}\\n\\tif (a[mid] < a[mid+1]) {\\n\\t\\tans = max(ans, min(tree[rt<<1].rv, mid-l+1) + min(tree[rt<<1|1].lv, r-mid));\\n\\t}\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tint x, y;\\n\\t\\t\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\t\\t\\tprintf(\\\"%d \\\", query(x, y, 1));\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n不用线段树直接进行求解，发现也能 AC，可能数据比较菜。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nconst int maxn = 1e5 + 5;\\n\\nint T, n, m; \\nint a[maxn];\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tint x, y;\\n\\t\\t\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\t\\t\\tint res = 1, len = 1;\\n\\t\\t\\tfor (int j = x + 1; j <= y; j++) {\\n                // 后一个比前一个大，l长度增加\\n\\t\\t\\t\\tif (a[j] > a[j-1]) {\\n\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t} else {\\n                    // 否则，长度置为1，因为是连续字串\\n\\t\\t\\t\\t\\tlen = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = max(len, res);\\n\\t\\t\\t}\\n\\t\\t\\tprintf(\\\"%d\\\\n\\\", res);\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 F: 雄伟的城堡](https://acm.webturing.com/problem.php?cid=1323&pid=5&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n在一个群岛上，有一个富可敌国的大富翁。他打算在这个群岛上建造一个最大城堡，也就是群岛上最大的岛屿。\\n\\n**输入** \\n第一行是一个整数T，代表测试数据的组数。每组数据中第一行是两个整数n,m，代表地图的大小。接下来n行每行共m个整数。0代表海洋，1代表陆地。其中T<=50,n,m<=200 。\\n\\n**输出**\\n共T行，最大的面积。\\n\\n**样例输入**\\n\\n```c++\\n1\\n5 5\\n0 1 1 0 0\\n1 1 0 0 0\\n0 0 1 1 0\\n0 1 1 1 1 \\n0 0 1 1 0\\n```\\n\\n**样例输出**\\n\\n```c++\\n8\\n```\\n\\n**解题思路：** dfs 或 bfs 求最大连通块。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nconst int maxn = 205;\\nint T, n, m;\\nint a[maxn][maxn];\\nint vis[maxn][maxn];\\nint area, ans;\\n\\nvoid dfs(int x, int y) {\\n\\tif (x < 0 || y < 0 || x >= n || y >= n || vis[x][y] || !a[x][y]) {\\n\\t\\treturn;\\n\\t}\\n\\tvis[x][y] = 1;\\n\\tarea++;\\n\\tdfs(x-1, y);\\n\\tdfs(x+1, y);\\n\\tdfs(x, y-1);\\n\\tdfs(x, y+1);\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tans = 0;\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tscanf(\\\"%d\\\", &a[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (a[i][j] && !vis[i][j]) {\\n\\t\\t\\t\\t\\tarea = 0;\\n\\t\\t\\t\\t\\tdfs(i, j);\\n\\t\\t\\t\\t\\tans = max(area, ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n}\\n\\n----------------------------------------------------------------------------------------\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\nconst int maxn = 205;\\nint T, n, m;\\nint a[maxn][maxn];\\nint vis[maxn][maxn];\\nint dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\nint area, ans;\\n\\nstruct Node {\\n    int x, y;\\n    Node():x(),y(){} // 空构造函数\\n    Node(int xx, int yy):x(xx),y(yy){} // 带参构造函数\\n};\\n\\nvoid bfs(int i, int j) {\\n\\tqueue<Node> q;\\n\\tq.push(Node(i, j));\\n\\tvis[i][j] = 1;\\n\\twhile (!q.empty()) {\\n\\t\\tarea++;\\n\\t\\tNode now = q.front();\\n\\t\\tq.pop();\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = now.x + dir[k][0];\\n\\t\\t\\tint y = now.y + dir[k][1];\\n\\t\\t\\tif (x >= 0 && y >= 0 && x < n && y < n && !vis[x][y] && a[x][y]) {\\n\\t\\t\\t\\tvis[x][y] = 1;\\n\\t\\t\\t\\tq.push(Node(x, y));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tans = 0;\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tscanf(\\\"%d\\\", &a[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (a[i][j] && !vis[i][j]) {\\n\\t\\t\\t\\t\\tarea = 0;\\n\\t\\t\\t\\t\\tbfs(i, j);\\n\\t\\t\\t\\t\\tans = max(area, ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 J: 数列分段](https://acm.webturing.com/problem.php?cid=1323&pid=9&langmask=262141&puzzle_mask=0)\\n\\n**题目描述** \\n\\n有n个整数，分成m段。使每一段的和的最小值尽可能的大。\\n\\n**输入**\\n\\n第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有两个整数n，m，接下来一行是n个整数。其中T<=50,n,m<1e5 。\\n\\n**输出**\\n尽可能的大的每一段的和的最小值。\\n\\n**样例输入**\\n\\n```c++\\n1\\n5 3\\n4 5 4 5 1\\n```\\n\\n**样例输出**\\n\\n```c++\\n4\\n```\\n\\n**解题思路：** 二分，最大化最小值\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nint T, n, m;\\nint a[maxn];\\n\\nint check(int k) {\\n\\tint num = 0, sum = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (sum + a[i] >= k) {\\n\\t\\t\\tnum++;\\n\\t\\t\\tsum = 0;\\n\\t\\t} else {\\n\\t\\t\\tsum += a[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {\\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tint r = 0;\\n\\t\\tint l = 0x3f3f3f3f;\\n\\t\\tint ans = 0;\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t\\tr += a[i];\\n\\t\\t\\tl = min(l, a[i]);\\n\\t\\t}\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = (l + r) >> 1;\\n\\t\\t\\tif (check(mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 K: 数数字](https://acm.webturing.com/problem.php?cid=1323&pid=10&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\nAlice和Bob进行一款质数游戏，Alice先说一个质数或者1，Bob再加上一个质数或者1。不能超过目标数字，谁先喊道目标数字就获胜。Alice和Bob都足够聪明，都会采用最优策略。\\n\\n**输入**\\n\\n第一行是一个整数T，代表测试数据的组数。每组样例中，第一行有一个整数n，代表目标数字。\\n\\nT<=20,n<1e18\\n\\n**输出**\\n\\n共T行，输出Alice win或者Bob win。\\n\\n**样例输入**\\n\\n```c++\\n2\\n4\\n6\\n```\\n\\n**样例输出**\\n\\n```c++\\nBob win\\nAlice win\\n```\\n\\n**解题思路：** 首先，我们需要知道一个定理：**一切大于2的质数，一定是形如4n+1或4n-1的数。**\\n\\n由于我们每次给的数可以是1，2，3+（大于2的）质数。那么无论谁先讲，后手的一定可以加成4n。所以说，只\\n\\n要给的数能够被4整除，Bob必胜。反之，Alice必胜。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tint T, n;\\n\\tscanf(\\\"%d\\\", &T);\\n\\twhile (T--) {\\n\\t\\tscanf(\\\"%d\\\", &n);\\n\\t\\tif (n % 4 == 0) {\\n\\t\\t\\tprintf(\\\"Bob win\\\\n\\\");\\n\\t\\t} else {\\n\\t\\t\\tprintf(\\\"Alice win\\\\n\\\");\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n**参考链接：**[https://blog.csdn.net/weixin_43773540/article/details/104943915](https://blog.csdn.net/weixin_43773540/article/details/104943915)\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621001632134.png\",\"articleTitle\":\"2018年安徽省程序设计竞赛题解\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.21', '安徽省合肥市 联通', '2021-05-14 22:14:02');
INSERT INTO `tb_operation_log` VALUES (90, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [最多约数](https://acm.webturing.com/problem.php?cid=1643&pid=0&langmask=262141&puzzle_mask=0)\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 2000000;\\nint dp[maxn]; // dp[i] 存储 i 的约数\\n\\nint main() {\\n\\tint a, b;\\n\\tcin>>a>>b;\\n\\tint res = 0;\\n\\tfor (int i = a; i <= b; i++) {\\n        // 以 i 的倍数进行增加\\n\\t\\tfor (int j = i; j <= b; j += i) {\\n\\t\\t\\tdp[j]++; // dp[j]++是因为，i 此时是 j 的约数，j = n*i;\\n\\t\\t}\\n\\t\\tres = max(res, dp[i]);\\n\\t}\\n\\tcout<<res<<endl;\\n\\treturn 0;\\n} \\n```\\n\\n## [会场安排问题](https://acm.webturing.com/problem.php?cid=1643&pid=1&langmask=262141&puzzle_mask=0)\\n\\n每个活动都有一个开始时间和一个结束时间，所有需要的会议数是活动之间重叠的次数 + 1\\n\\n```c++\\n#include<bits/stdc++.h> \\nusing namespace std;\\n\\nconst int maxn = 1000001;\\n\\ntypedef struct node {\\n\\tint start;\\n\\tint end;\\n} Act;\\n\\nbool cmp(Act a, Act b) {\\n\\treturn a.start < b.start;\\n}\\n\\n// 活动数组 \\nAct acts[maxn];\\nint k;\\nint main()\\n{\\n\\tcin>>k;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tcin>>acts[i].start>>acts[i].end;\\n\\t}\\n\\t// 把所有活动按开始时间升序进行排列 \\n\\tsort(acts, acts + k, cmp);\\n\\tint max = 0;\\n\\tfor (int i = 1; i < k; i++) {\\n\\t\\tint count = 1;\\n\\t\\tfor (int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t// 如果两个活动时间有重叠，则需要新开会议 \\n\\t\\t\\tif (acts[i].start < acts[j].end) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (count > max) {\\n\\t\\t\\tmax = count;\\n\\t\\t}\\n\\t}\\n\\tcout<<max<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n## [数位的幂](https://acm.webturing.com/problem.php?cid=1643&pid=2&langmask=262141&puzzle_mask=0)\\n\\n快速幂 + 模运算\\n\\n1. (a + b) % p = (a % p + b % p) % p （1）\\n2. (a - b) % p = (a % p - b % p ) % p （2）\\n3. **(a \\\\* b) % p = (a % p * b % p) % p （3）**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int P = 1000000007;\\n\\nlong long fastPower(long long base, long long power) {\\n    long long result = 1;\\n    while (power > 0) {\\n        if (power & 1) {\\n            result = result * base % P;\\n        }\\n        power >>= 1;\\n        base = (base * base) % P;\\n    }\\n    return result;\\n}\\n\\n\\nint main() {\\n\\tstring s;\\n\\tcin>>s;\\n\\tlong long res = 1;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tlong long x = s[i] - \'0\';\\n\\t\\tres *= fastPower(x, i + 1);\\n\\t\\tres %= P;\\n\\t}\\n\\tcout<<res<<endl;\\n    return 0;\\n}\\n\\n--------------------------------------------------------------------------------\\n// 优化版本\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\ntypedef long long ll;\\nconst ll mod = 1000000007;\\nconst int maxn = 1000001;\\n\\nll quickpw(ll a, ll b) {\\n    ll ans = 1, base = a;\\n    while (b != 0) {\\n        if (b & 1 != 0)\\n            ans = ans * base % mod;\\n        base = base * base % mod;\\n        b >>= 1;\\n    }\\n    return ans % mod;\\n}\\n\\nchar c[maxn];\\n\\nint main() {\\n    while (~scanf(\\\"%s\\\", c)) {\\n        ll a[11];\\n        ll ans = 1;\\n        memset(a, 0, sizeof(a));\\n        int len = strlen(c);\\n        for (int i = 0; i < len; i++) {\\n            a[c[i] - \'0\'] += (i + 1);\\n        }\\n        for (int i = 1; i < 10; i++) {\\n            if (a[i]) {\\n                ans = ans * quickpw(i, a[i]) % mod;\\n            }\\n        }\\n        cout << ans % mod << endl;\\n    }\\n    return 0;\\n}\\n```\\n\\n## [Search - Allocation](https://acm.webturing.com/problem.php?cid=1643&pid=3&langmask=262141&puzzle_mask=0)\\n\\n二分，最大值最小化\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n, m; // 分m段，则要划出m-1条线\\nint money[maxn];\\n\\nint check(int k) { // k是所有段中的最大值，希望其最小\\n\\tint sum = 0, num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\\n\\t\\tif (sum + money[i] > k) {  \\n\\t\\t\\tsum = money[i];\\n\\t\\t\\tnum++; \\n\\t\\t} else {\\n\\t\\t\\tsum += money[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\\n\\t\\treturn 0;\\n\\t}\\n\\treturn 1;\\n}\\n\\nint main() {\\n\\tcin>>n>>m;\\n    // l，r 为左右边界\\n\\tint l = 0, r = 0, ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t    cin>>money[i];\\n\\t\\tl = max(l, money[i]);\\n\\t\\tr += money[i];\\n\\t}\\n\\twhile (l <= r) {\\n\\t\\tint mid = (l + r) >> 1;\\n\\t\\tif (check(mid)) { // 符合，往左走\\n\\t\\t\\tans = mid;\\n\\t\\t\\tr = mid - 1;  \\n\\t\\t} else { // 不符合，往右走\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}\\n\\t}\\n\\tcout<<ans<<endl;\\n\\treturn 0;\\n} \\n```\\n\\n## [火柴](https://acm.webturing.com/problem.php?cid=1643&pid=4&langmask=262141&puzzle_mask=0)\\n\\n贪心\\n\\n每个数字都有对应的火柴数量，根据输入的数可以确定总的火柴数，因为要用这些火柴拼出最大的数，所以应该从9往前尝试，但是尝试的过程中需要判断是否满足条件。2，7分别是最小、最大能拼出数字的火柴数，通过这可以确定剩余火柴数的范围。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 每个数字对应的火彩数量 \\nint hcs[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\\nint t, n, sum, k;\\nchar ch;\\n\\n// i 剩余的数字数，j剩余的火彩数 \\nbool judge(int i, int j)  {\\n\\t// 2 和 7 是数字对应的最小和最大火柴数量 \\n\\treturn i * 2 <= j && j <= i * 7;\\n}\\n\\nint main() {\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tchar x;\\n\\t\\tsum = 0; // 火柴数量 \\n\\t\\tcin>>n;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tcin>>ch;\\n\\t\\t\\tsum += hcs[ch - \'0\'];  // 总的火柴数 \\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t// 重新排列后数要最大，所以要从9开始  \\n\\t\\t\\tk = 9;  \\n\\t\\t\\t// 判断是否是最后一位，如果是最后一位，sum应该和某个数字对应的火彩数相等 \\n\\t\\t\\tif (i == n) {\\n\\t\\t\\t\\twhile (sum != hcs[k]) {\\n\\t\\t\\t\\t\\tk--;\\t\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\tcout<<k;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 剩下的火柴数量应该在最小最大直接 \\n\\t\\t\\t// 如果不满足条件，就继续往下判断 \\n\\t\\t\\twhile (!judge(n - i, sum - hcs[k])) {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\tsum -= hcs[k];\\n\\t\\t\\tcout<<k;\\n\\t\\t}\\n\\t\\tcout<<endl; \\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [异或和(xorsum)](https://acm.webturing.com/problem.php?cid=1643&pid=5&langmask=262141&puzzle_mask=0)\\n\\n[参考链接](https://blog.csdn.net/liupang14159/article/details/115607276)\\n\\n+ 异或是不进位的加法\\n+ 进位加法和不进位加法相等，说明没有发生进位\\n+ 如果[l,r]区间的加法不进位，那么以r为右端点，左端点在[l,r]中的(l,r)都可行\\n+ 新加入一个右端点，那么有可能会出现进位，往右移动左端点，使之不进位。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tlong long n;\\n\\tcin >> n;\\n\\tlong long a[n];\\n\\tfor (long long i = 0; i <n ; i++) \\n\\t\\tcin >> a[i];\\n\\tlong long s = 0, l = 0, ans = 0;\\n\\t// 异或相当于不进位的加法 \\n\\tfor (long long i = 0; i < n; i++) {\\n\\t\\twhile ((s ^ a[i]) != s + a[i]) {\\n\\t\\t\\ts ^= a[l++];\\n\\t\\t}\\n\\t\\tans += i - l + 1;\\n\\t\\ts ^= a[i];\\n\\t}\\n\\tcout<<ans<<endl;\\n\\treturn 0;\\n}\\n\\n// 前缀和的思想\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\ntypedef long long ll;\\nconst int N = 2e5 + 10;\\nll sum[N], X[N];\\nll a[N];\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    for (int i = 1; i <= n; i++) {\\n    \\tscanf(\\\"%lld\\\", &a[i]);\\n\\t}\\n    sum[1] = X[1] = a[1];\\n    // 求出前缀和，以及前几项的异或结果\\n    for (int i = 2; i <= n; i++) {\\n    \\tsum[i] = sum[i - 1] + a[i];\\n\\t\\tX[i] = X[i - 1] ^ a[i];\\n\\t}\\n    ll ans = 0;\\n    int l = 0;\\n    // 遍历依次比较即可\\n    for (int r = 1; r <= n; r++) {\\n        // sum[r] - sum[l] 为 区间(l, r]的和，左开右闭区间\\n        // X[r] ^ X[l]) 为 (l, r]的异或结果\\n        while (sum[r] - sum[l] != (X[r] ^ X[l])) {\\n        \\tl++;\\n\\t\\t}\\n\\t\\tans += r - l;\\n    }\\n    printf(\\\"%lld\\\\n\\\", ans);\\n    return 0;\\n}\\n```\\n\\n## [五个数AB_CDE乘积最小](https://acm.webturing.com/problem.php?cid=1643&pid=6&langmask=262141&puzzle_mask=0)\\n\\n全排列\\n\\n```c++\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint a[5];\\nint n = 5;\\n\\nint main() {\\n    for (int i = 0; i < n; i++) {\\n    \\tcin >> a[i];\\n\\t}\\n    // 注意需要先排序，与next_permutation函数的特性有关\\n    sort(a, a + 5);\\n    int best = INT_MAX;\\n    do {\\n        if (a[0] == 0 || a[3] == 0) {\\n        \\tcontinue;\\n\\t\\t}\\n        int cur = (a[0] * 100 + a[1] * 10 + a[2]) * (a[3] * 10 + a[4]);\\n        best = min(cur, best);\\n        // next_permutation，下一个排列，全排列函数，每次循环对应一个排列，类似与升序\\n  // 若：a[3] = {1, 2, 3}，则该函数的结果为{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}\\n  // 若：a[3] = {3,1,2}，则该函数的结果为{3,1,2},{3,2,1}，这也是前面升序排序的原因\\n  // 与之对应的还有一个prev_permutation函数，前一个排列，对a[3] = {3,1,2}，结果为{3,1,2},{2,3,1},\\n        // {2,1,3},{1,3,2},{1,2,3}，类似于降序\\n    } while (next_permutation(a, a + n));\\n    cout << best << endl;\\n    return 0;\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620460201284.jpg\",\"articleTitle\":\"2021安徽省程序设计网络赛题解\",\"categoryId\":15,\"id\":46,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.93', '安徽省合肥市 联通', '2021-05-15 21:16:42');
INSERT INTO `tb_operation_log` VALUES (91, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [知识竞赛](http://210.45.175.76/home/problem.php?cid=1059&pid=0)\\n\\n**问题描述**\\n\\n最近学校组织了党史知识竞答比赛，比赛采用扣分制方法评分，即扣分越高，名次越低。当比赛结束时，要在现场按照选手的出场顺序宣布最后扣分和最后名次，扣除相同分数的选手具有相同的名次，名次连续编号，不用考虑同名次的选手人数。 例如： 选手序号：1 2 3 4 5 6 选手扣分：5 3 4 7 3 5 输出名次：3 1 2 4 1 3\\n\\n**输入描述**\\n\\n共N+1行，第一行为选手的个数N（1 < N ≤ 50），下面N行按选手序号给出每个选手的扣分，扣分在0~100之间，其中第i行表示序号为i-1的选手的扣分。\\n\\n**输出描述**\\n\\nN行，按序号给出每个选手的名次，第i行表示序号为i的选手的名次。\\n\\n**样例输入**\\n\\n```c++\\n6\\n5\\n3\\n4\\n7\\n3\\n5\\n```\\n\\n**样例输出**\\n\\n```\\n3\\n1\\n2\\n4\\n1\\n3\\n```\\n\\n**解题思路**\\n\\n用结构体把扣分情况和序号绑定在一起，先按扣分情况从小到大排序，按扣分情况得出具体排名后再按序号从小到大排序，再输出即可。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint id, score, rank;\\n} Stu[51];\\n\\nbool cmp(Node a, Node b) {    //按扣分从小到大排 \\n\\treturn a.score < b.score;  \\n}\\n\\nbool cmp2(Node a, Node b) {   //按序号从小到大排 \\n\\treturn a.id < b.id;\\n}\\n\\nint main() {\\n\\tint n;\\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tStu[i].id = i;\\n\\t\\tcin>>Stu[i].score;\\n\\t}\\n\\tsort(Stu, Stu + n, cmp);        //按扣分情况从小到大排序 \\n\\tint pre = Stu[0].score;\\n\\tint rank = 1;\\n\\tStu[0].rank = 1;\\n\\tfor (int i = 1; i < n; i++) {\\t//如果用相同的扣分则使其排名相同 \\n\\t\\tif (pre == Stu[i].score) {\\n\\t\\t\\tStu[i].rank = rank;\\n\\t\\t} else {\\n\\t\\t\\tStu[i].rank = ++rank;\\n\\t\\t\\tpre = Stu[i].score;\\n\\t\\t}\\n\\t}\\n\\tsort(Stu, Stu + n, cmp2);       //按序号从小到大排序 \\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcout<<Stu[i].rank<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n\\n-----------------------------------------------------------------------\\n/*\\n\\t方法二，用一个大小 101的数组，记录分数的排名，分数是下标，值是排名，再求前缀和即可\\n*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint n, s;\\nint rk[101];\\nint score[51];\\n\\nint main() {\\n\\tstd::ios::sync_with_stdio(false);\\n    std::cin.tie(0);\\n    \\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>score[i];\\n\\t\\trk[score[i]] = 1;\\n\\t}\\n\\tfor (int i = 1; i < 101; i++) {\\n\\t\\trk[i] += rk[i - 1];\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (rk[score[i]]) {\\n\\t\\t\\tcout<<rk[score[i]]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [螺旋拐弯](http://210.45.175.76/home/problem.php?cid=1059&pid=1)\\n\\n**问题描述**\\n\\n螺旋拐弯是由数字和连线按照顺时针方向画出的图形，如下图所示： 在拐弯时不能与已画出的图形发生碰撞，并且能拐弯时就一定要拐。由图可知，前4次拐弯分别发生在数字2、3、5、7这4个位置。 输入N，计算第N次拐弯发生在哪个数字处？\\n\\n**输入描述**\\n\\n输入只有一行，包括一个整数N (1 ≤ N ≤ 10000)\\n\\n**输出描述**\\n\\n输出第N个弯处的数字。\\n\\n**样例输入**\\n\\n```c++\\n5                 \\n```\\n\\n**样例输出**\\n\\n```c++\\n10\\n```\\n\\n直接根据图中拐弯处的数值求出规律，然后根据规律求出第n个拐弯处的值。规律为每两个拐弯处的相差的值为一个定值，后两个拐弯处的数相差的值比前两个拐弯处相差的值多1。如：前两个为1->2,2->3。后两个为3->5,5->7。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tint n;\\n\\tcin>>n;\\n\\t\\n\\tint x = 1;\\n\\tint step = 1;\\t\\t\\t\\t\\t//统计每两个拐弯处相差的个数 \\n\\tint cnt = 0;\\t\\t\\t\\t\\t//统计拐弯处的个数 \\n\\tfor (int i = 0; i < n; i++) {\\t\\n\\t\\tif (cnt == 2) {\\t\\t\\t\\t//每处理了两个拐弯处后使个数加一且cnt重新计数。 \\n\\t\\t\\tcnt = 0;\\n\\t\\t\\tstep += 1;\\n\\t\\t}\\n\\t\\tx += step;\\n\\t\\tcnt++;\\n\\t}\\n\\tcout<<x<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n## [文件加密](http://210.45.175.76/home/problem.php?cid=1059&pid=2)\\n\\n**问题描述**\\n\\n为了提高信息传输的安全性，我们常常需要对信息进行加密。人们发明了各种各样的加密方式，其中一种方式是，对文中单词进行逆序处理。请你写一个程序，对输入的已加密的文本进行解密。\\n\\n**输入描述**\\n\\n第一行是一个正整数N(1 ≤ N ≤ 1000)，表示后面将有N行已加密的信息。接下来的N行，每行一个不超过1000个字符的字符串，每个字符串中只有英文小写字母和空格组成。注意：可以有空行（即该行无字符出现）和空格行。\\n\\n**输出描述**\\n\\n共N行，每行对应输出解密后的文本。\\n\\n**样例输入**\\n\\n```c++\\n2\\ni ekil siht emag\\n eno  owt   eerht               \\n```\\n\\n**样例输出**\\n\\n```c++\\ni like this game\\n one  two   three               \\n```\\n\\n把每个单词反转即可，注意空格。设置两个指针 l, r，l位单词的开始位置，r位单词的结束位置\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n;\\nstring str;\\nchar cs[1005];\\n\\nvoid reverse(char cs[], int i, int j) {\\n    while (i < j) {\\n        char c = cs[i];\\n        cs[i] = cs[j];\\n        cs[j] = c;\\n        i++;\\n        j--;\\n    }\\n}\\n\\nint main() {\\n\\tint j = 0;\\n\\tcin>>n;\\n\\tgetchar();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\t// 这种方式可以输入空格 \\n\\t\\tgetline(cin, str);\\n\\t\\tint len = str.length();\\n\\t\\t// 转化成字符数组便于反转 \\n\\t\\tfor (j = 0; j <= len; j++) {\\n\\t\\t\\tcs[j] = str[j];\\n\\t\\t}\\n\\t\\tcs[j] = \'\\\\0\';\\n\\t\\tint l = 0, r = 0;\\n\\t\\t// 先忽略前面的空格 \\n\\t\\twhile (cs[l] == \' \' && l < len) {\\n\\t\\t\\tl++;\\n\\t\\t\\tr++;\\n\\t\\t}\\n        while (l < len) {\\n        \\t// 单词刚好结束的结束 \\n            if (cs[r] == \' \' && cs[r - 1] != \' \') {\\n                reverse(cs, l, r - 1);\\n                r++;\\n                l = r;\\n                // l移动到非空格位置，即下一个单词的开始位置 \\n                while (cs[l] == \' \') {\\n                \\tl++;\\n\\t\\t\\t\\t}\\n            }\\n            if (r == len - 1) {\\n                reverse(cs, l, r);\\n                break;\\n            }\\n            r++;\\n        }\\n        cout<<cs;\\n        if (i != n - 1) {\\n        \\tcout<<endl; \\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [化简比例](http://210.45.175.76/home/problem.php?cid=1059&pid=3)\\n\\n**问题描述**\\n\\n在互联网时代，我们经常会在网上看到有针对某个人或某个观点进行投票进行民意调查，投票的结果有若干人赞成，也会有若干人反对。比如，对某一观点表示赞成的有1498人，反对的有902人，则赞同与反对的比例可以简单记为1498:902。 一般情况下，直接把调查结果以实际的比例呈现出来，往往这个比例的数值太大，难以一眼看出它们的关系，大多数民众也不会满意。对上面的例子，如果把赞同与反对的比例记为5:3，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时看起来也比较直观。 现给出赞成人数X，反对人数Y，以及一个上界L，请你编程实现将X:Y化简为X’:Y’，要求在X’和Y’均不大于L且X’与Y’互质（即两个整数的最大公约数是1）的前提下，X/Y≤X’/Y’且X’/Y’-X/Y的值尽可能小。\\n\\n**输入描述**\\n\\n输入共一行，包含三个整数X、Y和L（1 ≤ X ≤ 1000000，1 ≤ Y ≤ 1000000，1 ≤ L ≤ 100），每两个整数之间用一个空格隔开，分别表示赞成人数、反对人数和上界。\\n\\n**输出描述**\\n\\n输出共一行，包含两个整数X’和Y’，中间用一个空格隔开，表示化简后比例。\\n\\n**样例输入**\\n\\n```c++\\n1498 902 10                 \\n```\\n\\n**样例输出**\\n\\n```c++\\n5 3     \\n```\\n\\n暴力，直接根据给定L的范围，依次尝试，与X/Y最接近的就是答案\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tdouble a, b, l, x, y;\\n\\tcin>>a>>b>>l;\\n\\tdouble min = 1000000.0, t, k = 1.0*a/b; // k算出a和b的比值作为精确度。 \\n\\tfor (int i = 1; i <= l; i++) {      \\n\\t\\tfor (int j = 1; j <= l; j++) {         \\n\\t\\t\\tt = 1.0*i/j - k;\\t\\t\\t  // t为每次两个数的比值与精确度相差的大小。 \\n             // 如果 这次t比上次的小，证明这次的精确度更高，保留此次数据。 \\n\\t\\t\\tif (t < min && t >= 0) {\\t\\t  \\n\\t\\t\\t\\tx = i;\\n\\t\\t\\t\\ty = j;\\n\\t\\t\\t\\tmin = t;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tcout<<x<<\\\" \\\"<<y<<endl;\\n\\treturn 0; \\n}\\n```\\n\\n## [布匹裁剪](http://210.45.175.76/home/problem.php?cid=1059&pid=4)\\n\\n**问题描述**\\n\\n布厂有一批布匹，现在想把这些布匹裁剪成一些长度相同的小段布料（布料有可能有剩余），需要得到的小段的数目是给定的。当然，我们希望得到的小段布料越长越好，你的任务是计算能够得到的小段布料的最大长度。布料长度的单位是cm。布匹的长度都是正整数，我们要求切割得到的小段布料的长度也是正整数。 例如有两段布匹长度分别为11和23，要求切割成到等长的6段，很明显能切割出来的小段布料长度最长为5。\\n\\n**输入描述**\\n\\n第一行是两个正整数N和K(1 ≤ N ≤ 100000，1 ≤ K ≤ 100000000)，N是布匹的数目，K是需要得到的小段的数目。接下来的N行，每行有一个1到100000000之间的正整数，表示一段布匹的长度。\\n\\n**输出描述**\\n\\n能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。\\n\\n**样例输入**\\n\\n```c++\\n3 7\\n232\\n124\\n456        \\n```\\n\\n**样例输出**\\n\\n```c++\\n114\\n```\\n\\n算出一个布段的取值范围，再使用二分慢慢的逼近符合情况的最大值。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100001;\\nint a[maxn];\\nint k;\\nint n;\\n\\nint check(long long len) {        // 算出当前长度能剪出的布段数量，与所需的布段数量k比较 \\n\\tlong long num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tnum += a[i] / len;   \\n\\t}\\n\\tif (num >= k) {              //若大于k返回1，小于k返回0 \\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tcin>>n>>k;                      \\n\\tint l = 100000001;\\n\\tlong long r = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tscanf(\\\"%d\\\", &a[i]);           \\n\\t\\tr += a[i];               // r为布段总长度       \\n\\t\\tl = min(l, a[i]);        // l为最小的布段长度     \\n\\t}\\n     // 因为布段最小为1cm，所以当布段总长小于需要的布段数时，切不出来，输出0 \\n\\tif (r < k) {                \\n\\t\\tprintf(\\\"0\\\\n\\\");\\n\\t\\treturn 0;\\n\\t}\\n\\tl = l / k;  \\t\\t\\t\\t //二分的最小值\\t\\n\\tr = r / k;\\t\\t\\t\\t\\t //二分的最大值\\t\\n\\tif (r == 1) {\\t\\t\\t\\t //特殊情况单独讨论，不然后面二分会出现除数为0\\n\\t\\tprintf(\\\"1\\\\n\\\");\\n\\t\\treturn 0;\\n\\t}\\n\\tint ans = 0;\\n\\twhile (l <= r) {             //使用二分慢慢逼近最大长度 \\n\\t\\tlong long mid = (l + r) >> 1; \\n\\t\\tif (check(mid)) {\\t\\t \\t\\t\\t\\t\\n\\t\\t\\tans = mid;   \\n\\t\\t\\tl = mid + 1; \\t\\t \\n\\t\\t} else {\\n\\t\\t\\tr = mid - 1;\\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\treturn 0;\\n}\\n```\\n\\n## [蝈蝈赛马](http://210.45.175.76/home/problem.php?cid=1059&pid=5)\\n\\n**问题描述**\\n\\n卢宝嚣张着要和蝈蝈赛马，并且为了增加难度，卢宝在自己的每匹马上都设置了一个币值，如果卢宝这匹马赢了，那么蝈蝈就要付给卢宝相应的币，同样的，如果蝈蝈赢了卢宝这匹马，卢宝也要给蝈蝈相应的币。每匹马还有一个速度值，速度快的马会获得胜利，速度相同则平局，平局的话蝈蝈也要付给卢宝币。现在卢宝已经安排好了马的上场顺序，以及按照顺序的每匹马的币值。蝈蝈想知道，该怎么安排自己的上场顺序，才能赢得最多的钱或者怎样才能输最少的钱？（如果最后是输钱就输出负数）\\n\\n**输入描述**\\n\\n第一行一个t，代表t组数据（1 ≤ t ≤ 10），每种数据包含四行： 第一行为一个整数n，代表马的数量（1 ≤ n ≤ 1000） 第二行n个数a[i]，代表卢宝各匹马的速度，并且这就是卢宝的上场顺序（1 ≤ a[i] ≤ 100000） 第三行n个数b[i]，代表卢宝各匹马的币值，与速度值一一对应（1 ≤ b[i] ≤ 10000） 第四行n个数c[i]，代表蝈蝈各匹马的速度（1 ≤ c[i] ≤ 100000）\\n\\n**输出描述**\\n\\n每组数据输出一行一个整数，表示蝈蝈可以赢的最多的币（输出非负数），或者输的最少的币（输出负数）。\\n\\n**样例输入**\\n\\n```c++\\n2\\n3\\n40 30 20\\n1 2 3\\n20 30 50\\n5\\n25 25 50 60 10\\n10 50 5 100 30\\n70 5 30 25 40                 \\n```\\n\\n**样例输出**\\n\\n```c++\\n4\\n185\\n```\\n\\n贪心算法，把卢宝的马按金钱从大到小排，蝈蝈的马按速度从大到小排，然后从前往后依次拿出卢宝的马，再从后向前拿蝈蝈的马比较速度，这样就能保证蝈蝈速度比卢宝大的马都是正好比他大的。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nconst int maxn = 100005;\\n\\nstruct Node {\\t\\t\\t\\t\\t//卢宝的马 \\n\\tint speed, money;\\n} Ho[maxn];\\n\\nint b[maxn];                    //蝈蝈的马 \\nint t, n;\\n\\nbool cmp1(Node a, Node b) {     //按金钱从大到小排序 \\n\\treturn a.money > b.money;\\n}\\n\\nbool cmp2(int a, int b) {\\t\\t//从大到小排序 \\n\\treturn a > b;\\n}\\n\\nint  vis[maxn];                //蝈蝈的马的标记数组 \\n\\nint main() {\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tcin>>n;\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tcin>>Ho[j].speed;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tcin>>Ho[j].money;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tcin>>b[j];\\n\\t\\t}\\n\\t\\tsort(Ho, Ho + n, cmp1); //让卢宝的马按金钱从大到小排序 \\n\\t\\tsort(b, b + n, cmp2);   //让蝈蝈的马按速度从大到小排序 \\n\\t\\tint sum = 0;\\n\\t\\tmemset(vis, 0, sizeof(vis));//每一组数据都要初始化标记数组 \\n\\t\\tint len = n - 1;\\t\\t\\t  //蝈蝈的马的数组的下标，因为从0开始所以先减一 \\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint flag = 0;             //标记，若找到了为1，为找到为0\\n\\t\\t\\tfor (int k = len; k >= 0; k--) {  //从后往前找蝈蝈的马，找到比卢宝马速度大的最小值。 \\n\\t\\t\\t\\tif (b[k] > Ho[j].speed && !vis[k]) {//找到了后标记flag且加上相应的金钱 \\n\\t\\t\\t\\t\\tsum += Ho[j].money;\\n\\t\\t\\t\\t\\tvis[k] = 1;\\n\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!flag) {\\t\\t\\t\\t\\t//未找到则减去相应的金钱 \\n\\t\\t\\t\\t// vis[len--] = 1;\\t\\n\\t\\t\\t\\tsum -= Ho[j].money;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [笔迹鉴别](http://210.45.175.76/home/problem.php?cid=1059&pid=6)\\n\\n**问题描述**\\n\\n最近柯南收到了一则来自怪盗基德的预告函，上面写着：“今晚8点，我将前来取走‘命运的宝石’”。然而上一周怪盗基德也发出了一张预告函，写着：“在10周年纪念之时，我将取走 the 8148”。柯南感到很奇怪，因为怪盗基德很少如此频繁地连续作案。于是他仔细比对这两封预告函。柯南发现，上一周的预告函中出现了两次“8”，这次预告函也有一个“8”，但是笔迹并不相同。如图所示，左边两个“8”字均来源于上一周的预告函，右上角留了一个开口；而右边的“8”字来源于本周的预告函，右上角是闭合的。 真 真 假 因此，柯南判断，这次收到的预告函并不是真正的怪盗基德发出的，而是一封伪造的预告函。最终，柯南抓住了伪造预告函的假基德。 现在，请聪明的你也来鉴别一下笔迹图像，判别这些“8”字笔迹的真伪。\\n\\n**输入描述**\\n\\n首先是一个正整数T（T ≤ 10），表示数据组数。对于每一组数据： 第一行，两个正整数m和n（m，n ≤ 1000）分别表示图像的高和宽。接下来有m行，每行，每n个字符，只可能为0 或者1。0表示黑色字迹，1表示白色背景。数据保证每张图像为白底黑字，且含有唯一一个完整的“8”字，不会有缺失，也不存在空白图像或者含有其它内容的数据。 注意，“8”字有可能是歪的或者倒过来的。\\n\\n**输出描述**\\n\\n对于每一组数据，输出Yes或No，代表笔迹真伪。\\n\\n**样例输入**\\n\\n```c++\\n1\\n9 8\\n1 1 1 1 1 1 1 1 \\n1 1 1 0 0 1 1 1 \\n1 1 0 1 1 0 1 1 \\n1 1 0 0 1 0 1 1 \\n1 1 1 0 0 1 1 1 \\n1 1 0 1 1 0 1 1 \\n1 1 0 1 1 0 1 1 \\n1 1 1 0 0 1 1 1 \\n1 1 1 1 1 1 1 1                \\n```\\n\\n**样例输出**\\n\\n```c++\\nNo\\n```\\n\\n此题使用深搜解决，如果8的右上角有开口，则只有两个封闭的区域，如果没有封口，则有三个封闭的区域。为了避免数字8可能与矩阵边缘接触（会导致划分的封闭区域不确定），在矩阵外围包上一层1。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint a[1005][1005];\\nint cnt, flag;\\nint t, m, n;\\nint dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};  //上下左右四种情况 \\nint vis[1005][1005]; //标记数组 \\n\\nvoid dfs(int x, int y) {\\n\\tvis[x][y] = 1;                //走过了此处就标记为1 \\n\\tfor (int i = 0; i < 4; i++) {\\n\\t\\tint xx = x + dir[i][0];\\n\\t\\tint yy = y + dir[i][1];\\n\\t\\tif (a[xx][yy] == 1 && xx >= 0 && xx <= m + 1 && yy >= 0 && yy <= n + 1 && !vis[xx][yy]) {\\n\\t\\t\\tdfs(xx, yy);\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tcin>>m>>n;\\n\\t\\tcnt = 0;\\n\\t\\tmemset(vis, 0, sizeof(vis));  //每一组数据都要重新初始化标记数组 \\n\\t\\tfor (int j = 1; j <= m; j++) { //将图像从（1，1）开始输入，防止图像出现在边上 \\n\\t\\t\\tfor (int k = 1; k <= n; k++) {\\n\\t\\t\\t\\tcin>>a[j][k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int j = 0; j <= n + 1; j++) { //将最外围一圈赋值为1 \\n\\t\\t\\ta[0][j] = 1;\\n\\t\\t\\ta[m + 1][j] = 1;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j <= m + 1; j++) {\\n\\t\\t\\ta[j][0] = 1;\\n\\t\\t\\ta[j][n + 1] = 1;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j <= m + 1; j++) {\\n\\t\\t\\tfor (int k = 0; k <= n + 1; k++) {\\n\\t\\t\\t\\tif (a[j][k] == 1 && !vis[j][k]) { //如果此处为1且没被走过则开始深搜 \\n\\t\\t\\t\\t\\tdfs(j, k);    \\n\\t\\t\\t\\t\\tcnt++;                        //记录下能深搜区域的个数。 \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (cnt == 2) {                           //区域的个数为2则为yes,否则为no \\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [减肥](http://210.45.175.76/home/problem.php?cid=1059&pid=7)\\n\\n**问题描述**\\n\\n已知在接下来的几天里赛文斯要吃n顿饭，第i顿饭要吃ai的食物，现在赛文斯想减肥，想要节食，所以他有时会不吃饭，但是赛文斯不能连续两顿不吃饭。所以他想知道，在保证不能连续两顿不吃饭前提下，这n顿中，他最少要吃多少食物。\\n\\n**输入描述**\\n\\n第一行是一个整数n，代表接下来有n顿饭（n ≤ 100,000） 第二行有n个数字，a1,a2,……an,代表第i顿饭要吃ai的食物（1 ≤ ai ≤ 100）\\n\\n**输出描述**\\n\\n输出一个整数，代表赛文斯最少要吃多少食物。\\n\\n**样例输入**\\n\\n```c++\\n5\\n3 40 1 6 100                  \\n```\\n\\n**样例输出**\\n\\n```c++\\n10\\n```\\n\\n动规，两个状态，吃饭和没吃饭\\n\\ndp0[i]：表示第 i 天没有吃饭时的最小食物\\n\\ndp1[i]:   表示第 i 天吃饭时的最小食物\\n\\n状态转移方程：\\n\\n**dp0[i] = dp1[i - 1];**\\n\\n**dp1[i] = min(dp0[i - 1] + a[i], dp1[i - 1] + a[i]);**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n;\\nint a[maxn];\\nint dp0[maxn]; // 当天没有吃饭 \\nint dp1[maxn]; // 当天吃饭 \\n\\nint main() {\\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>a[i];\\n\\t}\\n\\tdp0[0] = 0;\\n\\tdp1[0] = a[0];\\n\\tfor (int i = 1; i < n; i++) {\\n\\t\\t// 今天没吃饭，昨天必须吃饭 \\n\\t\\tdp0[i] = dp1[i - 1];\\n\\t\\t// 今天吃饭，昨天可以吃饭，也可以不吃饭，取最小值 \\n\\t\\tdp1[i] = min(dp0[i - 1] + a[i], dp1[i - 1] + a[i]);\\n\\t}\\n\\tcout<<min(dp0[n - 1], dp1[n - 1])<<endl;\\n\\treturn 0; \\n}\\n\\n----------------------------------------------------------------------------------\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n;\\nint a[maxn];\\n\\nint main() {\\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>a[i];\\n\\t}\\n\\tint dp0 = 0;            //第一天不吃 \\n\\tint dp1 = a[0];\\t\\t\\t//第一天吃 \\n\\tfor (int i = 1; i < n; i++) {\\n\\t\\tint temp = dp1;     //因为可以空一天不吃，记录下dp1的值 \\n\\t\\tdp1 = min(dp0 + a[i], dp1 + a[i]); //求出前一天吃和前一天不吃性价比最高的选择 \\n\\t\\tdp0 = temp;         //dp0为这一天不吃的值。 \\n\\t}\\n\\tcout<<min(dp0, dp1)<<endl;  //输出两者的最小值 \\n\\treturn 0; \\n} \\n```\\n\\n## [最大收益](http://210.45.175.76/home/problem.php?cid=1059&pid=8)\\n\\n**问题描述**\\n\\n商店里有n种商品和k个按顺序给出的订单。每种商品给定名称、收益和库存。每个订单给出需求商品和需求数量。编程判断是否能依序满足所有的订单，如果可以，输出收益；否则，输出“-X\\\"，X表示第一个无法满足的订单编号。\\n\\n**输入描述**\\n\\n第1行2个整数n和k, k ≤ n ≤ 10^5。 下面的n行，每行表示一种商品的名称、收益和库存3种信息。 再下面的若干行，每行表示一个订单的需求商品和需求数量两种信息。每种商品的个数保证在int范围内，保证每个订单中都不会出现没有的商品，商品名的长度≤ 20，具体格式参见输入样例。\\n\\n**输出描述**\\n\\n一行一个整数，表示收益，或者\\\"-X\\\"，X表示第一个无法满足的订单编号。\\n\\n**样例输入**\\n\\n```c++\\n3 5\\napple 1 100\\npear 5 90\\nfootball 30 10\\npear 24\\napple 18\\nfootball 4\\npear 1\\nfootball 6            \\n```\\n\\n**样例输出**\\n\\n```c++\\n443                  \\n```\\n\\n依次将订单编号的需求与对应商品的库存比较即可。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\nstruct Node {   //将商品价值和库存放在一个结构体中 \\n\\tint val;\\n\\tint num;\\n} P[maxn];\\n\\nint main() {\\n\\tint n, k;\\n\\tstring name;\\n\\tmap<string, Node> pmap;\\t//定义一个一对一的映射，每个商品的名字和他的价值和库存一对一对应。 \\n\\tcin>>n>>k;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>name>>P[i].val>>P[i].num;\\n\\t\\tpmap.insert(make_pair(name, P[i]));\\n\\t}\\n\\tint cnt;\\n\\tlong long sum = 0;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tcin>>name>>cnt;\\n\\t\\tNode p = pmap[name];  //调出名称为name的映射结构体。 \\n\\t\\tif (p.num >= cnt) {   //如果库存够的话则计算收益，且刷新库存 \\n\\t\\t\\tsum += cnt * p.val;\\n\\t\\t\\tp.num -= cnt;\\n\\t\\t\\tpmap[name] = p;\\n\\t\\t} else {              //如果库存不够的话则输出-X（X为订单编号） \\n\\t\\t\\tcout<<\\\"-\\\"<<i + 1<<endl;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tcout<<sum<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n## [穿越侏罗纪](http://210.45.175.76/home/problem.php?cid=1059&pid=9)\\n\\n**问题描述**\\n\\n小明来到侏罗纪公园游玩，他对穿越侏罗纪这个虚拟现实的游戏很感兴趣。该游戏在一处开阔的平地上，平地面积为n×n。最开始，小明站在起点处(1,1)，最终赢得游戏要达到终点(n,n)，小明每秒可以向东南西北四个方向移动一步。但是该游戏的难度在于，每秒结束时，天上会掉落一块陨石在(x,y)处，小明不能走在陨石上。假如小明已经知道哪些时刻会在哪些点掉落陨石。所以现在你需要判断，小明能否成功走到(n,n)。 保证数据足够弱：也就是说，无需考虑“走到某处被一块陨石砸死”的情况，因为答案不会出现此类情况。\\n\\n**输入描述**\\n\\n首先是一个正整数T（T ≤ 10），表示数据组数。对于每一组数据： 第一行，一个正整数n（n ≤ 1000）。 接下来2n-2行，每行两个正整数x和y，意义是在那一秒结束后，(x,y)将被出现一块陨石。\\n\\n**输出描述**\\n\\n对于每一组数据，输出Yes或No，回答小明能否顺利走到终点。\\n\\n**样例输入**\\n\\n```c++\\n2\\n2\\n1 1\\n2 2\\n5\\n3 3\\n3 2\\n3 1\\n1 2\\n1 3\\n1 4\\n1 5\\n2 2                  \\n```\\n\\n**样例输出**\\n\\n```c++\\nYes\\nYes\\n```\\n\\n**思路一**\\n\\nBFS，输入时，用数组把每秒对应的路障的位置记录下来，索引是秒，值是坐标。在搜索的过程中，每秒结束后，把该秒对应的路障标记出来。（tx[i]，ty[i]，i 是秒，tx[i] 、ty[i] 是坐标）\\n\\n**思路二**\\n\\nBFS，输入时，用 一个二维数组把路障出现的秒记录下来，搜索时，若该坐标有路障，则比较时间判断是否可以进入。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\n\\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint vis[maxn][maxn];\\nint t, n, flag;\\nint tx[2*maxn], ty[2*maxn];\\n\\nstruct Node {\\n\\tint x, y, time;\\n\\tNode():x(),y(),time(){} // 空构造函数\\n    Node(int x, int y, int time):x(x),y(y),time(time){} // 带参构造函数\\n}; \\n\\nvoid bfs(int i, int j) {\\n\\tqueue<Node> q;\\n\\tq.push(Node(i, j, 1));\\n\\tvis[i][j] = 1;\\n\\twhile (!q.empty()) {\\n\\t\\tNode now = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (now.x == n && now.y == n) {\\n\\t\\t\\tflag = 1;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvis[tx[now.time-1]][ty[now.time-1]] = 1;\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = now.x + dir[k][0];\\n\\t\\t\\tint y = now.y + dir[k][1];\\n\\t\\t\\tif (x >= 1 && y >= 1 && x <= n && y <= n && !vis[x][y]) {\\n\\t\\t\\t\\tvis[x][y] = 1;\\n\\t\\t\\t\\tq.push(Node(x, y, now.time + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tmemset(tx, 0, sizeof(tx));\\n\\t\\tmemset(ty, 0, sizeof(ty));\\n\\t\\tflag = 0;\\n\\t\\tcin>>n;\\n\\t\\tfor (int j = 1; j <= 2 * n - 2; j++) {\\n\\t\\t\\tcin>>tx[j]>>ty[j];\\n\\t\\t}\\n\\t\\tbfs(1, 1); \\n\\t\\tif (flag) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n--------------------------------------------------------------------------------------\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\n\\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint vis[maxn][maxn];\\nint t, n, flag;\\nint tt[maxn][maxn];\\n\\nstruct Node {\\n\\tint x, y, time;\\n\\tNode():x(),y(),time(){} // 空构造函数\\n    Node(int x, int y, int time):x(x),y(y),time(time){} // 带参构造函数\\n}; \\n\\nvoid bfs(int i, int j) {\\n\\tqueue<Node> q;\\n\\tq.push(Node(i, j, 1));\\n\\tvis[i][j] = 1;\\n\\twhile (!q.empty()) {\\n\\t\\tNode now = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (now.x == n && now.y == n) {\\n\\t\\t\\tflag = 1;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = now.x + dir[k][0];\\n\\t\\t\\tint y = now.y + dir[k][1];\\n\\t\\t\\tif (x >= 1 && y >= 1 && x <= n && y <= n && !vis[x][y] && (!tt[x][y] || tt[x][y] >= now.time)) {\\n\\t\\t\\t\\tvis[x][y] = 1;\\n\\t\\t\\t\\tq.push(Node(x, y, now.time + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tmemset(tt, 0, sizeof(tt));\\n\\t\\tflag = 0;\\n\\t\\tcin>>n;\\n\\t\\tfor (int j = 1; j <= 2 * n - 2; j++) {\\n\\t\\t\\tcin>>x>>y;\\n\\t\\t\\ttt[x][y] = j;\\n\\t\\t}\\n\\t\\tbfs(1, 1); \\n\\t\\tif (flag) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621084758493.jpg\",\"articleTitle\":\"2021校赛题解\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.93', '安徽省合肥市 联通', '2021-05-15 21:19:25');
INSERT INTO `tb_operation_log` VALUES (92, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [知识竞赛](http://210.45.175.76/home/problem.php?cid=1059&pid=0)\\n\\n**问题描述**\\n\\n最近学校组织了党史知识竞答比赛，比赛采用扣分制方法评分，即扣分越高，名次越低。当比赛结束时，要在现场按照选手的出场顺序宣布最后扣分和最后名次，扣除相同分数的选手具有相同的名次，名次连续编号，不用考虑同名次的选手人数。 例如： 选手序号：1 2 3 4 5 6 选手扣分：5 3 4 7 3 5 输出名次：3 1 2 4 1 3\\n\\n**输入描述**\\n\\n共N+1行，第一行为选手的个数N（1 < N ≤ 50），下面N行按选手序号给出每个选手的扣分，扣分在0~100之间，其中第i行表示序号为i-1的选手的扣分。\\n\\n**输出描述**\\n\\nN行，按序号给出每个选手的名次，第i行表示序号为i的选手的名次。\\n\\n**样例输入**\\n\\n```c++\\n6\\n5\\n3\\n4\\n7\\n3\\n5\\n```\\n\\n**样例输出**\\n\\n```c++\\n3\\n1\\n2\\n4\\n1\\n3\\n```\\n\\n**解题思路**\\n\\n用结构体把扣分情况和序号绑定在一起，先按扣分情况从小到大排序，按扣分情况得出具体排名后再按序号从小到大排序，再输出即可。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint id, score, rank;\\n} Stu[51];\\n\\nbool cmp(Node a, Node b) {    //按扣分从小到大排 \\n\\treturn a.score < b.score;  \\n}\\n\\nbool cmp2(Node a, Node b) {   //按序号从小到大排 \\n\\treturn a.id < b.id;\\n}\\n\\nint main() {\\n\\tint n;\\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tStu[i].id = i;\\n\\t\\tcin>>Stu[i].score;\\n\\t}\\n\\tsort(Stu, Stu + n, cmp);        //按扣分情况从小到大排序 \\n\\tint pre = Stu[0].score;\\n\\tint rank = 1;\\n\\tStu[0].rank = 1;\\n\\tfor (int i = 1; i < n; i++) {\\t//如果用相同的扣分则使其排名相同 \\n\\t\\tif (pre == Stu[i].score) {\\n\\t\\t\\tStu[i].rank = rank;\\n\\t\\t} else {\\n\\t\\t\\tStu[i].rank = ++rank;\\n\\t\\t\\tpre = Stu[i].score;\\n\\t\\t}\\n\\t}\\n\\tsort(Stu, Stu + n, cmp2);       //按序号从小到大排序 \\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcout<<Stu[i].rank<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n\\n-----------------------------------------------------------------------\\n/*\\n\\t方法二，用一个大小 101的数组，记录分数的排名，分数是下标，值是排名，再求前缀和即可\\n*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint n, s;\\nint rk[101];\\nint score[51];\\n\\nint main() {\\n\\tstd::ios::sync_with_stdio(false);\\n    std::cin.tie(0);\\n    \\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>score[i];\\n\\t\\trk[score[i]] = 1;\\n\\t}\\n\\tfor (int i = 1; i < 101; i++) {\\n\\t\\trk[i] += rk[i - 1];\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (rk[score[i]]) {\\n\\t\\t\\tcout<<rk[score[i]]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [螺旋拐弯](http://210.45.175.76/home/problem.php?cid=1059&pid=1)\\n\\n**问题描述**\\n\\n螺旋拐弯是由数字和连线按照顺时针方向画出的图形，如下图所示： 在拐弯时不能与已画出的图形发生碰撞，并且能拐弯时就一定要拐。由图可知，前4次拐弯分别发生在数字2、3、5、7这4个位置。 输入N，计算第N次拐弯发生在哪个数字处？\\n\\n**输入描述**\\n\\n输入只有一行，包括一个整数N (1 ≤ N ≤ 10000)\\n\\n**输出描述**\\n\\n输出第N个弯处的数字。\\n\\n**样例输入**\\n\\n```c++\\n5                 \\n```\\n\\n**样例输出**\\n\\n```c++\\n10\\n```\\n\\n直接根据图中拐弯处的数值求出规律，然后根据规律求出第n个拐弯处的值。规律为每两个拐弯处的相差的值为一个定值，后两个拐弯处的数相差的值比前两个拐弯处相差的值多1。如：前两个为1->2,2->3。后两个为3->5,5->7。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tint n;\\n\\tcin>>n;\\n\\t\\n\\tint x = 1;\\n\\tint step = 1;\\t\\t\\t\\t\\t//统计每两个拐弯处相差的个数 \\n\\tint cnt = 0;\\t\\t\\t\\t\\t//统计拐弯处的个数 \\n\\tfor (int i = 0; i < n; i++) {\\t\\n\\t\\tif (cnt == 2) {\\t\\t\\t\\t//每处理了两个拐弯处后使个数加一且cnt重新计数。 \\n\\t\\t\\tcnt = 0;\\n\\t\\t\\tstep += 1;\\n\\t\\t}\\n\\t\\tx += step;\\n\\t\\tcnt++;\\n\\t}\\n\\tcout<<x<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n## [文件加密](http://210.45.175.76/home/problem.php?cid=1059&pid=2)\\n\\n**问题描述**\\n\\n为了提高信息传输的安全性，我们常常需要对信息进行加密。人们发明了各种各样的加密方式，其中一种方式是，对文中单词进行逆序处理。请你写一个程序，对输入的已加密的文本进行解密。\\n\\n**输入描述**\\n\\n第一行是一个正整数N(1 ≤ N ≤ 1000)，表示后面将有N行已加密的信息。接下来的N行，每行一个不超过1000个字符的字符串，每个字符串中只有英文小写字母和空格组成。注意：可以有空行（即该行无字符出现）和空格行。\\n\\n**输出描述**\\n\\n共N行，每行对应输出解密后的文本。\\n\\n**样例输入**\\n\\n```c++\\n2\\ni ekil siht emag\\n eno  owt   eerht               \\n```\\n\\n**样例输出**\\n\\n```c++\\ni like this game\\n one  two   three               \\n```\\n\\n把每个单词反转即可，注意空格。设置两个指针 l, r，l位单词的开始位置，r位单词的结束位置\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n;\\nstring str;\\nchar cs[1005];\\n\\nvoid reverse(char cs[], int i, int j) {\\n    while (i < j) {\\n        char c = cs[i];\\n        cs[i] = cs[j];\\n        cs[j] = c;\\n        i++;\\n        j--;\\n    }\\n}\\n\\nint main() {\\n\\tint j = 0;\\n\\tcin>>n;\\n\\tgetchar();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\t// 这种方式可以输入空格 \\n\\t\\tgetline(cin, str);\\n\\t\\tint len = str.length();\\n\\t\\t// 转化成字符数组便于反转 \\n\\t\\tfor (j = 0; j <= len; j++) {\\n\\t\\t\\tcs[j] = str[j];\\n\\t\\t}\\n\\t\\tcs[j] = \'\\\\0\';\\n\\t\\tint l = 0, r = 0;\\n\\t\\t// 先忽略前面的空格 \\n\\t\\twhile (cs[l] == \' \' && l < len) {\\n\\t\\t\\tl++;\\n\\t\\t\\tr++;\\n\\t\\t}\\n        while (l < len) {\\n        \\t// 单词刚好结束的结束 \\n            if (cs[r] == \' \' && cs[r - 1] != \' \') {\\n                reverse(cs, l, r - 1);\\n                r++;\\n                l = r;\\n                // l移动到非空格位置，即下一个单词的开始位置 \\n                while (cs[l] == \' \') {\\n                \\tl++;\\n\\t\\t\\t\\t}\\n            }\\n            if (r == len - 1) {\\n                reverse(cs, l, r);\\n                break;\\n            }\\n            r++;\\n        }\\n        cout<<cs;\\n        if (i != n - 1) {\\n        \\tcout<<endl; \\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [化简比例](http://210.45.175.76/home/problem.php?cid=1059&pid=3)\\n\\n**问题描述**\\n\\n在互联网时代，我们经常会在网上看到有针对某个人或某个观点进行投票进行民意调查，投票的结果有若干人赞成，也会有若干人反对。比如，对某一观点表示赞成的有1498人，反对的有902人，则赞同与反对的比例可以简单记为1498:902。 一般情况下，直接把调查结果以实际的比例呈现出来，往往这个比例的数值太大，难以一眼看出它们的关系，大多数民众也不会满意。对上面的例子，如果把赞同与反对的比例记为5:3，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时看起来也比较直观。 现给出赞成人数X，反对人数Y，以及一个上界L，请你编程实现将X:Y化简为X’:Y’，要求在X’和Y’均不大于L且X’与Y’互质（即两个整数的最大公约数是1）的前提下，X/Y≤X’/Y’且X’/Y’-X/Y的值尽可能小。\\n\\n**输入描述**\\n\\n输入共一行，包含三个整数X、Y和L（1 ≤ X ≤ 1000000，1 ≤ Y ≤ 1000000，1 ≤ L ≤ 100），每两个整数之间用一个空格隔开，分别表示赞成人数、反对人数和上界。\\n\\n**输出描述**\\n\\n输出共一行，包含两个整数X’和Y’，中间用一个空格隔开，表示化简后比例。\\n\\n**样例输入**\\n\\n```c++\\n1498 902 10                 \\n```\\n\\n**样例输出**\\n\\n```c++\\n5 3     \\n```\\n\\n暴力，直接根据给定L的范围，依次尝试，与X/Y最接近的就是答案\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tdouble a, b, l, x, y;\\n\\tcin>>a>>b>>l;\\n\\tdouble min = 1000000.0, t, k = 1.0*a/b; // k算出a和b的比值作为精确度。 \\n\\tfor (int i = 1; i <= l; i++) {      \\n\\t\\tfor (int j = 1; j <= l; j++) {         \\n\\t\\t\\tt = 1.0*i/j - k;\\t\\t\\t  // t为每次两个数的比值与精确度相差的大小。 \\n             // 如果 这次t比上次的小，证明这次的精确度更高，保留此次数据。 \\n\\t\\t\\tif (t < min && t >= 0) {\\t\\t  \\n\\t\\t\\t\\tx = i;\\n\\t\\t\\t\\ty = j;\\n\\t\\t\\t\\tmin = t;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tcout<<x<<\\\" \\\"<<y<<endl;\\n\\treturn 0; \\n}\\n```\\n\\n## [布匹裁剪](http://210.45.175.76/home/problem.php?cid=1059&pid=4)\\n\\n**问题描述**\\n\\n布厂有一批布匹，现在想把这些布匹裁剪成一些长度相同的小段布料（布料有可能有剩余），需要得到的小段的数目是给定的。当然，我们希望得到的小段布料越长越好，你的任务是计算能够得到的小段布料的最大长度。布料长度的单位是cm。布匹的长度都是正整数，我们要求切割得到的小段布料的长度也是正整数。 例如有两段布匹长度分别为11和23，要求切割成到等长的6段，很明显能切割出来的小段布料长度最长为5。\\n\\n**输入描述**\\n\\n第一行是两个正整数N和K(1 ≤ N ≤ 100000，1 ≤ K ≤ 100000000)，N是布匹的数目，K是需要得到的小段的数目。接下来的N行，每行有一个1到100000000之间的正整数，表示一段布匹的长度。\\n\\n**输出描述**\\n\\n能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。\\n\\n**样例输入**\\n\\n```c++\\n3 7\\n232\\n124\\n456        \\n```\\n\\n**样例输出**\\n\\n```c++\\n114\\n```\\n\\n算出一个布段的取值范围，再使用二分慢慢的逼近符合情况的最大值。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100001;\\nint a[maxn];\\nint k;\\nint n;\\n\\nint check(long long len) {        // 算出当前长度能剪出的布段数量，与所需的布段数量k比较 \\n\\tlong long num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tnum += a[i] / len;   \\n\\t}\\n\\tif (num >= k) {              //若大于k返回1，小于k返回0 \\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\nint main() {\\n\\tcin>>n>>k;                      \\n\\tint l = 100000001;\\n\\tlong long r = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tscanf(\\\"%d\\\", &a[i]);           \\n\\t\\tr += a[i];               // r为布段总长度       \\n\\t\\tl = min(l, a[i]);        // l为最小的布段长度     \\n\\t}\\n     // 因为布段最小为1cm，所以当布段总长小于需要的布段数时，切不出来，输出0 \\n\\tif (r < k) {                \\n\\t\\tprintf(\\\"0\\\\n\\\");\\n\\t\\treturn 0;\\n\\t}\\n\\tl = l / k;  \\t\\t\\t\\t //二分的最小值\\t\\n\\tr = r / k;\\t\\t\\t\\t\\t //二分的最大值\\t\\n\\tif (r == 1) {\\t\\t\\t\\t //特殊情况单独讨论，不然后面二分会出现除数为0\\n\\t\\tprintf(\\\"1\\\\n\\\");\\n\\t\\treturn 0;\\n\\t}\\n\\tint ans = 0;\\n\\twhile (l <= r) {             //使用二分慢慢逼近最大长度 \\n\\t\\tlong long mid = (l + r) >> 1; \\n\\t\\tif (check(mid)) {\\t\\t \\t\\t\\t\\t\\n\\t\\t\\tans = mid;   \\n\\t\\t\\tl = mid + 1; \\t\\t \\n\\t\\t} else {\\n\\t\\t\\tr = mid - 1;\\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"%d\\\\n\\\", ans);\\n\\treturn 0;\\n}\\n```\\n\\n## [蝈蝈赛马](http://210.45.175.76/home/problem.php?cid=1059&pid=5)\\n\\n**问题描述**\\n\\n卢宝嚣张着要和蝈蝈赛马，并且为了增加难度，卢宝在自己的每匹马上都设置了一个币值，如果卢宝这匹马赢了，那么蝈蝈就要付给卢宝相应的币，同样的，如果蝈蝈赢了卢宝这匹马，卢宝也要给蝈蝈相应的币。每匹马还有一个速度值，速度快的马会获得胜利，速度相同则平局，平局的话蝈蝈也要付给卢宝币。现在卢宝已经安排好了马的上场顺序，以及按照顺序的每匹马的币值。蝈蝈想知道，该怎么安排自己的上场顺序，才能赢得最多的钱或者怎样才能输最少的钱？（如果最后是输钱就输出负数）\\n\\n**输入描述**\\n\\n第一行一个t，代表t组数据（1 ≤ t ≤ 10），每种数据包含四行： 第一行为一个整数n，代表马的数量（1 ≤ n ≤ 1000） 第二行n个数a[i]，代表卢宝各匹马的速度，并且这就是卢宝的上场顺序（1 ≤ a[i] ≤ 100000） 第三行n个数b[i]，代表卢宝各匹马的币值，与速度值一一对应（1 ≤ b[i] ≤ 10000） 第四行n个数c[i]，代表蝈蝈各匹马的速度（1 ≤ c[i] ≤ 100000）\\n\\n**输出描述**\\n\\n每组数据输出一行一个整数，表示蝈蝈可以赢的最多的币（输出非负数），或者输的最少的币（输出负数）。\\n\\n**样例输入**\\n\\n```c++\\n2\\n3\\n40 30 20\\n1 2 3\\n20 30 50\\n5\\n25 25 50 60 10\\n10 50 5 100 30\\n70 5 30 25 40                 \\n```\\n\\n**样例输出**\\n\\n```c++\\n4\\n185\\n```\\n\\n贪心算法，把卢宝的马按金钱从大到小排，蝈蝈的马按速度从大到小排，然后从前往后依次拿出卢宝的马，再从后向前拿蝈蝈的马比较速度，这样就能保证蝈蝈速度比卢宝大的马都是正好比他大的。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nconst int maxn = 100005;\\n\\nstruct Node {\\t\\t\\t\\t\\t//卢宝的马 \\n\\tint speed, money;\\n} Ho[maxn];\\n\\nint b[maxn];                    //蝈蝈的马 \\nint t, n;\\n\\nbool cmp1(Node a, Node b) {     //按金钱从大到小排序 \\n\\treturn a.money > b.money;\\n}\\n\\nbool cmp2(int a, int b) {\\t\\t//从大到小排序 \\n\\treturn a > b;\\n}\\n\\nint  vis[maxn];                //蝈蝈的马的标记数组 \\n\\nint main() {\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tcin>>n;\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tcin>>Ho[j].speed;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tcin>>Ho[j].money;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tcin>>b[j];\\n\\t\\t}\\n\\t\\tsort(Ho, Ho + n, cmp1); //让卢宝的马按金钱从大到小排序 \\n\\t\\tsort(b, b + n, cmp2);   //让蝈蝈的马按速度从大到小排序 \\n\\t\\tint sum = 0;\\n\\t\\tmemset(vis, 0, sizeof(vis));//每一组数据都要初始化标记数组 \\n\\t\\tint len = n - 1;\\t\\t\\t  //蝈蝈的马的数组的下标，因为从0开始所以先减一 \\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint flag = 0;             //标记，若找到了为1，为找到为0\\n\\t\\t\\tfor (int k = len; k >= 0; k--) {  //从后往前找蝈蝈的马，找到比卢宝马速度大的最小值。 \\n\\t\\t\\t\\tif (b[k] > Ho[j].speed && !vis[k]) {//找到了后标记flag且加上相应的金钱 \\n\\t\\t\\t\\t\\tsum += Ho[j].money;\\n\\t\\t\\t\\t\\tvis[k] = 1;\\n\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!flag) {\\t\\t\\t\\t\\t//未找到则减去相应的金钱 \\n\\t\\t\\t\\t// vis[len--] = 1;\\t\\n\\t\\t\\t\\tsum -= Ho[j].money;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [笔迹鉴别](http://210.45.175.76/home/problem.php?cid=1059&pid=6)\\n\\n**问题描述**\\n\\n最近柯南收到了一则来自怪盗基德的预告函，上面写着：“今晚8点，我将前来取走‘命运的宝石’”。然而上一周怪盗基德也发出了一张预告函，写着：“在10周年纪念之时，我将取走 the 8148”。柯南感到很奇怪，因为怪盗基德很少如此频繁地连续作案。于是他仔细比对这两封预告函。柯南发现，上一周的预告函中出现了两次“8”，这次预告函也有一个“8”，但是笔迹并不相同。如图所示，左边两个“8”字均来源于上一周的预告函，右上角留了一个开口；而右边的“8”字来源于本周的预告函，右上角是闭合的。 真 真 假 因此，柯南判断，这次收到的预告函并不是真正的怪盗基德发出的，而是一封伪造的预告函。最终，柯南抓住了伪造预告函的假基德。 现在，请聪明的你也来鉴别一下笔迹图像，判别这些“8”字笔迹的真伪。\\n\\n**输入描述**\\n\\n首先是一个正整数T（T ≤ 10），表示数据组数。对于每一组数据： 第一行，两个正整数m和n（m，n ≤ 1000）分别表示图像的高和宽。接下来有m行，每行，每n个字符，只可能为0 或者1。0表示黑色字迹，1表示白色背景。数据保证每张图像为白底黑字，且含有唯一一个完整的“8”字，不会有缺失，也不存在空白图像或者含有其它内容的数据。 注意，“8”字有可能是歪的或者倒过来的。\\n\\n**输出描述**\\n\\n对于每一组数据，输出Yes或No，代表笔迹真伪。\\n\\n**样例输入**\\n\\n```c++\\n1\\n9 8\\n1 1 1 1 1 1 1 1 \\n1 1 1 0 0 1 1 1 \\n1 1 0 1 1 0 1 1 \\n1 1 0 0 1 0 1 1 \\n1 1 1 0 0 1 1 1 \\n1 1 0 1 1 0 1 1 \\n1 1 0 1 1 0 1 1 \\n1 1 1 0 0 1 1 1 \\n1 1 1 1 1 1 1 1                \\n```\\n\\n**样例输出**\\n\\n```c++\\nNo\\n```\\n\\n此题使用深搜解决，如果8的右上角有开口，则只有两个封闭的区域，如果没有封口，则有三个封闭的区域。为了避免数字8可能与矩阵边缘接触（会导致划分的封闭区域不确定），在矩阵外围包上一层1。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint a[1005][1005];\\nint cnt, flag;\\nint t, m, n;\\nint dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};  //上下左右四种情况 \\nint vis[1005][1005]; //标记数组 \\n\\nvoid dfs(int x, int y) {\\n\\tvis[x][y] = 1;                //走过了此处就标记为1 \\n\\tfor (int i = 0; i < 4; i++) {\\n\\t\\tint xx = x + dir[i][0];\\n\\t\\tint yy = y + dir[i][1];\\n\\t\\tif (a[xx][yy] == 1 && xx >= 0 && xx <= m + 1 && yy >= 0 && yy <= n + 1 && !vis[xx][yy]) {\\n\\t\\t\\tdfs(xx, yy);\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tcin>>m>>n;\\n\\t\\tcnt = 0;\\n\\t\\tmemset(vis, 0, sizeof(vis));  //每一组数据都要重新初始化标记数组 \\n\\t\\tfor (int j = 1; j <= m; j++) { //将图像从（1，1）开始输入，防止图像出现在边上 \\n\\t\\t\\tfor (int k = 1; k <= n; k++) {\\n\\t\\t\\t\\tcin>>a[j][k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int j = 0; j <= n + 1; j++) { //将最外围一圈赋值为1 \\n\\t\\t\\ta[0][j] = 1;\\n\\t\\t\\ta[m + 1][j] = 1;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j <= m + 1; j++) {\\n\\t\\t\\ta[j][0] = 1;\\n\\t\\t\\ta[j][n + 1] = 1;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j <= m + 1; j++) {\\n\\t\\t\\tfor (int k = 0; k <= n + 1; k++) {\\n\\t\\t\\t\\tif (a[j][k] == 1 && !vis[j][k]) { //如果此处为1且没被走过则开始深搜 \\n\\t\\t\\t\\t\\tdfs(j, k);    \\n\\t\\t\\t\\t\\tcnt++;                        //记录下能深搜区域的个数。 \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (cnt == 2) {                           //区域的个数为2则为yes,否则为no \\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [减肥](http://210.45.175.76/home/problem.php?cid=1059&pid=7)\\n\\n**问题描述**\\n\\n已知在接下来的几天里赛文斯要吃n顿饭，第i顿饭要吃ai的食物，现在赛文斯想减肥，想要节食，所以他有时会不吃饭，但是赛文斯不能连续两顿不吃饭。所以他想知道，在保证不能连续两顿不吃饭前提下，这n顿中，他最少要吃多少食物。\\n\\n**输入描述**\\n\\n第一行是一个整数n，代表接下来有n顿饭（n ≤ 100,000） 第二行有n个数字，a1,a2,……an,代表第i顿饭要吃ai的食物（1 ≤ ai ≤ 100）\\n\\n**输出描述**\\n\\n输出一个整数，代表赛文斯最少要吃多少食物。\\n\\n**样例输入**\\n\\n```c++\\n5\\n3 40 1 6 100                  \\n```\\n\\n**样例输出**\\n\\n```c++\\n10\\n```\\n\\n动规，两个状态，吃饭和没吃饭\\n\\ndp0[i]：表示第 i 天没有吃饭时的最小食物\\n\\ndp1[i]:   表示第 i 天吃饭时的最小食物\\n\\n状态转移方程：\\n\\n**dp0[i] = dp1[i - 1];**\\n\\n**dp1[i] = min(dp0[i - 1] + a[i], dp1[i - 1] + a[i]);**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n;\\nint a[maxn];\\nint dp0[maxn]; // 当天没有吃饭 \\nint dp1[maxn]; // 当天吃饭 \\n\\nint main() {\\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>a[i];\\n\\t}\\n\\tdp0[0] = 0;\\n\\tdp1[0] = a[0];\\n\\tfor (int i = 1; i < n; i++) {\\n\\t\\t// 今天没吃饭，昨天必须吃饭 \\n\\t\\tdp0[i] = dp1[i - 1];\\n\\t\\t// 今天吃饭，昨天可以吃饭，也可以不吃饭，取最小值 \\n\\t\\tdp1[i] = min(dp0[i - 1] + a[i], dp1[i - 1] + a[i]);\\n\\t}\\n\\tcout<<min(dp0[n - 1], dp1[n - 1])<<endl;\\n\\treturn 0; \\n}\\n\\n----------------------------------------------------------------------------------\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n;\\nint a[maxn];\\n\\nint main() {\\n\\tcin>>n;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>a[i];\\n\\t}\\n\\tint dp0 = 0;            //第一天不吃 \\n\\tint dp1 = a[0];\\t\\t\\t//第一天吃 \\n\\tfor (int i = 1; i < n; i++) {\\n\\t\\tint temp = dp1;     //因为可以空一天不吃，记录下dp1的值 \\n\\t\\tdp1 = min(dp0 + a[i], dp1 + a[i]); //求出前一天吃和前一天不吃性价比最高的选择 \\n\\t\\tdp0 = temp;         //dp0为这一天不吃的值。 \\n\\t}\\n\\tcout<<min(dp0, dp1)<<endl;  //输出两者的最小值 \\n\\treturn 0; \\n} \\n```\\n\\n## [最大收益](http://210.45.175.76/home/problem.php?cid=1059&pid=8)\\n\\n**问题描述**\\n\\n商店里有n种商品和k个按顺序给出的订单。每种商品给定名称、收益和库存。每个订单给出需求商品和需求数量。编程判断是否能依序满足所有的订单，如果可以，输出收益；否则，输出“-X\\\"，X表示第一个无法满足的订单编号。\\n\\n**输入描述**\\n\\n第1行2个整数n和k, k ≤ n ≤ 10^5。 下面的n行，每行表示一种商品的名称、收益和库存3种信息。 再下面的若干行，每行表示一个订单的需求商品和需求数量两种信息。每种商品的个数保证在int范围内，保证每个订单中都不会出现没有的商品，商品名的长度≤ 20，具体格式参见输入样例。\\n\\n**输出描述**\\n\\n一行一个整数，表示收益，或者\\\"-X\\\"，X表示第一个无法满足的订单编号。\\n\\n**样例输入**\\n\\n```c++\\n3 5\\napple 1 100\\npear 5 90\\nfootball 30 10\\npear 24\\napple 18\\nfootball 4\\npear 1\\nfootball 6            \\n```\\n\\n**样例输出**\\n\\n```c++\\n443                  \\n```\\n\\n依次将订单编号的需求与对应商品的库存比较即可。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\nstruct Node {   //将商品价值和库存放在一个结构体中 \\n\\tint val;\\n\\tint num;\\n} P[maxn];\\n\\nint main() {\\n\\tint n, k;\\n\\tstring name;\\n\\tmap<string, Node> pmap;\\t//定义一个一对一的映射，每个商品的名字和他的价值和库存一对一对应。 \\n\\tcin>>n>>k;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>name>>P[i].val>>P[i].num;\\n\\t\\tpmap.insert(make_pair(name, P[i]));\\n\\t}\\n\\tint cnt;\\n\\tlong long sum = 0;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tcin>>name>>cnt;\\n\\t\\tNode p = pmap[name];  //调出名称为name的映射结构体。 \\n\\t\\tif (p.num >= cnt) {   //如果库存够的话则计算收益，且刷新库存 \\n\\t\\t\\tsum += cnt * p.val;\\n\\t\\t\\tp.num -= cnt;\\n\\t\\t\\tpmap[name] = p;\\n\\t\\t} else {              //如果库存不够的话则输出-X（X为订单编号） \\n\\t\\t\\tcout<<\\\"-\\\"<<i + 1<<endl;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tcout<<sum<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n## [穿越侏罗纪](http://210.45.175.76/home/problem.php?cid=1059&pid=9)\\n\\n**问题描述**\\n\\n小明来到侏罗纪公园游玩，他对穿越侏罗纪这个虚拟现实的游戏很感兴趣。该游戏在一处开阔的平地上，平地面积为n×n。最开始，小明站在起点处(1,1)，最终赢得游戏要达到终点(n,n)，小明每秒可以向东南西北四个方向移动一步。但是该游戏的难度在于，每秒结束时，天上会掉落一块陨石在(x,y)处，小明不能走在陨石上。假如小明已经知道哪些时刻会在哪些点掉落陨石。所以现在你需要判断，小明能否成功走到(n,n)。 保证数据足够弱：也就是说，无需考虑“走到某处被一块陨石砸死”的情况，因为答案不会出现此类情况。\\n\\n**输入描述**\\n\\n首先是一个正整数T（T ≤ 10），表示数据组数。对于每一组数据： 第一行，一个正整数n（n ≤ 1000）。 接下来2n-2行，每行两个正整数x和y，意义是在那一秒结束后，(x,y)将被出现一块陨石。\\n\\n**输出描述**\\n\\n对于每一组数据，输出Yes或No，回答小明能否顺利走到终点。\\n\\n**样例输入**\\n\\n```c++\\n2\\n2\\n1 1\\n2 2\\n5\\n3 3\\n3 2\\n3 1\\n1 2\\n1 3\\n1 4\\n1 5\\n2 2                  \\n```\\n\\n**样例输出**\\n\\n```c++\\nYes\\nYes\\n```\\n\\n**思路一**\\n\\nBFS，输入时，用数组把每秒对应的路障的位置记录下来，索引是秒，值是坐标。在搜索的过程中，每秒结束后，把该秒对应的路障标记出来。（tx[i]，ty[i]，i 是秒，tx[i] 、ty[i] 是坐标）\\n\\n**思路二**\\n\\nBFS，输入时，用 一个二维数组把路障出现的秒记录下来，搜索时，若该坐标有路障，则比较时间判断是否可以进入。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\n\\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint vis[maxn][maxn];\\nint t, n, flag;\\nint tx[2*maxn], ty[2*maxn];\\n\\nstruct Node {\\n\\tint x, y, time;\\n\\tNode():x(),y(),time(){} // 空构造函数\\n    Node(int x, int y, int time):x(x),y(y),time(time){} // 带参构造函数\\n}; \\n\\nvoid bfs(int i, int j) {\\n\\tqueue<Node> q;\\n\\tq.push(Node(i, j, 1));\\n\\tvis[i][j] = 1;\\n\\twhile (!q.empty()) {\\n\\t\\tNode now = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (now.x == n && now.y == n) {\\n\\t\\t\\tflag = 1;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvis[tx[now.time-1]][ty[now.time-1]] = 1;\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = now.x + dir[k][0];\\n\\t\\t\\tint y = now.y + dir[k][1];\\n\\t\\t\\tif (x >= 1 && y >= 1 && x <= n && y <= n && !vis[x][y]) {\\n\\t\\t\\t\\tvis[x][y] = 1;\\n\\t\\t\\t\\tq.push(Node(x, y, now.time + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tmemset(tx, 0, sizeof(tx));\\n\\t\\tmemset(ty, 0, sizeof(ty));\\n\\t\\tflag = 0;\\n\\t\\tcin>>n;\\n\\t\\tfor (int j = 1; j <= 2 * n - 2; j++) {\\n\\t\\t\\tcin>>tx[j]>>ty[j];\\n\\t\\t}\\n\\t\\tbfs(1, 1); \\n\\t\\tif (flag) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n--------------------------------------------------------------------------------------\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\n\\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint vis[maxn][maxn];\\nint t, n, flag;\\nint tt[maxn][maxn];\\n\\nstruct Node {\\n\\tint x, y, time;\\n\\tNode():x(),y(),time(){} // 空构造函数\\n    Node(int x, int y, int time):x(x),y(y),time(time){} // 带参构造函数\\n}; \\n\\nvoid bfs(int i, int j) {\\n\\tqueue<Node> q;\\n\\tq.push(Node(i, j, 1));\\n\\tvis[i][j] = 1;\\n\\twhile (!q.empty()) {\\n\\t\\tNode now = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (now.x == n && now.y == n) {\\n\\t\\t\\tflag = 1;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\tint x = now.x + dir[k][0];\\n\\t\\t\\tint y = now.y + dir[k][1];\\n\\t\\t\\tif (x >= 1 && y >= 1 && x <= n && y <= n && !vis[x][y] && (!tt[x][y] || tt[x][y] >= now.time)) {\\n\\t\\t\\t\\tvis[x][y] = 1;\\n\\t\\t\\t\\tq.push(Node(x, y, now.time + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tcin>>t;\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tmemset(tt, 0, sizeof(tt));\\n\\t\\tflag = 0;\\n\\t\\tcin>>n;\\n\\t\\tfor (int j = 1; j <= 2 * n - 2; j++) {\\n\\t\\t\\tcin>>x>>y;\\n\\t\\t\\ttt[x][y] = j;\\n\\t\\t}\\n\\t\\tbfs(1, 1); \\n\\t\\tif (flag) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621084758493.jpg\",\"articleTitle\":\"2021校赛题解\",\"categoryId\":15,\"id\":54,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.93', '安徽省合肥市 联通', '2021-05-15 21:20:36');
INSERT INTO `tb_operation_log` VALUES (93, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [最多约数](https://acm.webturing.com/problem.php?cid=1643&pid=0&langmask=262141&puzzle_mask=0)\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 2000000;\\nint dp[maxn]; // dp[i] 存储 i 的约数\\n\\nint main() {\\n\\tint a, b;\\n\\tcin>>a>>b;\\n\\tint res = 0;\\n\\tfor (int i = a; i <= b; i++) {\\n        // 以 i 的倍数进行增加\\n\\t\\tfor (int j = i; j <= b; j += i) {\\n\\t\\t\\tdp[j]++; // dp[j]++是因为，i 此时是 j 的约数，j = n*i;\\n\\t\\t}\\n\\t\\tres = max(res, dp[i]);\\n\\t}\\n\\tcout<<res<<endl;\\n\\treturn 0;\\n} \\n```\\n\\n## [会场安排问题](https://acm.webturing.com/problem.php?cid=1643&pid=1&langmask=262141&puzzle_mask=0)\\n\\n每个活动都有一个开始时间和一个结束时间，所有需要的会议数是活动之间重叠的次数 + 1\\n\\n```c++\\n#include<bits/stdc++.h> \\nusing namespace std;\\n\\nconst int maxn = 1000001;\\n\\ntypedef struct node {\\n\\tint start;\\n\\tint end;\\n} Act;\\n\\nbool cmp(Act a, Act b) {\\n\\treturn a.start < b.start;\\n}\\n\\n// 活动数组 \\nAct acts[maxn];\\nint k;\\nint main()\\n{\\n\\tcin>>k;\\n\\tfor (int i = 0; i < k; i++) {\\n\\t\\tcin>>acts[i].start>>acts[i].end;\\n\\t}\\n\\t// 把所有活动按开始时间升序进行排列 \\n\\tsort(acts, acts + k, cmp);\\n\\tint max = 0;\\n\\tfor (int i = 1; i < k; i++) {\\n\\t\\tint count = 1;\\n\\t\\tfor (int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t// 如果两个活动时间有重叠，则需要新开会议 \\n\\t\\t\\tif (acts[i].start < acts[j].end) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (count > max) {\\n\\t\\t\\tmax = count;\\n\\t\\t}\\n\\t}\\n\\tcout<<max<<endl;\\n\\treturn 0;\\n}\\n\\n----------------------------------------------------------------------------------\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\ntypedef long long LL;\\nconst int N = 1e7 + 3;\\n\\nint cnt[N];\\n\\nint main() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    int k;\\n    cin >> k;\\n    for (int i = 1; i <= k; i++) {\\n        int l, r;\\n        cin >> l >> r;\\n        cnt[l]++;\\n        cnt[r]--;\\n    }\\n    int ans = 0;\\n    for (int i = 1; i < N; i++) {\\n    \\tcnt[i] += cnt[i - 1];\\n\\t\\tans = max(ans, cnt[i]);\\n\\t}\\n    cout << ans << endl;\\n    return 0;\\n}\\n```\\n\\n## [数位的幂](https://acm.webturing.com/problem.php?cid=1643&pid=2&langmask=262141&puzzle_mask=0)\\n\\n快速幂 + 模运算\\n\\n1. (a + b) % p = (a % p + b % p) % p （1）\\n2. (a - b) % p = (a % p - b % p ) % p （2）\\n3. **(a \\\\* b) % p = (a % p * b % p) % p （3）**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int P = 1000000007;\\n\\nlong long fastPower(long long base, long long power) {\\n    long long result = 1;\\n    while (power > 0) {\\n        if (power & 1) {\\n            result = result * base % P;\\n        }\\n        power >>= 1;\\n        base = (base * base) % P;\\n    }\\n    return result;\\n}\\n\\n\\nint main() {\\n\\tstring s;\\n\\tcin>>s;\\n\\tlong long res = 1;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tlong long x = s[i] - \'0\';\\n\\t\\tres *= fastPower(x, i + 1);\\n\\t\\tres %= P;\\n\\t}\\n\\tcout<<res<<endl;\\n    return 0;\\n}\\n\\n--------------------------------------------------------------------------------\\n// 优化版本\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\ntypedef long long ll;\\nconst ll mod = 1000000007;\\nconst int maxn = 1000001;\\n\\nll quickpw(ll a, ll b) {\\n    ll ans = 1, base = a;\\n    while (b != 0) {\\n        if (b & 1 != 0)\\n            ans = ans * base % mod;\\n        base = base * base % mod;\\n        b >>= 1;\\n    }\\n    return ans % mod;\\n}\\n\\nchar c[maxn];\\n\\nint main() {\\n    while (~scanf(\\\"%s\\\", c)) {\\n        ll a[11];\\n        ll ans = 1;\\n        memset(a, 0, sizeof(a));\\n        int len = strlen(c);\\n        for (int i = 0; i < len; i++) {\\n            a[c[i] - \'0\'] += (i + 1);\\n        }\\n        for (int i = 1; i < 10; i++) {\\n            if (a[i]) {\\n                ans = ans * quickpw(i, a[i]) % mod;\\n            }\\n        }\\n        cout << ans % mod << endl;\\n    }\\n    return 0;\\n}\\n```\\n\\n## [Search - Allocation](https://acm.webturing.com/problem.php?cid=1643&pid=3&langmask=262141&puzzle_mask=0)\\n\\n二分，最大值最小化\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint n, m; // 分m段，则要划出m-1条线\\nint money[maxn];\\n\\nint check(int k) { // k是所有段中的最大值，希望其最小\\n\\tint sum = 0, num = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n         // 如果和超过了最大值说明需要将其分段，线段数加1，重新开始计算sum\\n\\t\\tif (sum + money[i] > k) {  \\n\\t\\t\\tsum = money[i];\\n\\t\\t\\tnum++; \\n\\t\\t} else {\\n\\t\\t\\tsum += money[i];\\n\\t\\t}\\n\\t} \\n\\tif (num >= m) {  // 所加的线段数超过了要求的m-1条，说明这个最大和是非法解\\n\\t\\treturn 0;\\n\\t}\\n\\treturn 1;\\n}\\n\\nint main() {\\n\\tcin>>n>>m;\\n    // l，r 为左右边界\\n\\tint l = 0, r = 0, ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t    cin>>money[i];\\n\\t\\tl = max(l, money[i]);\\n\\t\\tr += money[i];\\n\\t}\\n\\twhile (l <= r) {\\n\\t\\tint mid = (l + r) >> 1;\\n\\t\\tif (check(mid)) { // 符合，往左走\\n\\t\\t\\tans = mid;\\n\\t\\t\\tr = mid - 1;  \\n\\t\\t} else { // 不符合，往右走\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}\\n\\t}\\n\\tcout<<ans<<endl;\\n\\treturn 0;\\n} \\n```\\n\\n## [火柴](https://acm.webturing.com/problem.php?cid=1643&pid=4&langmask=262141&puzzle_mask=0)\\n\\n贪心\\n\\n每个数字都有对应的火柴数量，根据输入的数可以确定总的火柴数，因为要用这些火柴拼出最大的数，所以应该从9往前尝试，但是尝试的过程中需要判断是否满足条件。2，7分别是最小、最大能拼出数字的火柴数，通过这可以确定剩余火柴数的范围。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 每个数字对应的火彩数量 \\nint hcs[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\\nint t, n, sum, k;\\nchar ch;\\n\\n// i 剩余的数字数，j剩余的火彩数 \\nbool judge(int i, int j)  {\\n\\t// 2 和 7 是数字对应的最小和最大火柴数量 \\n\\treturn i * 2 <= j && j <= i * 7;\\n}\\n\\nint main() {\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tchar x;\\n\\t\\tsum = 0; // 火柴数量 \\n\\t\\tcin>>n;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tcin>>ch;\\n\\t\\t\\tsum += hcs[ch - \'0\'];  // 总的火柴数 \\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t// 重新排列后数要最大，所以要从9开始  \\n\\t\\t\\tk = 9;  \\n\\t\\t\\t// 判断是否是最后一位，如果是最后一位，sum应该和某个数字对应的火彩数相等 \\n\\t\\t\\tif (i == n) {\\n\\t\\t\\t\\twhile (sum != hcs[k]) {\\n\\t\\t\\t\\t\\tk--;\\t\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\tcout<<k;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 剩下的火柴数量应该在最小最大直接 \\n\\t\\t\\t// 如果不满足条件，就继续往下判断 \\n\\t\\t\\twhile (!judge(n - i, sum - hcs[k])) {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\tsum -= hcs[k];\\n\\t\\t\\tcout<<k;\\n\\t\\t}\\n\\t\\tcout<<endl; \\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [异或和(xorsum)](https://acm.webturing.com/problem.php?cid=1643&pid=5&langmask=262141&puzzle_mask=0)\\n\\n[参考链接](https://blog.csdn.net/liupang14159/article/details/115607276)\\n\\n+ 异或是不进位的加法\\n+ 进位加法和不进位加法相等，说明没有发生进位\\n+ 如果[l,r]区间的加法不进位，那么以r为右端点，左端点在[l,r]中的(l,r)都可行\\n+ 新加入一个右端点，那么有可能会出现进位，往右移动左端点，使之不进位。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n\\tlong long n;\\n\\tcin >> n;\\n\\tlong long a[n];\\n\\tfor (long long i = 0; i <n ; i++) \\n\\t\\tcin >> a[i];\\n\\tlong long s = 0, l = 0, ans = 0;\\n\\t// 异或相当于不进位的加法 \\n\\tfor (long long i = 0; i < n; i++) {\\n\\t\\twhile ((s ^ a[i]) != s + a[i]) {\\n\\t\\t\\ts ^= a[l++];\\n\\t\\t}\\n\\t\\tans += i - l + 1;\\n\\t\\ts ^= a[i];\\n\\t}\\n\\tcout<<ans<<endl;\\n\\treturn 0;\\n}\\n\\n// 前缀和的思想\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\ntypedef long long ll;\\nconst int N = 2e5 + 10;\\nll sum[N], X[N];\\nll a[N];\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    for (int i = 1; i <= n; i++) {\\n    \\tscanf(\\\"%lld\\\", &a[i]);\\n\\t}\\n    sum[1] = X[1] = a[1];\\n    // 求出前缀和，以及前几项的异或结果\\n    for (int i = 2; i <= n; i++) {\\n    \\tsum[i] = sum[i - 1] + a[i];\\n\\t\\tX[i] = X[i - 1] ^ a[i];\\n\\t}\\n    ll ans = 0;\\n    int l = 0;\\n    // 遍历依次比较即可\\n    for (int r = 1; r <= n; r++) {\\n        // sum[r] - sum[l] 为 区间(l, r]的和，左开右闭区间\\n        // X[r] ^ X[l]) 为 (l, r]的异或结果\\n        while (sum[r] - sum[l] != (X[r] ^ X[l])) {\\n        \\tl++;\\n\\t\\t}\\n\\t\\tans += r - l;\\n    }\\n    printf(\\\"%lld\\\\n\\\", ans);\\n    return 0;\\n}\\n```\\n\\n## [五个数AB_CDE乘积最小](https://acm.webturing.com/problem.php?cid=1643&pid=6&langmask=262141&puzzle_mask=0)\\n\\n全排列\\n\\n```c++\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint a[5];\\nint n = 5;\\n\\nint main() {\\n    for (int i = 0; i < n; i++) {\\n    \\tcin >> a[i];\\n\\t}\\n    // 注意需要先排序，与next_permutation函数的特性有关\\n    sort(a, a + 5);\\n    int best = INT_MAX;\\n    do {\\n        if (a[0] == 0 || a[3] == 0) {\\n        \\tcontinue;\\n\\t\\t}\\n        int cur = (a[0] * 100 + a[1] * 10 + a[2]) * (a[3] * 10 + a[4]);\\n        best = min(cur, best);\\n        // next_permutation，下一个排列，全排列函数，每次循环对应一个排列，类似与升序\\n  // 若：a[3] = {1, 2, 3}，则该函数的结果为{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}\\n  // 若：a[3] = {3,1,2}，则该函数的结果为{3,1,2},{3,2,1}，这也是前面升序排序的原因\\n  // 与之对应的还有一个prev_permutation函数，前一个排列，对a[3] = {3,1,2}，结果为{3,1,2},{2,3,1},\\n        // {2,1,3},{1,3,2},{1,2,3}，类似于降序\\n    } while (next_permutation(a, a + n));\\n    cout << best << endl;\\n    return 0;\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620460201284.jpg\",\"articleTitle\":\"2021安徽省程序设计网络赛题解\",\"categoryId\":15,\"id\":46,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.93', '安徽省合肥市 联通', '2021-05-15 21:49:29');
INSERT INTO `tb_operation_log` VALUES (94, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [HDU-1166 敌兵布阵](http://acm.hdu.edu.cn/showproblem.php?pid=1166): 区间求和、单点修改、区间查询\\n\\n**Problem Description**\\n\\nC国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。\\n中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:\\\"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：\\\"我知错了。。。\\\"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.\\n\\n**Input**\\n\\n第一行一个整数T，表示有T组数据。\\n每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。\\n接下来每行有一条命令，命令有4种形式：\\n(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）\\n(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;\\n(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数;\\n(4)End 表示结束，这条命令在每组数据最后出现;\\n每组数据最多有40000条命令\\n\\n**Output**\\n\\n对第i组数据,首先输出“Case i:”和回车,\\n对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10\\n1 2 3 4 5 6 7 8 9 10\\nQuery 1 3\\nAdd 3 6\\nQuery 2 7\\nSub 10 2\\nAdd 6 3\\nQuery 3 10\\nEnd \\n```\\n\\n**Sample Output**\\n\\n```c++\\nCase 1:\\n6\\n33\\n59\\n```\\n\\n **题解**：模板题\\n\\n```c++\\n#include<iostream>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 50005;\\nint a[maxn], t[maxn<<2];\\nint ans, T, n;\\n\\nvoid pushup(int i) {\\n\\tt[i] = t[i<<1] + t[i<<1|1];\\n}\\n\\nvoid build(int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = a[left];\\n\\t\\treturn;\\n\\t}\\n\\tint mid = left + ((right - left) >> 1);\\n\\tbuild(left, mid, index<<1);\\n\\tbuild(mid + 1, right, index<<1|1);\\n\\tpushup(index);\\n}\\n\\nvoid update(int p, int v, int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] += v;\\n\\t} else {\\n\\t\\tint mid = left + ((right - left) >> 1);\\n\\t\\tif (p <= mid) {\\n\\t\\t\\tupdate(p, v, left, mid, index << 1);\\n\\t\\t} else {\\n\\t\\t\\tupdate(p, v, mid + 1, right, index<<1|1);\\n\\t\\t}\\n\\t\\tpushup(index);\\n\\t}\\n}\\n\\nint query(int index, int L, int R, int l, int r) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn t[index];\\n\\t}\\n\\tint s = 0;\\n\\tint mid = l + ((r - l) >> 1);\\n\\tif (L <= mid) {\\n\\t\\ts += query(index<<1, L, R, l, mid);\\n\\t} \\n\\tif (R > mid) {\\n\\t\\ts += query(index<<1|1, L, R, mid + 1, r);\\n\\t}\\n\\treturn s;\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tscanf(\\\"%d\\\", &T);\\n\\tfor (int k = 1; k <= T; k++) {\\n\\t\\tprintf(\\\"Case %d:\\\\n\\\", k);\\n\\t\\tcin>>n;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tchar str[20];\\n\\t\\twhile (scanf(\\\"%s\\\", str) && str[0] != \'E\') {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\t\\t\\tif (str[0] == \'Q\') {\\n\\t\\t\\t\\tcout<<query(1, x, y, 1, n)<<endl;\\n\\t\\t\\t}\\n\\t\\t\\tif (str[0] == \'A\') {\\n\\t\\t\\t\\tupdate(x, y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (str[0] == \'S\') {\\n\\t\\t\\t\\tupdate(x, -y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [HDU-1754 I Hate It](http://acm.hdu.edu.cn/showproblem.php?pid=1754): 区间最值、单点修改、区间查询\\n\\n**Problem Description**\\n\\n很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。\\n这让很多学生很反感。\\n不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\\n\\n**Input**\\n\\n本题目包含多组测试，请处理到文件结束。\\n在每个测试的第一行，有两个正整数 N 和 M ( 0<N<=200000,0<M<5000 )，分别代表学生的数目和操作的数目。\\n学生ID编号分别从1编到N。\\n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。\\n接下来有M行。每一行有一个字符 C (只取\'Q\'或\'U\') ，和两个正整数A，B。\\n当C为\'Q\'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。\\n当C为\'U\'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。\\n\\n**Output**\\n\\n对于每一次询问操作，在一行里面输出最高成绩。\\n\\n**Sample Input**\\n\\n```C++\\n5 6\\n1 2 3 4 5\\nQ 1 5\\nU 3 6\\nQ 3 4\\nQ 4 5\\nU 2 9\\nQ 1 5\\n```\\n\\n**Sample Output**\\n\\n```C++\\n5\\n6\\n5\\n9\\n\\nHint\\nHuge input,the C function scanf() will work better than cin\\n```\\n\\n**题解**：模板题\\n\\n```c++\\n// 最值-单点更新，批量查询\\n#include<iostream>\\n#include<algorithm>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int INF = 1e8;\\nconst int maxn = 2000005;\\nint a[maxn], t[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tt[i] = max(t[i<<1], t[i<<1|1]);\\n}\\n\\nvoid build(int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = a[left];\\n\\t\\treturn;\\n\\t}\\n\\tint mid = left + ((right - left) >> 1);\\n\\tbuild(left, mid, index<<1);\\n\\tbuild(mid + 1, right, index<<1|1);\\n\\tpushup(index);\\n}\\n\\nvoid update(int p, int v, int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = v;\\n\\t} else {\\n\\t\\tint mid = left + ((right - left) >> 1);\\n\\t\\tif (p <= mid) {\\n\\t\\t\\tupdate(p, v, left, mid, index << 1);\\n\\t\\t} else {\\n\\t\\t\\tupdate(p, v, mid + 1, right, index<<1|1);\\n\\t\\t}\\n\\t\\tpushup(index);\\n\\t}\\n}\\n\\nint query(int index, int L, int R, int l, int r) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn t[index];\\n\\t}\\n\\tint smax = -INF;\\n\\tint mid = l + ((r - l) >> 1);\\n\\tif (L <= mid) {\\n\\t\\tsmax = max(smax, query(index<<1, L, R, l, mid));\\n\\t} \\n\\tif (R > mid) {\\n\\t\\tsmax = max(smax, query(index<<1|1, L, R, mid + 1, r));\\n\\t}\\n\\treturn smax;\\n}\\n\\nint n, m;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tchar c;\\n\\t\\tint x, y;\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tscanf(\\\" %c%d%d\\\", &c, &x, &y);\\n\\t\\t\\tif (c == \'Q\') {\\n\\t\\t\\t\\tprintf(\\\"%d\\\\n\\\", query(1, x, y, 1, n));\\n\\t\\t\\t} else if (c == \'U\') {\\n\\t\\t\\t\\tupdate(x, y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [HDU-2795 Billboard](http://acm.hdu.edu.cn/showproblem.php?pid=2795): 区间最值、单点更新、区间查询\\n\\n**Problem Description**\\n\\nAt the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.\\nOn September 1, the billboard was empty. One by one, the announcements started being put on the billboard.\\nEach announcement is a stripe of paper of unit height. More specifically, the i-th announcement is a rectangle of size 1 * wi.\\nWhen someone puts a new announcement on the billboard, she would always choose the topmost possible position for the announcement. Among all possible topmost positions she would always choose the leftmost one.\\nIf there is no valid location for a new announcement, it is not put on the billboard (that\'s why some programming contests have no participants from this university).\\nGiven the sizes of the billboard and the announcements, your task is to find the numbers of rows in which the announcements are placed.\\n\\n**Input**\\n\\nThere are multiple cases (no more than 40 cases).\\nThe first line of the input file contains three integer numbers, h, w, and n (1 <= h,w <= 10^9; 1 <= n <= 200,000) - the dimensions of the billboard and the number of announcements.\\nEach of the next n lines contains an integer number wi (1 <= wi <= 10^9) - the width of i-th announcement.\\n\\n**Output**\\n\\nFor each announcement (in the order they are given in the input file) output one number - the number of the row in which this announcement is placed. Rows are numbered from 1 to h, starting with the top row. If an announcement can\'t be put on the billboard, output \\\"-1\\\" for this announcement.\\n\\n**Sample Input**\\n\\n```C++\\n3 5 5\\n2\\n4\\n3\\n3\\n3\\n```\\n\\n**Sample Output**\\n\\n```C++\\n1\\n2\\n1\\n3\\n-1\\n```\\n\\n**题解：**\\n\\n​        该题的大意就是在一块广告牌上张贴公告，广告牌有高宽限制，公告默认高度为1，输入广告牌的高度、宽度、公告的数量及每个公告的宽度，输出公告张贴的行号。（广告张贴高度优先，从高往低贴，高度一致，尽量贴左侧）\\n\\n​\\t用线段树的每个结点存储对应区间内最大的那一行的剩余宽度，只要维护好每个区间的最大值就行了。输入每一个公告的宽度，与树根比较，如果大于树根对应的最大宽度，直接输出-1，否则，与左子树比较，若比它小，就查询左子树，否则查询右子树。查询到之后再减去相应的宽度。\\n\\n​\\t如果广告牌的高度大于公告的数量时，即 h > n，令 h = n 。高出的部分没有意义。每行只能贴一个公告。\\n\\n```c++\\n// 最值-单点更新、批量查询\\n#include<iostream>\\n#include<algorithm>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\n#define maxn 200005\\nint tree[maxn<<2]; //每个结点存储的是宽度的最大值，区间为高度的区间 \\nint n, h, w, x;\\n\\nvoid pushup(int root) {\\n\\ttree[root] = max(tree[root<<1], tree[root<<1|1]);\\n}\\n\\nvoid build(int l, int r, int root) {\\n    if (l == r) {\\n        tree[root] = w; //初始高度均为w \\n        return;\\n    }\\n    int mid = (l + r) >> 1;\\n    build(l, mid, root<<1);\\n    build(mid + 1, r, root<<1|1);\\n    pushup(root);\\n}\\n\\nint query(int val, int l, int r, int root) {\\n    if (l == r) { //查询到合适的高度 \\n        tree[root] -= val; //对应的宽度减少val \\n        return l; //返回行号 \\n    }\\n    int mid = (l + r) >> 1;\\n    int ans;\\n    if (tree[root<<1] >= val) { //如果左子树的宽度最大值大于val，则去左子树查询 \\n    \\tans = query(val, l, mid, root<<1);\\n\\t} else { //否则，去右子树查询 \\n\\t\\tans = query(val, mid + 1, r, root<<1|1);\\t\\n\\t}  \\n    pushup(root);\\n    return ans;\\n}\\n\\nint main() {\\n    while (~scanf(\\\"%d%d%d\\\", &h, &w, &n)) {\\n        if (h > n) { //如果高度超过了广告牌的个数，高度置为个数，每层只能放一个广告牌 \\n        \\th = n;\\t\\n\\t\\t}  \\n        build(1, h, 1);\\n        for (int i = 1; i <= n; i++) {\\n            scanf(\\\"%d\\\", &x);\\n            if (x > tree[1]) { //如果宽度大于最大宽度，则输出-1 \\n            \\tprintf(\\\"%d\\\\n\\\", -1);\\n\\t\\t\\t} else { //否则，在线段树中查询 \\n\\t\\t\\t\\tprintf(\\\"%d\\\\n\\\", query(x, 1, h, 1));\\n\\t\\t\\t}     \\n        }\\n    }\\n    return 0;\\n}\\n```\\n\\n### [POJ-2828 Buy Tickets](http://poj.org/problem?id=2828): 排队、区间求和、单点更新\\n\\n**Description**\\n\\n*Railway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…*\\n\\nThe Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.\\n\\nIt was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!\\n\\nPeople kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.\\n\\n**Input**\\n\\nThere will be several test cases in the input. Each test case consists of *N* + 1 lines where *N* (1 ≤ *N* ≤ 200,000) is given in the first line of the test case. The next *N* lines contain the pairs of values *Posi* and *Vali* in the increasing order of *i* (1 ≤ *i* ≤ *N*). For each *i*, the ranges and meanings of *Posi* and *Vali* are as follows:\\n\\n- *Posi* ∈ [0, *i* − 1] — The *i*-th person came to the queue and stood right behind the *Posi*-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.\\n- *Vali* ∈ [0, 32767] — The *i*-th person was assigned the value *Vali*.\\n\\nThere no blank lines between test cases. Proceed to the end of input.\\n\\n**Output**\\n\\nFor each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.\\n\\n**Sample Input**\\n\\n```C++\\n4\\n0 77\\n1 51\\n1 33\\n2 69\\n4\\n0 20523\\n1 19243\\n1 3890\\n0 31492\\n```\\n\\n**Sample Output**\\n\\n```C++\\n77 33 69 51\\n31492 20523 3890 19243\\n```\\n\\n**Hint**  \\n\\n​      The figure below shows how the Little Cat found out the final order of people in the queue described in the first test case of the sample input.\\n\\n![img](http://poj.org/images/2828.gif)\\n\\n**题解：**\\n\\n​\\t题目大意，插队的问题，每个案例给出 n ，代表有 n 个插队的，每个给出 p, v，意思是代号为 v 的人插在了第 p 个人的后面，问最后的队伍的排列。\\n\\n​\\t一开始的队列是空的，如果输入i，j：代表代号为 j 的人插在代号为 i 的人的后面，也就是说他前面一定有了 i 个人，而他是第 i + 1 个人。\\n\\n​\\t所以从后往前推导，最后的人选定的位置是不会变的，同样，在第 i 个人后面插队，他的前面一定要留下 i 个空位。用线段树的每个结点存储对应区间的空位数的和。建树时叶子结点默认的空位为 1，每次输入 p 和 v 时，更新位数和为 p + 1 的结点，对应的位数和减 1，用数组记录对应的位置和序号。\\n\\n```c++\\n// 排队，求和-单点更新 \\n// 从后往前进行 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 2e5 + 5;\\nint sum[maxn<<2], b[maxn]; //sum中的每个结点存储对应区间中的空位数，b用来记录排队序列 \\n\\nstruct node {\\n\\tint p;\\n\\tint num;\\n} a[maxn];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] + sum[i<<1|1];\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\nvoid update(int p, int num, int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tsum[i]--;\\n\\t\\tb[l] = num;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tif (sum[i<<1] >= p) {\\n\\t\\tupdate(p, num, l, mid, i<<1); \\n\\t} else {\\n\\t// p-sum[i<<1]，从后往前推导，在第p个人后插队，他的前面一定要有p个空位，所以要减去左边的空位数 \\n\\t\\tupdate(p - sum[i<<1], num, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n} \\n\\nint main() {\\n\\tint n;\\n\\twhile (scanf(\\\"%d\\\", &n) != EOF) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &a[i].p, &a[i].num);\\n\\t\\t\\ta[i].p++; //开始把位置都加1，更新时只需找到sum为p的结点\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n        // 从后往前推\\n\\t\\tfor (int i = n; i > 0; i--) {\\n\\t\\t\\tupdate(a[i].p, a[i].num, 1, n, 1);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tprintf(\\\"%d \\\", b[i]);\\n\\t\\t}\\n\\t\\tprintf(\\\"\\\\n\\\");\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n### [HDU-1698 Just a Hook](http://acm.hdu.edu.cn/showproblem.php?pid=1698): 区间修改、延迟标记、区间求和\\n\\n**Problem Description**\\n\\nIn the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.\\n![img](http://acm.hdu.edu.cn/data/images/C116-1010-1.JPG)\\nNow Pudge wants to do some operations on the hook.\\nLet us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.\\nThe total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:\\nFor each cupreous stick, the value is 1.\\nFor each silver stick, the value is 2.\\nFor each golden stick, the value is 3.\\nPudge wants to know the total value of the hook after performing the operations.\\nYou may consider the original hook is made up of cupreous sticks.\\n\\n**Input**\\n\\nThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.\\nFor each case, the first line contains an integer N, 1<=N<=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0<=Q<=100,000, which is the number of the operations.\\nNext Q lines, each line contains three integers X, Y, 1<=X<=Y<=N, Z, 1<=Z<=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.\\n\\n**Output**\\n\\nFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10\\n2\\n1 5 2\\n5 9 3\\n```\\n\\n**Sample Output**\\n\\n```C++\\nCase 1: The total value of the hook is 24.\\n```\\n\\n**题解：**\\n\\n​\\t题目大意：有T组样例，每组样例给出n个棍子，开始时每个棍子的价值均为1，给出q个操作，可以把编号[x,y]之间的棍子d的价值改为z（z可以是1，2，3），求最终价值。\\n\\n​\\t线段树每个结点存储对应区间的价值和，开始叶子结点默认价值为1。区间修改模板。\\n\\n```c++\\n// 区间染色-区间修改，延迟标记 ，区间求和 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint lazy[maxn<<2];\\nint sum[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] + sum[i<<1|1];\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tlazy[i] = 0;\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1; // 初始值为1 \\n\\t\\treturn; \\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\n//更新子树的lazy值\\nvoid pushdown(int l, int r, int i) {\\n\\tint mid = (l + r) >> 1;\\n\\tif (lazy[i]) { //如果有lazy标记\\n\\t\\tlazy[i<<1] = lazy[i]; //更新左子树的lazy值 \\n\\t\\tlazy[i<<1|1] = lazy[i]; //更新右子树的lazy值\\n\\t\\tsum[i<<1] = lazy[i<<1] * (mid - l + 1); //更新左子树的和 \\n\\t\\tsum[i<<1|1] = lazy[i<<1|1] * (r - mid); //更新右子树的和 \\n\\t\\tlazy[i] = 0; //取消标记 \\n\\t}\\n}\\n\\nvoid update(int l, int r, int z, int L, int R, int i) {\\n\\tif (l <= L && R <= r) {\\n\\t\\tlazy[i] = z;\\n\\t\\tsum[i] = lazy[i] * (R - L + 1);\\n\\t\\treturn;\\n\\t}\\n\\tpushdown(L, R, i); //每次都需要更新子树的lazy标记 \\n\\tint mid = (L + R) >> 1;\\n\\tif (l <= mid) {\\n\\t\\tupdate(l, r, z, L, mid, i<<1);\\n\\t}\\n\\tif (r > mid) {\\n\\t\\tupdate(l, r, z, mid + 1, R, i<<1|1);\\n\\t}\\n\\tpushup(i); //更新父结点 \\n}\\n/*\\nint query(int l, int r, int L, int R, int i) {\\n\\tif (l <= L && R <= r) {\\n\\t\\treturn sum[i];\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tint res = 0;\\n\\tif (l <= mid) {\\n\\t\\tres += query(l, r, L, mid, i<<1);\\n\\t}\\n\\tif (r > mid) {\\n\\t\\tres += query(l, r, mid + 1, R, i<<1|1);\\n\\t} \\n\\treturn res;\\n}*/\\n\\nint main() {\\n    int T;\\n    scanf(\\\"%d\\\", &T);\\n    int kase = 0;\\n    while(T--) {\\n        int n, q;\\n        scanf(\\\"%d%d\\\", &n, &q);\\n        build(1, n, 1);\\n        for (int i = 0; i < q; i++) {\\n            int x, y, z;\\n            scanf(\\\"%d%d%d\\\", &x, &y, &z);\\n            update(x, y, z, 1, n, 1);\\n        }\\n        printf(\\\"Case %d: The total value of the hook is %d.\\\\n\\\", ++kase, sum[1]);\\n    }\\n    return 0;\\n}\\n```\\n\\n### [HDU-5023 A Corrupt Mayor\'s Performance Art](http://acm.hdu.edu.cn/showproblem.php?pid=5023): 区间染色、区间更新、区间查询、延迟标记、位运算\\n\\n**Problem Description**\\n\\nCorrupt governors always find ways to get dirty money. Paint something, then sell the worthless painting at a high price to someone who wants to bribe him/her on an auction, this seemed a safe way for mayor X to make money.\\nBecause a lot of people praised mayor X\'s painting(of course, X was a mayor), mayor X believed more and more that he was a very talented painter. Soon mayor X was not satisfied with only making money. He wanted to be a famous painter. So he joined the local painting associates. Other painters had to elect him as the chairman of the associates. Then his painting sold at better price.\\nThe local middle school from which mayor X graduated, wanted to beat mayor X\'s horse fart(In Chinese English, beating one\'s horse fart means flattering one hard). They built a wall, and invited mayor X to paint on it. Mayor X was very happy. But he really had no idea about what to paint because he could only paint very abstract paintings which nobody really understand. Mayor X\'s secretary suggested that he could make this thing not only a painting, but also a performance art work.\\nThis was the secretary\'s idea:\\nThe wall was divided into N segments and the width of each segment was one cun(cun is a Chinese length unit). All segments were numbered from 1 to N, from left to right. There were 30 kinds of colors mayor X could use to paint the wall. They named those colors as color 1, color 2 .... color 30. The wall\'s original color was color 2. Every time mayor X would paint some consecutive segments with a certain kind of color, and he did this for many times. Trying to make his performance art fancy, mayor X declared that at any moment, if someone asked how many kind of colors were there on any consecutive segments, he could give the number immediately without counting.\\nBut mayor X didn\'t know how to give the right answer. Your friend, Mr. W was an secret officer of anti-corruption bureau, he helped mayor X on this problem and gained his trust. Do you know how Mr. Q did this？\\n\\n**Input**\\n\\nThere are several test cases.\\nFor each test case:\\nThe first line contains two integers, N and M ,meaning that the wall is divided into N segments and there are M operations(0 < N <= 1,000,000; 0<M<=100,000)\\nThen M lines follow, each representing an operation. There are two kinds of operations, as described below:\\n1) P a b c\\na, b and c are integers. This operation means that mayor X painted all segments from segment a to segment b with color c ( 0 < a<=b <= N, 0 < c <= 30).\\n2) Q a b\\na and b are integers. This is a query operation. It means that someone asked that how many kinds of colors were there from segment a to segment b ( 0 < a<=b <= N).\\nPlease note that the operations are given in time sequence.\\nThe input ends with M = 0 and N = 0.\\n\\n**Output**\\n\\nFor each query operation, print all kinds of color on the queried segments. For color 1, print 1, for color 2, print 2 ... etc. And this color sequence must be in ascending order.\\n\\n**Sample Input**\\n\\n```C++\\n5 10\\nP 1 2 3\\nP 2 3 4\\nQ 2 3\\nQ 1 3\\nP 3 5 4\\nP 1 2 7\\nQ 1 3\\nQ 3 4\\nP 5 5 8\\nQ 1 5\\n0 0\\n```\\n\\n**Sample Output**\\n\\n```C++\\n4\\n3 4\\n4 7\\n4\\n4 7 8\\n```\\n\\n**题解：**\\n\\n题目大意：有最多30种颜色，一个长度为n的墙。一开始所有墙的颜色都是2。有两种操作：\\n\\n+ P l r x ：把区间[l,r]中所有的墙的颜色都改为x\\n+ Q l r ：询问[l,r]里面的颜色，把颜色升序输出\\n\\n\\n因为颜色种数最大只有30，可以直接用二进制表示是否含有某种颜色。就是利用优美的位运算的性质，初始为1，当有某种颜色时就<<代表此种颜色的数字，最后在每次输出的时候再从1到30种颜色中逐一>>并&1就可以检验是否含有这种颜色！\\n\\n```c++\\n// 区间染色-区间更新-区间查询-延迟标记 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 1e6+5;\\nint sum[maxn<<2];\\nint lazy[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] | sum[i<<1|1]; // 总共的颜色 \\n}\\n\\nvoid pushdown(int i) {\\n\\tif (lazy[i]) {\\n\\t\\tlazy[i<<1] = lazy[i];\\n\\t\\tlazy[i<<1|1] = lazy[i];\\n\\t\\tsum[i<<1] = lazy[i];\\n\\t\\tsum[i<<1|1] = lazy[i];\\n\\t\\tlazy[i] = 0;\\n\\t}\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tlazy[i] = 0;\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1<<1;//初始颜色为2，即1<<1，左移1为\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n} \\n\\nvoid update(int L, int R, int c, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\tsum[i] = 1<<(c-1);\\n\\t\\tlazy[i] = 1<<(c-1);\\n\\t\\treturn;\\n\\t}\\n\\tpushdown(i);\\n\\tint mid = (l + r) >> 1;\\n\\tif (L <= mid) {\\n\\t\\tupdate(L, R, c, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tupdate(L, R, c, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n}\\n\\nint query(int L, int R, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn sum[i];\\n\\t}\\n\\tpushdown(i);\\n\\tint mid = (l + r) >> 1;\\n\\tint res = 0;\\n\\tif (L <= mid) {\\n\\t\\tres |= query(L, R, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tres |= query(L, R, mid + 1, r, i<<1|1);\\n\\t}\\n\\treturn res;\\n}\\n\\nint main() {\\n\\tint N, Q;\\n    int a, b, c;\\n    while (~scanf(\\\"%d%d\\\", &N, &Q)) {\\n        if (N == 0 && Q == 0) {\\n            break;\\n\\t\\t}\\n        build(1, N, 1);//建树\\n        while (Q--) {\\n            char op[2];\\n            scanf(\\\"%s\\\",op);\\n            if (op[0] == \'Q\') {\\n                scanf(\\\"%d%d\\\", &a, &b);\\n                int tt = query(a, b, 1, N, 1);\\n                int flag = 0;\\n                for (int i = 1; i <= 30; i++) {\\n                    //通过右移来判断是否存在i号颜色\\n                    if (tt>>(i-1)&1 && flag == 0) { // flag用来控制输出格式 \\n                        printf(\\\"%d\\\", i);\\n                        flag = 1;\\n                    } else if (tt>>(i-1)&1) {\\n                    \\tprintf(\\\" %d\\\", i);\\n\\t\\t\\t\\t   }                      \\n                }\\n                printf(\\\"\\\\n\\\");\\n            } else {\\n                scanf(\\\"%d%d%d\\\", &a, &b, &c);\\n                update(a, b, c, 1, N, 1);\\n            }\\n        }\\n    }\\n\\treturn 0;\\n} \\n\\n//普通解法\\n#include<iostream>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1e6+5;\\nint t[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tif (t[i<<1] == t[i<<1|1]) { //如果两个儿子的颜色是一样的，说明大区间颜色一样\\n\\t\\tt[i] = t[i<<1];\\n\\t} else { //否则，整个区间颜色不一，大区间改为0\\n\\t\\tt[i] = 0;\\n\\t}\\n} \\n\\nvoid pushdown(int i) {\\n\\tif (!t[i]) { //如果大区间的颜色都是不确定的，没有必要往下传\\n\\t\\treturn;\\n\\t}\\n\\t//大区间颜色确定，说明下面所有小区间颜色都是一样的\\n\\tt[i<<1] = t[i];\\n\\tt[i<<1|1] = t[i];\\n\\tt[i] = 0;\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tt[i] = 2;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\nvoid update(int L, int R, int v, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\tt[i] = v; //找到大区间后，把大区间的颜色更改，下面的小区间等要用到的时候更新\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tpushdown(i);\\n\\tif (L <= mid) {\\n\\t\\tupdate(L, R, v, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tupdate(L, R, v, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n}\\n\\nint ans[35];\\nvoid query(int L, int R, int l, int r, int i) {\\n\\tif (t[i]) { //如果这个大区间的颜色是知道的，那么下面所有的小区间的颜色都一样，不用再找了\\n\\t\\tans[t[i]] = 1;\\n\\t\\treturn;\\n\\t}\\n\\t//大区间颜色不确定，再往下找\\n\\tint mid = (l + r) >> 1;\\n\\tpushdown(i);\\n\\tif (L <= mid) {\\n\\t\\tquery(L, R, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tquery(L, R, mid + 1, r, i<<1|1);\\n\\t}\\n}\\n\\nint main() {\\n\\tint n, m;\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n        if (!n && !m) {\\n        \\tbreak;\\n\\t\\t}\\n        build(1, n, 1);\\n        char o[2];\\n        int x, y, z;\\n        for (int i = 1; i <= m; i++) {\\n            scanf(\\\"%s\\\",o);\\n            if (o[0] == \'P\') {\\n                scanf(\\\"%d%d%d\\\", &x, &y, &z);\\n                update(x, y, z, 1, n, 1);\\n            } else if (o[0] == \'Q\') {\\n                scanf(\\\"%d%d\\\", &x, &y);\\n                memset(ans, 0, sizeof(ans));//预置为0\\n                query(x, y, 1, n, 1);\\n                bool fir = false;//注意行尾空格\\n                for (int i = 1; i <= 30; i++) {\\n                    if (ans[i]) {\\n                        if (!fir) {\\n                            printf(\\\"%d\\\", i);\\n                            fir = true;\\n                        } else {\\n                            printf(\\\" %d\\\", i);\\n                        }  \\n                    }\\n                }\\n                printf(\\\"\\\\n\\\");\\n            }\\n        }\\n    }\\n\\treturn 0;\\n}\\n```\\n### [HDU-3308 LCIS](http://acm.hdu.edu.cn/showproblem.php?pid=3308): 区间合并、区间最值、单点更新、区间查询\\n\\n**Problem Description**\\n\\nGiven n integers.\\nYou have two operations:\\nU A B: replace the Ath number by B. (index counting from 0)\\nQ A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].\\n\\n**Input**\\n\\nT in the first line, indicating the case number.\\nEach case starts with two integers n , m(0<n,m<=105).\\nThe next line has n integers(0<=val<=105).\\nThe next m lines each has an operation:\\nU A B(0<=A,n , 0<=B=105)\\nOR\\nQ A B(0<=A<=B< n).\\n\\n**Output**\\n\\nFor each Q, output the answer.\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10 10\\n7 7 3 3 5 9 9 8 1 8 \\nQ 6 6\\nU 3 4\\nQ 0 1\\nQ 0 5\\nQ 4 7\\nQ 3 5\\nQ 0 2\\nQ 4 6\\nU 6 10\\nQ 0 9\\n```\\n\\n**Sample Output**\\n\\n```C++\\n1\\n1\\n4\\n2\\n3\\n1\\n2\\n5\\n```\\n\\n**题解：**\\n\\n题目大意：给你n个数，m个操作。操作有两种：1.U x y 将数组第x位变为y   2. Q x y 问数组第x位到第y位连续最长子序列的长度。对于每次询问，输出一结果。\\n\\n分析：线段树单点修改区间合并。线段树维护三个值，lv是区间左端点开始的最长上升连续值，rv是以区间右端点结束的最长上升连续值，mv是该区间的最长上升连续值，pushup时分类讨论，当a[mid]<a[mid+1]时，可以知道该区间中间两个点是递增的。这需要合并操作，具体细节看代码注释：\\n\\n```c++\\n// 区间合并、单点更新、区间查询、区间最值 \\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nstruct Tree {\\n\\tint l, r;\\n\\t//lv是区间左端点开始的最长上升连续值\\n    //rv是以区间右端点结束的最长上升连续值\\n    //mv是该区间的最长上升连续值\\n\\tint lv, rv, mv; \\n} tree[maxn<<2];\\nint a[maxn];\\nint n, m, t;\\n\\nvoid pushup(int l, int r, int rt) {\\n\\ttree[rt].lv = tree[rt<<1].lv; //默认为左子树的lv \\n\\ttree[rt].rv = tree[rt<<1|1].rv;//默认为右子树的rv \\n\\ttree[rt].mv = max(tree[rt<<1].mv, tree[rt<<1|1].mv);//默认为左右子树mv的较大值 \\n\\tint mid = (l + r) >> 1;\\n\\tif (a[mid] < a[mid + 1]) { //左右可以合并 \\n\\t\\tif (tree[rt<<1].lv == mid - l + 1) { //左子树的lv长度等于区间长度 \\n\\t\\t\\ttree[rt].lv = tree[rt<<1].lv + tree[rt<<1|1].lv;\\n\\t\\t}\\n\\t\\tif (tree[rt<<1|1].rv == r - mid) { //右子树的lv长度等于区间长度 \\n\\t\\t\\ttree[rt].rv = tree[rt<<1].rv + tree[rt<<1|1].rv; \\n\\t\\t}\\n        // 更新区间的最大值，与合并后的比较，左区间右端点和右区间左端点合并\\n\\t\\ttree[rt].mv = max(tree[rt].mv, tree[rt<<1].rv + tree[rt<<1|1].lv);\\n\\t}\\n}\\n\\nvoid build(int l, int r, int rt) {\\n\\ttree[rt].l = l;\\n\\ttree[rt].r = r;\\n\\tif (l == r) {\\n\\t\\ttree[rt].lv = tree[rt].rv = tree[rt].mv = 1;\\n\\t\\treturn;\\n\\t} \\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, rt<<1);\\n\\tbuild(mid + 1, r, rt<<1|1);\\n\\tpushup(l, r, rt);\\n}\\n\\n//单点更新 \\nvoid update(int l, int r, int p, int rt) {\\n    if (l == r) {\\n        return;\\n    }\\n    int mid = (l + r) >> 1;\\n    if (p <= mid) {\\n    \\tupdate(l, mid, p, rt<<1);\\n\\t} else {\\n\\t\\tupdate(mid + 1, r, p, rt<<1|1);\\n\\t}\\n    pushup(l, r, rt);\\n}\\n\\n//区间查询 \\nint query(int l, int r, int rt) {\\n\\tif (tree[rt].l >= l && tree[rt].r <= r) {\\n        return tree[rt].mv;\\n    }\\n    int mid = (tree[rt].l + tree[rt].r) >> 1;\\n    int ans = 0;\\n    //分别在左子区间和右子区间查找，结果分别为x,y,如果左右两个区间不能延续，\\n    //那肯定是在x,y中找一个最大值\\n    if (l <= mid) {\\n    \\tans = max(ans, query(l, r, rt<<1)); //x \\n\\t} \\n\\tif (r > mid) {\\n\\t\\tans = max(ans, query(l, r, rt<<1|1)); //y\\n\\t}\\n //如果能够延续,设两端延续区间长度为z,那么肯定是在 x,y,z找最大值，另外，对于左区间,我们要保证\\n //向左延续的区间(rv)肯定是在[l,mid]中的(不然超过我们要查询的区间了),所以长度必须要在 mid - l+1之内\\n    //向右亦如此.\\n\\tif (a[mid] < a[mid+1]) {\\n        ans = max(ans, min(mid-l+1, tree[rt<<1].rv) + min(r-mid, tree[rt<<1|1].lv));\\n    }\\n   \\treturn ans;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &t);\\n\\twhile (t--) {\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\twhile (m--) {\\n\\t        char s[5];\\n\\t        scanf(\\\"%s\\\", s);\\n            if (s[0] == \'U\'){\\n                int b, c;\\n                scanf(\\\"%d%d\\\", &b, &c);\\n                a[++b] = c;  //由于题目下标从0开始，所以++\\n                update(1, n, b, 1);\\n            } else {\\n                int b, c;\\n                scanf(\\\"%d%d\\\", &b, &c);\\n                b++;\\n\\t\\t\\t   c++;\\n                printf(\\\"%d\\\\n\\\", query(b, c, 1));\\n            }\\n\\t    }\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"线段树刷题记录\",\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.194', '安徽省合肥市 联通', '2021-05-16 16:44:05');
INSERT INTO `tb_operation_log` VALUES (95, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"线段树\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.194', '安徽省合肥市 联通', '2021-05-16 16:44:14');
INSERT INTO `tb_operation_log` VALUES (96, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [HDU-1166 敌兵布阵](http://acm.hdu.edu.cn/showproblem.php?pid=1166): 区间求和、单点修改、区间查询\\n\\n**Problem Description**\\n\\nC国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。\\n中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:\\\"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：\\\"我知错了。。。\\\"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.\\n\\n**Input**\\n\\n第一行一个整数T，表示有T组数据。\\n每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。\\n接下来每行有一条命令，命令有4种形式：\\n(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）\\n(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;\\n(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数;\\n(4)End 表示结束，这条命令在每组数据最后出现;\\n每组数据最多有40000条命令\\n\\n**Output**\\n\\n对第i组数据,首先输出“Case i:”和回车,\\n对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10\\n1 2 3 4 5 6 7 8 9 10\\nQuery 1 3\\nAdd 3 6\\nQuery 2 7\\nSub 10 2\\nAdd 6 3\\nQuery 3 10\\nEnd \\n```\\n\\n**Sample Output**\\n\\n```c++\\nCase 1:\\n6\\n33\\n59\\n```\\n\\n **题解**：模板题\\n\\n```c++\\n#include<iostream>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 50005;\\nint a[maxn], t[maxn<<2];\\nint ans, T, n;\\n\\nvoid pushup(int i) {\\n\\tt[i] = t[i<<1] + t[i<<1|1];\\n}\\n\\nvoid build(int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = a[left];\\n\\t\\treturn;\\n\\t}\\n\\tint mid = left + ((right - left) >> 1);\\n\\tbuild(left, mid, index<<1);\\n\\tbuild(mid + 1, right, index<<1|1);\\n\\tpushup(index);\\n}\\n\\nvoid update(int p, int v, int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] += v;\\n\\t} else {\\n\\t\\tint mid = left + ((right - left) >> 1);\\n\\t\\tif (p <= mid) {\\n\\t\\t\\tupdate(p, v, left, mid, index << 1);\\n\\t\\t} else {\\n\\t\\t\\tupdate(p, v, mid + 1, right, index<<1|1);\\n\\t\\t}\\n\\t\\tpushup(index);\\n\\t}\\n}\\n\\nint query(int index, int L, int R, int l, int r) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn t[index];\\n\\t}\\n\\tint s = 0;\\n\\tint mid = l + ((r - l) >> 1);\\n\\tif (L <= mid) {\\n\\t\\ts += query(index<<1, L, R, l, mid);\\n\\t} \\n\\tif (R > mid) {\\n\\t\\ts += query(index<<1|1, L, R, mid + 1, r);\\n\\t}\\n\\treturn s;\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tscanf(\\\"%d\\\", &T);\\n\\tfor (int k = 1; k <= T; k++) {\\n\\t\\tprintf(\\\"Case %d:\\\\n\\\", k);\\n\\t\\tcin>>n;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tchar str[20];\\n\\t\\twhile (scanf(\\\"%s\\\", str) && str[0] != \'E\') {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\t\\t\\tif (str[0] == \'Q\') {\\n\\t\\t\\t\\tcout<<query(1, x, y, 1, n)<<endl;\\n\\t\\t\\t}\\n\\t\\t\\tif (str[0] == \'A\') {\\n\\t\\t\\t\\tupdate(x, y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (str[0] == \'S\') {\\n\\t\\t\\t\\tupdate(x, -y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [HDU-1754 I Hate It](http://acm.hdu.edu.cn/showproblem.php?pid=1754): 区间最值、单点修改、区间查询\\n\\n**Problem Description**\\n\\n很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。\\n这让很多学生很反感。\\n不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\\n\\n**Input**\\n\\n本题目包含多组测试，请处理到文件结束。\\n在每个测试的第一行，有两个正整数 N 和 M ( 0<N<=200000,0<M<5000 )，分别代表学生的数目和操作的数目。\\n学生ID编号分别从1编到N。\\n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。\\n接下来有M行。每一行有一个字符 C (只取\'Q\'或\'U\') ，和两个正整数A，B。\\n当C为\'Q\'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。\\n当C为\'U\'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。\\n\\n**Output**\\n\\n对于每一次询问操作，在一行里面输出最高成绩。\\n\\n**Sample Input**\\n\\n```C++\\n5 6\\n1 2 3 4 5\\nQ 1 5\\nU 3 6\\nQ 3 4\\nQ 4 5\\nU 2 9\\nQ 1 5\\n```\\n\\n**Sample Output**\\n\\n```C++\\n5\\n6\\n5\\n9\\n\\nHint\\nHuge input,the C function scanf() will work better than cin\\n```\\n\\n**题解**：模板题\\n\\n```c++\\n// 最值-单点更新，批量查询\\n#include<iostream>\\n#include<algorithm>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int INF = 1e8;\\nconst int maxn = 2000005;\\nint a[maxn], t[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tt[i] = max(t[i<<1], t[i<<1|1]);\\n}\\n\\nvoid build(int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = a[left];\\n\\t\\treturn;\\n\\t}\\n\\tint mid = left + ((right - left) >> 1);\\n\\tbuild(left, mid, index<<1);\\n\\tbuild(mid + 1, right, index<<1|1);\\n\\tpushup(index);\\n}\\n\\nvoid update(int p, int v, int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = v;\\n\\t} else {\\n\\t\\tint mid = left + ((right - left) >> 1);\\n\\t\\tif (p <= mid) {\\n\\t\\t\\tupdate(p, v, left, mid, index << 1);\\n\\t\\t} else {\\n\\t\\t\\tupdate(p, v, mid + 1, right, index<<1|1);\\n\\t\\t}\\n\\t\\tpushup(index);\\n\\t}\\n}\\n\\nint query(int index, int L, int R, int l, int r) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn t[index];\\n\\t}\\n\\tint smax = -INF;\\n\\tint mid = l + ((r - l) >> 1);\\n\\tif (L <= mid) {\\n\\t\\tsmax = max(smax, query(index<<1, L, R, l, mid));\\n\\t} \\n\\tif (R > mid) {\\n\\t\\tsmax = max(smax, query(index<<1|1, L, R, mid + 1, r));\\n\\t}\\n\\treturn smax;\\n}\\n\\nint n, m;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tchar c;\\n\\t\\tint x, y;\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tscanf(\\\" %c%d%d\\\", &c, &x, &y);\\n\\t\\t\\tif (c == \'Q\') {\\n\\t\\t\\t\\tprintf(\\\"%d\\\\n\\\", query(1, x, y, 1, n));\\n\\t\\t\\t} else if (c == \'U\') {\\n\\t\\t\\t\\tupdate(x, y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [HDU-2795 Billboard](http://acm.hdu.edu.cn/showproblem.php?pid=2795): 区间最值、单点更新、区间查询\\n\\n**Problem Description**\\n\\nAt the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.\\nOn September 1, the billboard was empty. One by one, the announcements started being put on the billboard.\\nEach announcement is a stripe of paper of unit height. More specifically, the i-th announcement is a rectangle of size 1 * wi.\\nWhen someone puts a new announcement on the billboard, she would always choose the topmost possible position for the announcement. Among all possible topmost positions she would always choose the leftmost one.\\nIf there is no valid location for a new announcement, it is not put on the billboard (that\'s why some programming contests have no participants from this university).\\nGiven the sizes of the billboard and the announcements, your task is to find the numbers of rows in which the announcements are placed.\\n\\n**Input**\\n\\nThere are multiple cases (no more than 40 cases).\\nThe first line of the input file contains three integer numbers, h, w, and n (1 <= h,w <= 10^9; 1 <= n <= 200,000) - the dimensions of the billboard and the number of announcements.\\nEach of the next n lines contains an integer number wi (1 <= wi <= 10^9) - the width of i-th announcement.\\n\\n**Output**\\n\\nFor each announcement (in the order they are given in the input file) output one number - the number of the row in which this announcement is placed. Rows are numbered from 1 to h, starting with the top row. If an announcement can\'t be put on the billboard, output \\\"-1\\\" for this announcement.\\n\\n**Sample Input**\\n\\n```C++\\n3 5 5\\n2\\n4\\n3\\n3\\n3\\n```\\n\\n**Sample Output**\\n\\n```C++\\n1\\n2\\n1\\n3\\n-1\\n```\\n\\n**题解：**\\n\\n​        该题的大意就是在一块广告牌上张贴公告，广告牌有高宽限制，公告默认高度为1，输入广告牌的高度、宽度、公告的数量及每个公告的宽度，输出公告张贴的行号。（广告张贴高度优先，从高往低贴，高度一致，尽量贴左侧）\\n\\n​\\t用线段树的每个结点存储对应区间内最大的那一行的剩余宽度，只要维护好每个区间的最大值就行了。输入每一个公告的宽度，与树根比较，如果大于树根对应的最大宽度，直接输出-1，否则，与左子树比较，若比它小，就查询左子树，否则查询右子树。查询到之后再减去相应的宽度。\\n\\n​\\t如果广告牌的高度大于公告的数量时，即 h > n，令 h = n 。高出的部分没有意义。每行只能贴一个公告。\\n\\n```c++\\n// 最值-单点更新、批量查询\\n#include<iostream>\\n#include<algorithm>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\n#define maxn 200005\\nint tree[maxn<<2]; //每个结点存储的是宽度的最大值，区间为高度的区间 \\nint n, h, w, x;\\n\\nvoid pushup(int root) {\\n\\ttree[root] = max(tree[root<<1], tree[root<<1|1]);\\n}\\n\\nvoid build(int l, int r, int root) {\\n    if (l == r) {\\n        tree[root] = w; //初始高度均为w \\n        return;\\n    }\\n    int mid = (l + r) >> 1;\\n    build(l, mid, root<<1);\\n    build(mid + 1, r, root<<1|1);\\n    pushup(root);\\n}\\n\\nint query(int val, int l, int r, int root) {\\n    if (l == r) { //查询到合适的高度 \\n        tree[root] -= val; //对应的宽度减少val \\n        return l; //返回行号 \\n    }\\n    int mid = (l + r) >> 1;\\n    int ans;\\n    if (tree[root<<1] >= val) { //如果左子树的宽度最大值大于val，则去左子树查询 \\n    \\tans = query(val, l, mid, root<<1);\\n\\t} else { //否则，去右子树查询 \\n\\t\\tans = query(val, mid + 1, r, root<<1|1);\\t\\n\\t}  \\n    pushup(root);\\n    return ans;\\n}\\n\\nint main() {\\n    while (~scanf(\\\"%d%d%d\\\", &h, &w, &n)) {\\n        if (h > n) { //如果高度超过了广告牌的个数，高度置为个数，每层只能放一个广告牌 \\n        \\th = n;\\t\\n\\t\\t}  \\n        build(1, h, 1);\\n        for (int i = 1; i <= n; i++) {\\n            scanf(\\\"%d\\\", &x);\\n            if (x > tree[1]) { //如果宽度大于最大宽度，则输出-1 \\n            \\tprintf(\\\"%d\\\\n\\\", -1);\\n\\t\\t\\t} else { //否则，在线段树中查询 \\n\\t\\t\\t\\tprintf(\\\"%d\\\\n\\\", query(x, 1, h, 1));\\n\\t\\t\\t}     \\n        }\\n    }\\n    return 0;\\n}\\n```\\n\\n### [POJ-2828 Buy Tickets](http://poj.org/problem?id=2828): 排队、区间求和、单点更新\\n\\n**Description**\\n\\n*Railway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…*\\n\\nThe Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.\\n\\nIt was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!\\n\\nPeople kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.\\n\\n**Input**\\n\\nThere will be several test cases in the input. Each test case consists of *N* + 1 lines where *N* (1 ≤ *N* ≤ 200,000) is given in the first line of the test case. The next *N* lines contain the pairs of values *Posi* and *Vali* in the increasing order of *i* (1 ≤ *i* ≤ *N*). For each *i*, the ranges and meanings of *Posi* and *Vali* are as follows:\\n\\n- *Posi* ∈ [0, *i* − 1] — The *i*-th person came to the queue and stood right behind the *Posi*-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.\\n- *Vali* ∈ [0, 32767] — The *i*-th person was assigned the value *Vali*.\\n\\nThere no blank lines between test cases. Proceed to the end of input.\\n\\n**Output**\\n\\nFor each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.\\n\\n**Sample Input**\\n\\n```C++\\n4\\n0 77\\n1 51\\n1 33\\n2 69\\n4\\n0 20523\\n1 19243\\n1 3890\\n0 31492\\n```\\n\\n**Sample Output**\\n\\n```C++\\n77 33 69 51\\n31492 20523 3890 19243\\n```\\n\\n**Hint**  \\n\\n​      The figure below shows how the Little Cat found out the final order of people in the queue described in the first test case of the sample input.\\n\\n![img](http://poj.org/images/2828.gif)\\n\\n**题解：**\\n\\n​\\t题目大意，插队的问题，每个案例给出 n ，代表有 n 个插队的，每个给出 p, v，意思是代号为 v 的人插在了第 p 个人的后面，问最后的队伍的排列。\\n\\n​\\t一开始的队列是空的，如果输入i，j：代表代号为 j 的人插在代号为 i 的人的后面，也就是说他前面一定有了 i 个人，而他是第 i + 1 个人。\\n\\n​\\t所以从后往前推导，最后的人选定的位置是不会变的，同样，在第 i 个人后面插队，他的前面一定要留下 i 个空位。用线段树的每个结点存储对应区间的空位数的和。建树时叶子结点默认的空位为 1，每次输入 p 和 v 时，更新位数和为 p + 1 的结点，对应的位数和减 1，用数组记录对应的位置和序号。\\n\\n```c++\\n// 排队，求和-单点更新 \\n// 从后往前进行 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 2e5 + 5;\\nint sum[maxn<<2], b[maxn]; //sum中的每个结点存储对应区间中的空位数，b用来记录排队序列 \\n\\nstruct node {\\n\\tint p;\\n\\tint num;\\n} a[maxn];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] + sum[i<<1|1];\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\nvoid update(int p, int num, int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tsum[i]--;\\n\\t\\tb[l] = num;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tif (sum[i<<1] >= p) {\\n\\t\\tupdate(p, num, l, mid, i<<1); \\n\\t} else {\\n\\t// p-sum[i<<1]，从后往前推导，在第p个人后插队，他的前面一定要有p个空位，所以要减去左边的空位数 \\n\\t\\tupdate(p - sum[i<<1], num, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n} \\n\\nint main() {\\n\\tint n;\\n\\twhile (scanf(\\\"%d\\\", &n) != EOF) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &a[i].p, &a[i].num);\\n\\t\\t\\ta[i].p++; //开始把位置都加1，更新时只需找到sum为p的结点\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n        // 从后往前推\\n\\t\\tfor (int i = n; i > 0; i--) {\\n\\t\\t\\tupdate(a[i].p, a[i].num, 1, n, 1);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tprintf(\\\"%d \\\", b[i]);\\n\\t\\t}\\n\\t\\tprintf(\\\"\\\\n\\\");\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n### [HDU-1698 Just a Hook](http://acm.hdu.edu.cn/showproblem.php?pid=1698): 区间修改、延迟标记、区间求和\\n\\n**Problem Description**\\n\\nIn the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.\\n![img](http://acm.hdu.edu.cn/data/images/C116-1010-1.JPG)\\nNow Pudge wants to do some operations on the hook.\\nLet us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.\\nThe total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:\\nFor each cupreous stick, the value is 1.\\nFor each silver stick, the value is 2.\\nFor each golden stick, the value is 3.\\nPudge wants to know the total value of the hook after performing the operations.\\nYou may consider the original hook is made up of cupreous sticks.\\n\\n**Input**\\n\\nThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.\\nFor each case, the first line contains an integer N, 1<=N<=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0<=Q<=100,000, which is the number of the operations.\\nNext Q lines, each line contains three integers X, Y, 1<=X<=Y<=N, Z, 1<=Z<=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.\\n\\n**Output**\\n\\nFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10\\n2\\n1 5 2\\n5 9 3\\n```\\n\\n**Sample Output**\\n\\n```C++\\nCase 1: The total value of the hook is 24.\\n```\\n\\n**题解：**\\n\\n​\\t题目大意：有T组样例，每组样例给出n个棍子，开始时每个棍子的价值均为1，给出q个操作，可以把编号[x,y]之间的棍子d的价值改为z（z可以是1，2，3），求最终价值。\\n\\n​\\t线段树每个结点存储对应区间的价值和，开始叶子结点默认价值为1。区间修改模板。\\n\\n```c++\\n// 区间染色-区间修改，延迟标记 ，区间求和 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint lazy[maxn<<2];\\nint sum[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] + sum[i<<1|1];\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tlazy[i] = 0;\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1; // 初始值为1 \\n\\t\\treturn; \\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\n//更新子树的lazy值\\nvoid pushdown(int l, int r, int i) {\\n\\tint mid = (l + r) >> 1;\\n\\tif (lazy[i]) { //如果有lazy标记\\n\\t\\tlazy[i<<1] = lazy[i]; //更新左子树的lazy值 \\n\\t\\tlazy[i<<1|1] = lazy[i]; //更新右子树的lazy值\\n\\t\\tsum[i<<1] = lazy[i<<1] * (mid - l + 1); //更新左子树的和 \\n\\t\\tsum[i<<1|1] = lazy[i<<1|1] * (r - mid); //更新右子树的和 \\n\\t\\tlazy[i] = 0; //取消标记 \\n\\t}\\n}\\n\\nvoid update(int l, int r, int z, int L, int R, int i) {\\n\\tif (l <= L && R <= r) {\\n\\t\\tlazy[i] = z;\\n\\t\\tsum[i] = lazy[i] * (R - L + 1);\\n\\t\\treturn;\\n\\t}\\n\\tpushdown(L, R, i); //每次都需要更新子树的lazy标记 \\n\\tint mid = (L + R) >> 1;\\n\\tif (l <= mid) {\\n\\t\\tupdate(l, r, z, L, mid, i<<1);\\n\\t}\\n\\tif (r > mid) {\\n\\t\\tupdate(l, r, z, mid + 1, R, i<<1|1);\\n\\t}\\n\\tpushup(i); //更新父结点 \\n}\\n/*\\nint query(int l, int r, int L, int R, int i) {\\n\\tif (l <= L && R <= r) {\\n\\t\\treturn sum[i];\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tint res = 0;\\n\\tif (l <= mid) {\\n\\t\\tres += query(l, r, L, mid, i<<1);\\n\\t}\\n\\tif (r > mid) {\\n\\t\\tres += query(l, r, mid + 1, R, i<<1|1);\\n\\t} \\n\\treturn res;\\n}*/\\n\\nint main() {\\n    int T;\\n    scanf(\\\"%d\\\", &T);\\n    int kase = 0;\\n    while(T--) {\\n        int n, q;\\n        scanf(\\\"%d%d\\\", &n, &q);\\n        build(1, n, 1);\\n        for (int i = 0; i < q; i++) {\\n            int x, y, z;\\n            scanf(\\\"%d%d%d\\\", &x, &y, &z);\\n            update(x, y, z, 1, n, 1);\\n        }\\n        printf(\\\"Case %d: The total value of the hook is %d.\\\\n\\\", ++kase, sum[1]);\\n    }\\n    return 0;\\n}\\n```\\n\\n### [HDU-5023 A Corrupt Mayor\'s Performance Art](http://acm.hdu.edu.cn/showproblem.php?pid=5023): 区间染色、区间更新、区间查询、延迟标记、位运算\\n\\n**Problem Description**\\n\\nCorrupt governors always find ways to get dirty money. Paint something, then sell the worthless painting at a high price to someone who wants to bribe him/her on an auction, this seemed a safe way for mayor X to make money.\\nBecause a lot of people praised mayor X\'s painting(of course, X was a mayor), mayor X believed more and more that he was a very talented painter. Soon mayor X was not satisfied with only making money. He wanted to be a famous painter. So he joined the local painting associates. Other painters had to elect him as the chairman of the associates. Then his painting sold at better price.\\nThe local middle school from which mayor X graduated, wanted to beat mayor X\'s horse fart(In Chinese English, beating one\'s horse fart means flattering one hard). They built a wall, and invited mayor X to paint on it. Mayor X was very happy. But he really had no idea about what to paint because he could only paint very abstract paintings which nobody really understand. Mayor X\'s secretary suggested that he could make this thing not only a painting, but also a performance art work.\\nThis was the secretary\'s idea:\\nThe wall was divided into N segments and the width of each segment was one cun(cun is a Chinese length unit). All segments were numbered from 1 to N, from left to right. There were 30 kinds of colors mayor X could use to paint the wall. They named those colors as color 1, color 2 .... color 30. The wall\'s original color was color 2. Every time mayor X would paint some consecutive segments with a certain kind of color, and he did this for many times. Trying to make his performance art fancy, mayor X declared that at any moment, if someone asked how many kind of colors were there on any consecutive segments, he could give the number immediately without counting.\\nBut mayor X didn\'t know how to give the right answer. Your friend, Mr. W was an secret officer of anti-corruption bureau, he helped mayor X on this problem and gained his trust. Do you know how Mr. Q did this？\\n\\n**Input**\\n\\nThere are several test cases.\\nFor each test case:\\nThe first line contains two integers, N and M ,meaning that the wall is divided into N segments and there are M operations(0 < N <= 1,000,000; 0<M<=100,000)\\nThen M lines follow, each representing an operation. There are two kinds of operations, as described below:\\n1) P a b c\\na, b and c are integers. This operation means that mayor X painted all segments from segment a to segment b with color c ( 0 < a<=b <= N, 0 < c <= 30).\\n2) Q a b\\na and b are integers. This is a query operation. It means that someone asked that how many kinds of colors were there from segment a to segment b ( 0 < a<=b <= N).\\nPlease note that the operations are given in time sequence.\\nThe input ends with M = 0 and N = 0.\\n\\n**Output**\\n\\nFor each query operation, print all kinds of color on the queried segments. For color 1, print 1, for color 2, print 2 ... etc. And this color sequence must be in ascending order.\\n\\n**Sample Input**\\n\\n```C++\\n5 10\\nP 1 2 3\\nP 2 3 4\\nQ 2 3\\nQ 1 3\\nP 3 5 4\\nP 1 2 7\\nQ 1 3\\nQ 3 4\\nP 5 5 8\\nQ 1 5\\n0 0\\n```\\n\\n**Sample Output**\\n\\n```C++\\n4\\n3 4\\n4 7\\n4\\n4 7 8\\n```\\n\\n**题解：**\\n\\n题目大意：有最多30种颜色，一个长度为n的墙。一开始所有墙的颜色都是2。有两种操作：\\n\\n+ P l r x ：把区间[l,r]中所有的墙的颜色都改为x\\n+ Q l r ：询问[l,r]里面的颜色，把颜色升序输出\\n\\n\\n因为颜色种数最大只有30，可以直接用二进制表示是否含有某种颜色。就是利用优美的位运算的性质，初始为1，当有某种颜色时就<<代表此种颜色的数字，最后在每次输出的时候再从1到30种颜色中逐一>>并&1就可以检验是否含有这种颜色！\\n\\n```c++\\n// 区间染色-区间更新-区间查询-延迟标记 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 1e6+5;\\nint sum[maxn<<2];\\nint lazy[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] | sum[i<<1|1]; // 总共的颜色 \\n}\\n\\nvoid pushdown(int i) {\\n\\tif (lazy[i]) {\\n\\t\\tlazy[i<<1] = lazy[i];\\n\\t\\tlazy[i<<1|1] = lazy[i];\\n\\t\\tsum[i<<1] = lazy[i];\\n\\t\\tsum[i<<1|1] = lazy[i];\\n\\t\\tlazy[i] = 0;\\n\\t}\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tlazy[i] = 0;\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1<<1;//初始颜色为2，即1<<1，左移1为\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n} \\n\\nvoid update(int L, int R, int c, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\tsum[i] = 1<<(c-1);\\n\\t\\tlazy[i] = 1<<(c-1);\\n\\t\\treturn;\\n\\t}\\n\\tpushdown(i);\\n\\tint mid = (l + r) >> 1;\\n\\tif (L <= mid) {\\n\\t\\tupdate(L, R, c, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tupdate(L, R, c, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n}\\n\\nint query(int L, int R, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn sum[i];\\n\\t}\\n\\tpushdown(i);\\n\\tint mid = (l + r) >> 1;\\n\\tint res = 0;\\n\\tif (L <= mid) {\\n\\t\\tres |= query(L, R, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tres |= query(L, R, mid + 1, r, i<<1|1);\\n\\t}\\n\\treturn res;\\n}\\n\\nint main() {\\n\\tint N, Q;\\n    int a, b, c;\\n    while (~scanf(\\\"%d%d\\\", &N, &Q)) {\\n        if (N == 0 && Q == 0) {\\n            break;\\n\\t\\t}\\n        build(1, N, 1);//建树\\n        while (Q--) {\\n            char op[2];\\n            scanf(\\\"%s\\\",op);\\n            if (op[0] == \'Q\') {\\n                scanf(\\\"%d%d\\\", &a, &b);\\n                int tt = query(a, b, 1, N, 1);\\n                int flag = 0;\\n                for (int i = 1; i <= 30; i++) {\\n                    //通过右移来判断是否存在i号颜色\\n                    if (tt>>(i-1)&1 && flag == 0) { // flag用来控制输出格式 \\n                        printf(\\\"%d\\\", i);\\n                        flag = 1;\\n                    } else if (tt>>(i-1)&1) {\\n                    \\tprintf(\\\" %d\\\", i);\\n\\t\\t\\t\\t   }                      \\n                }\\n                printf(\\\"\\\\n\\\");\\n            } else {\\n                scanf(\\\"%d%d%d\\\", &a, &b, &c);\\n                update(a, b, c, 1, N, 1);\\n            }\\n        }\\n    }\\n\\treturn 0;\\n} \\n\\n//普通解法\\n#include<iostream>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1e6+5;\\nint t[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tif (t[i<<1] == t[i<<1|1]) { //如果两个儿子的颜色是一样的，说明大区间颜色一样\\n\\t\\tt[i] = t[i<<1];\\n\\t} else { //否则，整个区间颜色不一，大区间改为0\\n\\t\\tt[i] = 0;\\n\\t}\\n} \\n\\nvoid pushdown(int i) {\\n\\tif (!t[i]) { //如果大区间的颜色都是不确定的，没有必要往下传\\n\\t\\treturn;\\n\\t}\\n\\t//大区间颜色确定，说明下面所有小区间颜色都是一样的\\n\\tt[i<<1] = t[i];\\n\\tt[i<<1|1] = t[i];\\n\\tt[i] = 0;\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tt[i] = 2;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\nvoid update(int L, int R, int v, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\tt[i] = v; //找到大区间后，把大区间的颜色更改，下面的小区间等要用到的时候更新\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tpushdown(i);\\n\\tif (L <= mid) {\\n\\t\\tupdate(L, R, v, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tupdate(L, R, v, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n}\\n\\nint ans[35];\\nvoid query(int L, int R, int l, int r, int i) {\\n\\tif (t[i]) { //如果这个大区间的颜色是知道的，那么下面所有的小区间的颜色都一样，不用再找了\\n\\t\\tans[t[i]] = 1;\\n\\t\\treturn;\\n\\t}\\n\\t//大区间颜色不确定，再往下找\\n\\tint mid = (l + r) >> 1;\\n\\tpushdown(i);\\n\\tif (L <= mid) {\\n\\t\\tquery(L, R, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tquery(L, R, mid + 1, r, i<<1|1);\\n\\t}\\n}\\n\\nint main() {\\n\\tint n, m;\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n        if (!n && !m) {\\n        \\tbreak;\\n\\t\\t}\\n        build(1, n, 1);\\n        char o[2];\\n        int x, y, z;\\n        for (int i = 1; i <= m; i++) {\\n            scanf(\\\"%s\\\",o);\\n            if (o[0] == \'P\') {\\n                scanf(\\\"%d%d%d\\\", &x, &y, &z);\\n                update(x, y, z, 1, n, 1);\\n            } else if (o[0] == \'Q\') {\\n                scanf(\\\"%d%d\\\", &x, &y);\\n                memset(ans, 0, sizeof(ans));//预置为0\\n                query(x, y, 1, n, 1);\\n                bool fir = false;//注意行尾空格\\n                for (int i = 1; i <= 30; i++) {\\n                    if (ans[i]) {\\n                        if (!fir) {\\n                            printf(\\\"%d\\\", i);\\n                            fir = true;\\n                        } else {\\n                            printf(\\\" %d\\\", i);\\n                        }  \\n                    }\\n                }\\n                printf(\\\"\\\\n\\\");\\n            }\\n        }\\n    }\\n\\treturn 0;\\n}\\n```\\n### [HDU-3308 LCIS](http://acm.hdu.edu.cn/showproblem.php?pid=3308): 区间合并、区间最值、单点更新、区间查询\\n\\n**Problem Description**\\n\\nGiven n integers.\\nYou have two operations:\\nU A B: replace the Ath number by B. (index counting from 0)\\nQ A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].\\n\\n**Input**\\n\\nT in the first line, indicating the case number.\\nEach case starts with two integers n , m(0<n,m<=105).\\nThe next line has n integers(0<=val<=105).\\nThe next m lines each has an operation:\\nU A B(0<=A,n , 0<=B=105)\\nOR\\nQ A B(0<=A<=B< n).\\n\\n**Output**\\n\\nFor each Q, output the answer.\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10 10\\n7 7 3 3 5 9 9 8 1 8 \\nQ 6 6\\nU 3 4\\nQ 0 1\\nQ 0 5\\nQ 4 7\\nQ 3 5\\nQ 0 2\\nQ 4 6\\nU 6 10\\nQ 0 9\\n```\\n\\n**Sample Output**\\n\\n```C++\\n1\\n1\\n4\\n2\\n3\\n1\\n2\\n5\\n```\\n\\n**题解：**\\n\\n题目大意：给你n个数，m个操作。操作有两种：1.U x y 将数组第x位变为y   2. Q x y 问数组第x位到第y位连续最长子序列的长度。对于每次询问，输出一结果。\\n\\n分析：线段树单点修改区间合并。线段树维护三个值，lv是区间左端点开始的最长上升连续值，rv是以区间右端点结束的最长上升连续值，mv是该区间的最长上升连续值，pushup时分类讨论，当a[mid]<a[mid+1]时，可以知道该区间中间两个点是递增的。这需要合并操作，具体细节看代码注释：\\n\\n```c++\\n// 区间合并、单点更新、区间查询、区间最值 \\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nstruct Tree {\\n\\tint l, r;\\n\\t//lv是区间左端点开始的最长上升连续值\\n    //rv是以区间右端点结束的最长上升连续值\\n    //mv是该区间的最长上升连续值\\n\\tint lv, rv, mv; \\n} tree[maxn<<2];\\nint a[maxn];\\nint n, m, t;\\n\\nvoid pushup(int l, int r, int rt) {\\n\\ttree[rt].lv = tree[rt<<1].lv; //默认为左子树的lv \\n\\ttree[rt].rv = tree[rt<<1|1].rv;//默认为右子树的rv \\n\\ttree[rt].mv = max(tree[rt<<1].mv, tree[rt<<1|1].mv);//默认为左右子树mv的较大值 \\n\\tint mid = (l + r) >> 1;\\n\\tif (a[mid] < a[mid + 1]) { //左右可以合并 \\n\\t\\tif (tree[rt<<1].lv == mid - l + 1) { //左子树的lv长度等于区间长度 \\n\\t\\t\\ttree[rt].lv = tree[rt<<1].lv + tree[rt<<1|1].lv;\\n\\t\\t}\\n\\t\\tif (tree[rt<<1|1].rv == r - mid) { //右子树的lv长度等于区间长度 \\n\\t\\t\\ttree[rt].rv = tree[rt<<1].rv + tree[rt<<1|1].rv; \\n\\t\\t}\\n        // 更新区间的最大值，与合并后的比较，左区间右端点和右区间左端点合并\\n\\t\\ttree[rt].mv = max(tree[rt].mv, tree[rt<<1].rv + tree[rt<<1|1].lv);\\n\\t}\\n}\\n\\nvoid build(int l, int r, int rt) {\\n\\ttree[rt].l = l;\\n\\ttree[rt].r = r;\\n\\tif (l == r) {\\n\\t\\ttree[rt].lv = tree[rt].rv = tree[rt].mv = 1;\\n\\t\\treturn;\\n\\t} \\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, rt<<1);\\n\\tbuild(mid + 1, r, rt<<1|1);\\n\\tpushup(l, r, rt);\\n}\\n\\n//单点更新 \\nvoid update(int l, int r, int p, int rt) {\\n    if (l == r) {\\n        return;\\n    }\\n    int mid = (l + r) >> 1;\\n    if (p <= mid) {\\n    \\tupdate(l, mid, p, rt<<1);\\n\\t} else {\\n\\t\\tupdate(mid + 1, r, p, rt<<1|1);\\n\\t}\\n    pushup(l, r, rt);\\n}\\n\\n//区间查询 \\nint query(int l, int r, int rt) {\\n\\tif (tree[rt].l >= l && tree[rt].r <= r) {\\n        return tree[rt].mv;\\n    }\\n    int mid = (tree[rt].l + tree[rt].r) >> 1;\\n    int ans = 0;\\n    //分别在左子区间和右子区间查找，结果分别为x,y,如果左右两个区间不能延续，\\n    //那肯定是在x,y中找一个最大值\\n    if (l <= mid) {\\n    \\tans = max(ans, query(l, r, rt<<1)); //x \\n\\t} \\n\\tif (r > mid) {\\n\\t\\tans = max(ans, query(l, r, rt<<1|1)); //y\\n\\t}\\n //如果能够延续,设两端延续区间长度为z,那么肯定是在 x,y,z找最大值，另外，对于左区间,我们要保证\\n //向左延续的区间(rv)肯定是在[l,mid]中的(不然超过我们要查询的区间了),所以长度必须要在 mid - l+1之内\\n    //向右亦如此.\\n\\tif (a[mid] < a[mid+1]) {\\n        ans = max(ans, min(mid-l+1, tree[rt<<1].rv) + min(r-mid, tree[rt<<1|1].lv));\\n    }\\n   \\treturn ans;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &t);\\n\\twhile (t--) {\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\twhile (m--) {\\n\\t        char s[5];\\n\\t        scanf(\\\"%s\\\", s);\\n            if (s[0] == \'U\'){\\n                int b, c;\\n                scanf(\\\"%d%d\\\", &b, &c);\\n                a[++b] = c;  //由于题目下标从0开始，所以++\\n                update(1, n, b, 1);\\n            } else {\\n                int b, c;\\n                scanf(\\\"%d%d\\\", &b, &c);\\n                b++;\\n\\t\\t\\t   c++;\\n                printf(\\\"%d\\\\n\\\", query(b, c, 1));\\n            }\\n\\t    }\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621154837870.jpg\",\"articleTitle\":\"线段树刷题记录\",\"categoryId\":15,\"id\":55,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[32]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.194', '安徽省合肥市 联通', '2021-05-16 16:47:29');
INSERT INTO `tb_operation_log` VALUES (97, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 巴什博弈（Bash Game）\\n\\n​    一堆n个物品，两个人轮流从中取出1~m个，最后取光者胜（不能继续取的人输）。\\n\\n​    同余定理：n=k∗(m+1)+rn = k∗(m+1)+r，先者拿走rr个，那么后者无论拿走1 m1 m个先者只要的数目使和为m+1m+1，那么先手必赢。反之若n=k∗(m+1)n=k∗(m+1)，那么先手无论怎样都会输。\\n\\n```c++\\nif (n % (m + 1))  return false;\\nelse  return true;\\n```\\n### [Brave Game](http://acm.hdu.edu.cn/showproblem.php?pid=1846)\\n\\n**Problem Description**\\n\\n十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。\\n今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。\\n当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~\\n各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：\\n1、  本游戏是一个二人游戏;\\n2、  有一堆石子一共有n个；\\n3、  两人轮流进行;\\n4、  每走一步可以取走1…m个石子；\\n5、  最先取光石子的一方为胜；\\n如果游戏的双方使用的都是最优策略，请输出哪个人能赢。\\n\\n**Input**\\n\\n输入数据首先包含一个正整数C(C<=100)，表示有C组测试数据。\\n每组测试数据占一行，包含两个整数n和m（1<=n,m<=1000），n和m的含义见题目描述。\\n\\n**Output**\\n\\n如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n23 2\\n4 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\nfirst\\nsecond \\n```\\n\\n 巴什博弈\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 巴什博弈 \\nint c, n, m;\\nint main() {\\n\\tcin>>c;\\n\\twhile (c--) {\\n\\t\\tcin>>n>>m;\\n\\t\\tif (n % (m + 1)) {\\n\\t\\t\\tcout<<\\\"first\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"second\\\"<<endl; \\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [选拔志愿者](http://acm.hdu.edu.cn/showproblem.php?pid=2188)\\n\\n**Problem Description**\\n\\n对于四川同胞遭受的灾难，全国人民纷纷伸出援助之手，几乎每个省市都派出了大量的救援人员，这其中包括抢险救灾的武警部队，治疗和防疫的医护人员，以及进行心理疏导的心理学专家。根据要求，我校也有一个奔赴灾区救灾的名额，由于广大师生报名踊跃，学校不得不进行选拔来决定最后的人选。经过多轮的考核，形势逐渐明朗，最后的名额将在“林队”和“徐队”之间产生。但是很巧合，2个人的简历几乎一模一样，这让主持选拔的8600很是为难。无奈，他决定通过捐款来决定两人谁能入选。\\n选拔规则如下：\\n1、最初的捐款箱是空的；\\n2、两人轮流捐款，每次捐款额必须为正整数，并且每人每次捐款最多不超过m元(1<=m<=10)。\\n3、最先使得总捐款额达到或者超过n元（0<n<10000）的一方为胜者，则其可以亲赴灾区服务。\\n我们知道，两人都很想入选志愿者名单，并且都是非常聪明的人，假设林队先捐，请你判断谁能入选最后的名单？\\n\\n**Input**\\n\\n输入数据首先包含一个正整数C，表示包含C组测试用例，然后是C行数据，每行包含两个正整数n，m，n和m的含义参见上面提到的规则。\\n\\n**Output**\\n\\n对于每组测试数据，如果林队能入选，请输出字符串\\\"Grass\\\"， 如果徐队能入选，请输出字符串\\\"Rabbit\\\"，每个实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n8 10\\n11 10\\n```\\n\\n**Sample Output**\\n\\n```c++\\nGrass\\nRabbit\\n```\\n\\n巴什博弈模板\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint c, n, m;\\n\\nint main() {\\n\\tcin>>c;\\n\\twhile (c--) {\\n\\t\\tcin>>n>>m;\\n\\t\\t// 如果 n % (m + 1) == 1，则先手必输，否则先手必赢（巴什博弈） \\n\\t\\tif (n % (m + 1)) {\\n\\t\\t\\tcout<<\\\"Grass\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"Rabbit\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [Public Sale](http://acm.hdu.edu.cn/showproblem.php?pid=2149)\\n\\n**Problem Description**\\n\\n虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。\\n要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。\\n后来发现，整个拍卖会只有Lele和他的死对头Yueyue。\\n通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。\\nLele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。\\n由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候，\\nLele要出多少才能保证自己买得到这块地呢？\\n\\n**Input**\\n\\n本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。\\n每组测试包含两个整数M和N(含义见题目描述，0<N，M<1100)\\n\\n**Output**\\n\\n对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。\\n如果Lele在第一次无论如何出价都无法买到这块土地，就输出\\\"none\\\"。\\n\\n**Sample Input**\\n\\n```c++\\n4 2\\n3 2\\n3 5\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1\\nnone\\n3 4 5\\n```\\n\\n巴什博弈\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 巴什博弈\\nint M, N;\\nint main() {\\n\\twhile (cin>>M>>N) {\\n\\t\\tif (M % (N + 1) == 0) {\\n\\t\\t\\tcout<<\\\"none\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tif (M <= N) {\\n\\t\\t\\t\\tfor (int i = M; i <= N - 1; i++) {\\n\\t\\t\\t\\t\\tcout<<i<<\\\" \\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcout<<N<<endl;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcout<<M % (N + 1)<<endl;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## 威佐夫博弈（Wythoff Game）\\n\\n​    有两堆各若干物品，两个人轮流从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。\\n\\n​    这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数，ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...ak=[k∗(1+5)/2], bk=ak+k, k=0,1,2,3...。\\n\\n​    所以，先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\\n\\n```c++\\ndouble r = (sqrt(5) + 1) / 2;\\nint d = abs(a - b) * r;\\nif (d != min(a, b))  return true;\\nelse  false;\\n```\\n\\n注：如果a,b的值非常大的话，需要高精度来计算这个double类型的r。\\n\\n### [取石子游戏 POJ-1067](http://poj.org/problem?id=1067)\\n\\n**Description**\\n\\n有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。\\n\\n**Input**\\n\\n输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。\\n\\n**Output**\\n\\n输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。\\n\\n**Sample Input**\\n\\n```c++\\n2 1\\n8 4\\n4 7\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n1\\n0\\n```\\n\\n威佐夫博弈\\n\\n```c++\\n#include<iostream>\\n#include<cmath>\\n#include<algorithm>\\nusing namespace std;\\n\\n// 威佐夫博弈\\n// 先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\\nint main() {\\n\\tint a, b;\\n\\twhile (cin>>a>>b) {\\n\\t\\tdouble r = (sqrt(5.0) + 1) / 2.0;\\n\\t\\tint d = abs(a - b) * r;\\n\\t\\tif (d != min(a, b)) {\\n\\t\\t\\tcout<<1<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## 斐波那契博弈（Fibonacci Nim Game）\\n\\n​    一堆石子有n个，两人轮流取，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。\\n\\n​    同样是一个规律：先手胜当且仅当n不是斐波那契数。\\n\\n```c++\\nf[0] = f[1] = 1;\\nfor (int i = 0; f[i - 1] < n; i++)\\n{\\n    f[i] = f[i - 1] + f[i - 2];\\n    if (f[i] == n)  return true;\\n}\\nreturn false;\\n```\\n\\n### [取石子游戏 HDU-2516](http://acm.hdu.edu.cn/showproblem.php?pid=2516)\\n\\n**Problem Description**\\n\\n1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出\\\"Second win\\\".先取者胜输出\\\"First win\\\".\\n\\n**Input**\\n\\n输入有多组.每组第1行是2<=n<2^31. n=0退出.\\n\\n**Output**\\n\\n先取者负输出\\\"Second win\\\". 先取者胜输出\\\"First win\\\".\\n参看Sample Output.\\n\\n**Sample Input**\\n\\n```c++\\n2\\n13\\n10000\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\nSecond win\\nSecond win\\nFirst win\\n```\\n\\n斐波那契博弈\\n\\n```c++\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\n// 斐波那契博弈，先手胜当且仅当n不是斐波那契数。 \\nint main() {\\n    int fib[44];\\n    fib[0] = 2, fib[1] = 3;\\n    for (int i = 2; i < 44; i++) {\\n    \\tfib[i] = fib[i - 1] + fib[i - 2];\\n\\t}  \\n    int n;\\n    while (~scanf(\\\"%d\\\", &n) && n) {\\n        if (binary_search(fib, fib + 44, n)) {\\n        \\tprintf(\\\"Second win\\\\n\\\");\\n\\t\\t} else {\\n\\t\\t\\tprintf(\\\"First win\\\\n\\\");\\n\\t\\t}\\n    }\\n    return 0;\\n}\\n\\n```\\n\\n\\n## 尼姆博弈（Nimm Game）\\n\\n​    有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜。\\n\\n​    假如有3堆物品(a,b,c)\\n  （0，0，0）状态时先手是一个必输局势因为没有东西可取，(0,n,n) 状态时也是必输局势只要后者在另一堆取得物品与前者一样多时那么前者也就是必输局势。慢分析(1,2,3)也是一个必输局势。如果我们将其转化为二进制形式并通过异或运算(^)我们会发现：\\n\\n```c++\\n 0001^0010^0011=0000\\n```\\n\\n通过验证所有的堆数量累^后只要为0就都是必输局势，所以我们就只要记住这个规则：将n堆物品数量全部异或后结果为0先手必败，否则必胜。\\n\\n```c++\\nint res = 0;\\nfor (int i = 1; i <= n; i++)\\n    res ^= arr[i];\\nif (res)  return true;\\nelse  return false;\\n```\\n\\n### [Matches Game](http://poj.org/problem?id=2234)\\n\\n**Description**\\n\\nHere is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a player’s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not.\\n\\n**Input**\\n\\nThe input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 <= M <=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.\\n\\n**Output**\\n\\nFor each test case, output \\\"Yes\\\" in a single line, if the player who play first will win, otherwise output \\\"No\\\".\\n\\n**Sample Input**\\n\\n```c++\\n2 45 45\\n3 3 6 9\\n```\\n\\n**Sample Output**\\n\\n```c++\\nNo\\nYes\\n```\\n\\n题目大意：两个玩家，可以选择一个堆并从堆中除去任意数量的火柴（当然，被除去的火柴数不能为零，并且不能大于所选堆中的火柴数）。如果在一个玩家回合之后没有剩余比赛，则该玩家为获胜者。假设两个参与者都非常清楚。您的工作是告诉最先玩的玩家是否可以赢得比赛。\\n\\nn 堆物品数量，尼姆博弈\\n\\n\\n```c++\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\n// 尼姆博弈，将n堆物品数量全部异或后结果为0先手必败，否则必胜。 \\nint main() {\\n\\tint M;\\n\\twhile (cin>>M) {\\n\\t\\tint res = 0, x;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tcin>>x;\\n\\t\\t\\tres ^= x;\\n\\t\\t}\\n\\t\\tif (res) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\",\"articleCover\":\"\",\"articleTitle\":\"博弈论基础\",\"categoryId\":15,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:05:02');
INSERT INTO `tb_operation_log` VALUES (98, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 巴什博弈（Bash Game）\\n\\n​    一堆n个物品，两个人轮流从中取出1~m个，最后取光者胜（不能继续取的人输）。\\n\\n​    同余定理：n=k∗(m+1)+rn = k∗(m+1)+r，先者拿走rr个，那么后者无论拿走1 m1 m个先者只要的数目使和为m+1m+1，那么先手必赢。反之若n=k∗(m+1)n=k∗(m+1)，那么先手无论怎样都会输。\\n\\n```c++\\nif (n % (m + 1))  return false;\\nelse  return true;\\n```\\n### [Brave Game](http://acm.hdu.edu.cn/showproblem.php?pid=1846)\\n\\n**Problem Description**\\n\\n十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。\\n今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。\\n当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~\\n各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：\\n1、  本游戏是一个二人游戏;\\n2、  有一堆石子一共有n个；\\n3、  两人轮流进行;\\n4、  每走一步可以取走1…m个石子；\\n5、  最先取光石子的一方为胜；\\n如果游戏的双方使用的都是最优策略，请输出哪个人能赢。\\n\\n**Input**\\n\\n输入数据首先包含一个正整数C(C<=100)，表示有C组测试数据。\\n每组测试数据占一行，包含两个整数n和m（1<=n,m<=1000），n和m的含义见题目描述。\\n\\n**Output**\\n\\n如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n23 2\\n4 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\nfirst\\nsecond \\n```\\n\\n 巴什博弈\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 巴什博弈 \\nint c, n, m;\\nint main() {\\n\\tcin>>c;\\n\\twhile (c--) {\\n\\t\\tcin>>n>>m;\\n\\t\\tif (n % (m + 1)) {\\n\\t\\t\\tcout<<\\\"first\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"second\\\"<<endl; \\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [选拔志愿者](http://acm.hdu.edu.cn/showproblem.php?pid=2188)\\n\\n**Problem Description**\\n\\n对于四川同胞遭受的灾难，全国人民纷纷伸出援助之手，几乎每个省市都派出了大量的救援人员，这其中包括抢险救灾的武警部队，治疗和防疫的医护人员，以及进行心理疏导的心理学专家。根据要求，我校也有一个奔赴灾区救灾的名额，由于广大师生报名踊跃，学校不得不进行选拔来决定最后的人选。经过多轮的考核，形势逐渐明朗，最后的名额将在“林队”和“徐队”之间产生。但是很巧合，2个人的简历几乎一模一样，这让主持选拔的8600很是为难。无奈，他决定通过捐款来决定两人谁能入选。\\n选拔规则如下：\\n1、最初的捐款箱是空的；\\n2、两人轮流捐款，每次捐款额必须为正整数，并且每人每次捐款最多不超过m元(1<=m<=10)。\\n3、最先使得总捐款额达到或者超过n元（0<n<10000）的一方为胜者，则其可以亲赴灾区服务。\\n我们知道，两人都很想入选志愿者名单，并且都是非常聪明的人，假设林队先捐，请你判断谁能入选最后的名单？\\n\\n**Input**\\n\\n输入数据首先包含一个正整数C，表示包含C组测试用例，然后是C行数据，每行包含两个正整数n，m，n和m的含义参见上面提到的规则。\\n\\n**Output**\\n\\n对于每组测试数据，如果林队能入选，请输出字符串\\\"Grass\\\"， 如果徐队能入选，请输出字符串\\\"Rabbit\\\"，每个实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n8 10\\n11 10\\n```\\n\\n**Sample Output**\\n\\n```c++\\nGrass\\nRabbit\\n```\\n\\n巴什博弈模板\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint c, n, m;\\n\\nint main() {\\n\\tcin>>c;\\n\\twhile (c--) {\\n\\t\\tcin>>n>>m;\\n\\t\\t// 如果 n % (m + 1) == 1，则先手必输，否则先手必赢（巴什博弈） \\n\\t\\tif (n % (m + 1)) {\\n\\t\\t\\tcout<<\\\"Grass\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"Rabbit\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [Public Sale](http://acm.hdu.edu.cn/showproblem.php?pid=2149)\\n\\n**Problem Description**\\n\\n虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。\\n要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。\\n后来发现，整个拍卖会只有Lele和他的死对头Yueyue。\\n通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。\\nLele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。\\n由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候，\\nLele要出多少才能保证自己买得到这块地呢？\\n\\n**Input**\\n\\n本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。\\n每组测试包含两个整数M和N(含义见题目描述，0<N，M<1100)\\n\\n**Output**\\n\\n对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。\\n如果Lele在第一次无论如何出价都无法买到这块土地，就输出\\\"none\\\"。\\n\\n**Sample Input**\\n\\n```c++\\n4 2\\n3 2\\n3 5\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1\\nnone\\n3 4 5\\n```\\n\\n巴什博弈\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 巴什博弈\\nint M, N;\\nint main() {\\n\\twhile (cin>>M>>N) {\\n\\t\\tif (M % (N + 1) == 0) {\\n\\t\\t\\tcout<<\\\"none\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tif (M <= N) {\\n\\t\\t\\t\\tfor (int i = M; i <= N - 1; i++) {\\n\\t\\t\\t\\t\\tcout<<i<<\\\" \\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcout<<N<<endl;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcout<<M % (N + 1)<<endl;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## 威佐夫博弈（Wythoff Game）\\n\\n​    有两堆各若干物品，两个人轮流从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。\\n\\n​    这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数，ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...ak=[k∗(1+5)/2], bk=ak+k, k=0,1,2,3...。\\n\\n​    所以，先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\\n\\n```c++\\ndouble r = (sqrt(5) + 1) / 2;\\nint d = abs(a - b) * r;\\nif (d != min(a, b))  return true;\\nelse  false;\\n```\\n\\n注：如果a,b的值非常大的话，需要高精度来计算这个double类型的r。\\n\\n### [取石子游戏 POJ-1067](http://poj.org/problem?id=1067)\\n\\n**Description**\\n\\n有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。\\n\\n**Input**\\n\\n输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。\\n\\n**Output**\\n\\n输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。\\n\\n**Sample Input**\\n\\n```c++\\n2 1\\n8 4\\n4 7\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n1\\n0\\n```\\n\\n威佐夫博弈\\n\\n```c++\\n#include<iostream>\\n#include<cmath>\\n#include<algorithm>\\nusing namespace std;\\n\\n// 威佐夫博弈\\n// 先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\\nint main() {\\n\\tint a, b;\\n\\twhile (cin>>a>>b) {\\n\\t\\tdouble r = (sqrt(5.0) + 1) / 2.0;\\n\\t\\tint d = abs(a - b) * r;\\n\\t\\tif (d != min(a, b)) {\\n\\t\\t\\tcout<<1<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## 斐波那契博弈（Fibonacci Nim Game）\\n\\n​    一堆石子有n个，两人轮流取，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。\\n\\n​    同样是一个规律：先手胜当且仅当n不是斐波那契数。\\n\\n```c++\\nf[0] = f[1] = 1;\\nfor (int i = 0; f[i - 1] < n; i++)\\n{\\n    f[i] = f[i - 1] + f[i - 2];\\n    if (f[i] == n)  return true;\\n}\\nreturn false;\\n```\\n\\n### [取石子游戏 HDU-2516](http://acm.hdu.edu.cn/showproblem.php?pid=2516)\\n\\n**Problem Description**\\n\\n1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出\\\"Second win\\\".先取者胜输出\\\"First win\\\".\\n\\n**Input**\\n\\n输入有多组.每组第1行是2<=n<2^31. n=0退出.\\n\\n**Output**\\n\\n先取者负输出\\\"Second win\\\". 先取者胜输出\\\"First win\\\".\\n参看Sample Output.\\n\\n**Sample Input**\\n\\n```c++\\n2\\n13\\n10000\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\nSecond win\\nSecond win\\nFirst win\\n```\\n\\n斐波那契博弈\\n\\n```c++\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\n// 斐波那契博弈，先手胜当且仅当n不是斐波那契数。 \\nint main() {\\n    int fib[44];\\n    fib[0] = 2, fib[1] = 3;\\n    for (int i = 2; i < 44; i++) {\\n    \\tfib[i] = fib[i - 1] + fib[i - 2];\\n\\t}  \\n    int n;\\n    while (~scanf(\\\"%d\\\", &n) && n) {\\n        if (binary_search(fib, fib + 44, n)) {\\n        \\tprintf(\\\"Second win\\\\n\\\");\\n\\t\\t} else {\\n\\t\\t\\tprintf(\\\"First win\\\\n\\\");\\n\\t\\t}\\n    }\\n    return 0;\\n}\\n\\n```\\n\\n\\n## 尼姆博弈（Nimm Game）\\n\\n​    有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜。\\n\\n​    假如有3堆物品(a,b,c)\\n  （0，0，0）状态时先手是一个必输局势因为没有东西可取，(0,n,n) 状态时也是必输局势只要后者在另一堆取得物品与前者一样多时那么前者也就是必输局势。慢分析(1,2,3)也是一个必输局势。如果我们将其转化为二进制形式并通过异或运算(^)我们会发现：\\n\\n```c++\\n 0001^0010^0011=0000\\n```\\n\\n通过验证所有的堆数量累^后只要为0就都是必输局势，所以我们就只要记住这个规则：将n堆物品数量全部异或后结果为0先手必败，否则必胜。\\n\\n```c++\\nint res = 0;\\nfor (int i = 1; i <= n; i++)\\n    res ^= arr[i];\\nif (res)  return true;\\nelse  return false;\\n```\\n\\n### [Matches Game](http://poj.org/problem?id=2234)\\n\\n**Description**\\n\\nHere is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a player’s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not.\\n\\n**Input**\\n\\nThe input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 <= M <=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.\\n\\n**Output**\\n\\nFor each test case, output \\\"Yes\\\" in a single line, if the player who play first will win, otherwise output \\\"No\\\".\\n\\n**Sample Input**\\n\\n```c++\\n2 45 45\\n3 3 6 9\\n```\\n\\n**Sample Output**\\n\\n```c++\\nNo\\nYes\\n```\\n\\n题目大意：两个玩家，可以选择一个堆并从堆中除去任意数量的火柴（当然，被除去的火柴数不能为零，并且不能大于所选堆中的火柴数）。如果在一个玩家回合之后没有剩余比赛，则该玩家为获胜者。假设两个参与者都非常清楚。您的工作是告诉最先玩的玩家是否可以赢得比赛。\\n\\nn 堆物品数量，尼姆博弈\\n\\n\\n```c++\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\n// 尼姆博弈，将n堆物品数量全部异或后结果为0先手必败，否则必胜。 \\nint main() {\\n\\tint M;\\n\\twhile (cin>>M) {\\n\\t\\tint res = 0, x;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tcin>>x;\\n\\t\\t\\tres ^= x;\\n\\t\\t}\\n\\t\\tif (res) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\",\"articleCover\":\"\",\"articleTitle\":\"博弈论基础\",\"categoryId\":15,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:05:02');
INSERT INTO `tb_operation_log` VALUES (99, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"博弈\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:05:12');
INSERT INTO `tb_operation_log` VALUES (100, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[56],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:05:36');
INSERT INTO `tb_operation_log` VALUES (101, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## 巴什博弈（Bash Game）\\n\\n​    一堆n个物品，两个人轮流从中取出1~m个，最后取光者胜（不能继续取的人输）。\\n\\n​    同余定理：n=k∗(m+1)+rn = k∗(m+1)+r，先者拿走rr个，那么后者无论拿走1 m1 m个先者只要的数目使和为m+1m+1，那么先手必赢。反之若n=k∗(m+1)n=k∗(m+1)，那么先手无论怎样都会输。\\n\\n```c++\\nif (n % (m + 1))  return false;\\nelse  return true;\\n```\\n### [Brave Game](http://acm.hdu.edu.cn/showproblem.php?pid=1846)\\n\\n**Problem Description**\\n\\n十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。\\n今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。\\n当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~\\n各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：\\n1、  本游戏是一个二人游戏;\\n2、  有一堆石子一共有n个；\\n3、  两人轮流进行;\\n4、  每走一步可以取走1…m个石子；\\n5、  最先取光石子的一方为胜；\\n如果游戏的双方使用的都是最优策略，请输出哪个人能赢。\\n\\n**Input**\\n\\n输入数据首先包含一个正整数C(C<=100)，表示有C组测试数据。\\n每组测试数据占一行，包含两个整数n和m（1<=n,m<=1000），n和m的含义见题目描述。\\n\\n**Output**\\n\\n如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n23 2\\n4 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\nfirst\\nsecond \\n```\\n\\n 巴什博弈\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 巴什博弈 \\nint c, n, m;\\nint main() {\\n\\tcin>>c;\\n\\twhile (c--) {\\n\\t\\tcin>>n>>m;\\n\\t\\tif (n % (m + 1)) {\\n\\t\\t\\tcout<<\\\"first\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"second\\\"<<endl; \\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [选拔志愿者](http://acm.hdu.edu.cn/showproblem.php?pid=2188)\\n\\n**Problem Description**\\n\\n对于四川同胞遭受的灾难，全国人民纷纷伸出援助之手，几乎每个省市都派出了大量的救援人员，这其中包括抢险救灾的武警部队，治疗和防疫的医护人员，以及进行心理疏导的心理学专家。根据要求，我校也有一个奔赴灾区救灾的名额，由于广大师生报名踊跃，学校不得不进行选拔来决定最后的人选。经过多轮的考核，形势逐渐明朗，最后的名额将在“林队”和“徐队”之间产生。但是很巧合，2个人的简历几乎一模一样，这让主持选拔的8600很是为难。无奈，他决定通过捐款来决定两人谁能入选。\\n选拔规则如下：\\n1、最初的捐款箱是空的；\\n2、两人轮流捐款，每次捐款额必须为正整数，并且每人每次捐款最多不超过m元(1<=m<=10)。\\n3、最先使得总捐款额达到或者超过n元（0<n<10000）的一方为胜者，则其可以亲赴灾区服务。\\n我们知道，两人都很想入选志愿者名单，并且都是非常聪明的人，假设林队先捐，请你判断谁能入选最后的名单？\\n\\n**Input**\\n\\n输入数据首先包含一个正整数C，表示包含C组测试用例，然后是C行数据，每行包含两个正整数n，m，n和m的含义参见上面提到的规则。\\n\\n**Output**\\n\\n对于每组测试数据，如果林队能入选，请输出字符串\\\"Grass\\\"， 如果徐队能入选，请输出字符串\\\"Rabbit\\\"，每个实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n8 10\\n11 10\\n```\\n\\n**Sample Output**\\n\\n```c++\\nGrass\\nRabbit\\n```\\n\\n巴什博弈模板\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint c, n, m;\\n\\nint main() {\\n\\tcin>>c;\\n\\twhile (c--) {\\n\\t\\tcin>>n>>m;\\n\\t\\t// 如果 n % (m + 1) == 1，则先手必输，否则先手必赢（巴什博弈） \\n\\t\\tif (n % (m + 1)) {\\n\\t\\t\\tcout<<\\\"Grass\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"Rabbit\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [Public Sale](http://acm.hdu.edu.cn/showproblem.php?pid=2149)\\n\\n**Problem Description**\\n\\n虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。\\n要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。\\n后来发现，整个拍卖会只有Lele和他的死对头Yueyue。\\n通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。\\nLele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。\\n由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候，\\nLele要出多少才能保证自己买得到这块地呢？\\n\\n**Input**\\n\\n本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。\\n每组测试包含两个整数M和N(含义见题目描述，0<N，M<1100)\\n\\n**Output**\\n\\n对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。\\n如果Lele在第一次无论如何出价都无法买到这块土地，就输出\\\"none\\\"。\\n\\n**Sample Input**\\n\\n```c++\\n4 2\\n3 2\\n3 5\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1\\nnone\\n3 4 5\\n```\\n\\n巴什博弈\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// 巴什博弈\\nint M, N;\\nint main() {\\n\\twhile (cin>>M>>N) {\\n\\t\\tif (M % (N + 1) == 0) {\\n\\t\\t\\tcout<<\\\"none\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tif (M <= N) {\\n\\t\\t\\t\\tfor (int i = M; i <= N - 1; i++) {\\n\\t\\t\\t\\t\\tcout<<i<<\\\" \\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcout<<N<<endl;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcout<<M % (N + 1)<<endl;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## 威佐夫博弈（Wythoff Game）\\n\\n​    有两堆各若干物品，两个人轮流从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。\\n\\n​    这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数，ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...ak=[k∗(1+5)/2], bk=ak+k, k=0,1,2,3...。\\n\\n​    所以，先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\\n\\n```c++\\ndouble r = (sqrt(5) + 1) / 2;\\nint d = abs(a - b) * r;\\nif (d != min(a, b))  return true;\\nelse  false;\\n```\\n\\n注：如果a,b的值非常大的话，需要高精度来计算这个double类型的r。\\n\\n### [取石子游戏 POJ-1067](http://poj.org/problem?id=1067)\\n\\n**Description**\\n\\n有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。\\n\\n**Input**\\n\\n输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。\\n\\n**Output**\\n\\n输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。\\n\\n**Sample Input**\\n\\n```c++\\n2 1\\n8 4\\n4 7\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n1\\n0\\n```\\n\\n威佐夫博弈\\n\\n```c++\\n#include<iostream>\\n#include<cmath>\\n#include<algorithm>\\nusing namespace std;\\n\\n// 威佐夫博弈\\n// 先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。\\nint main() {\\n\\tint a, b;\\n\\twhile (cin>>a>>b) {\\n\\t\\tdouble r = (sqrt(5.0) + 1) / 2.0;\\n\\t\\tint d = abs(a - b) * r;\\n\\t\\tif (d != min(a, b)) {\\n\\t\\t\\tcout<<1<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## 斐波那契博弈（Fibonacci Nim Game）\\n\\n​    一堆石子有n个，两人轮流取，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。\\n\\n​    同样是一个规律：先手胜当且仅当n不是斐波那契数。\\n\\n```c++\\nf[0] = f[1] = 1;\\nfor (int i = 0; f[i - 1] < n; i++)\\n{\\n    f[i] = f[i - 1] + f[i - 2];\\n    if (f[i] == n)  return true;\\n}\\nreturn false;\\n```\\n\\n### [取石子游戏 HDU-2516](http://acm.hdu.edu.cn/showproblem.php?pid=2516)\\n\\n**Problem Description**\\n\\n1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出\\\"Second win\\\".先取者胜输出\\\"First win\\\".\\n\\n**Input**\\n\\n输入有多组.每组第1行是2<=n<2^31. n=0退出.\\n\\n**Output**\\n\\n先取者负输出\\\"Second win\\\". 先取者胜输出\\\"First win\\\".\\n参看Sample Output.\\n\\n**Sample Input**\\n\\n```c++\\n2\\n13\\n10000\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\nSecond win\\nSecond win\\nFirst win\\n```\\n\\n斐波那契博弈\\n\\n```c++\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\n// 斐波那契博弈，先手胜当且仅当n不是斐波那契数。 \\nint main() {\\n    int fib[44];\\n    fib[0] = 2, fib[1] = 3;\\n    for (int i = 2; i < 44; i++) {\\n    \\tfib[i] = fib[i - 1] + fib[i - 2];\\n\\t}  \\n    int n;\\n    while (~scanf(\\\"%d\\\", &n) && n) {\\n        if (binary_search(fib, fib + 44, n)) {\\n        \\tprintf(\\\"Second win\\\\n\\\");\\n\\t\\t} else {\\n\\t\\t\\tprintf(\\\"First win\\\\n\\\");\\n\\t\\t}\\n    }\\n    return 0;\\n}\\n\\n```\\n\\n\\n## 尼姆博弈（Nimm Game）\\n\\n​    有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜。\\n\\n​    假如有3堆物品(a,b,c)\\n  （0，0，0）状态时先手是一个必输局势因为没有东西可取，(0,n,n) 状态时也是必输局势只要后者在另一堆取得物品与前者一样多时那么前者也就是必输局势。慢分析(1,2,3)也是一个必输局势。如果我们将其转化为二进制形式并通过异或运算(^)我们会发现：\\n\\n```c++\\n 0001^0010^0011=0000\\n```\\n\\n通过验证所有的堆数量累^后只要为0就都是必输局势，所以我们就只要记住这个规则：将n堆物品数量全部异或后结果为0先手必败，否则必胜。\\n\\n```c++\\nint res = 0;\\nfor (int i = 1; i <= n; i++)\\n    res ^= arr[i];\\nif (res)  return true;\\nelse  return false;\\n```\\n\\n### [Matches Game](http://poj.org/problem?id=2234)\\n\\n**Description**\\n\\nHere is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a player’s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not.\\n\\n**Input**\\n\\nThe input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 <= M <=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.\\n\\n**Output**\\n\\nFor each test case, output \\\"Yes\\\" in a single line, if the player who play first will win, otherwise output \\\"No\\\".\\n\\n**Sample Input**\\n\\n```c++\\n2 45 45\\n3 3 6 9\\n```\\n\\n**Sample Output**\\n\\n```c++\\nNo\\nYes\\n```\\n\\n题目大意：两个玩家，可以选择一个堆并从堆中除去任意数量的火柴（当然，被除去的火柴数不能为零，并且不能大于所选堆中的火柴数）。如果在一个玩家回合之后没有剩余比赛，则该玩家为获胜者。假设两个参与者都非常清楚。您的工作是告诉最先玩的玩家是否可以赢得比赛。\\n\\nn 堆物品数量，尼姆博弈\\n\\n\\n```c++\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\n// 尼姆博弈，将n堆物品数量全部异或后结果为0先手必败，否则必胜。 \\nint main() {\\n\\tint M;\\n\\twhile (cin>>M) {\\n\\t\\tint res = 0, x;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tcin>>x;\\n\\t\\t\\tres ^= x;\\n\\t\\t}\\n\\t\\tif (res) {\\n\\t\\t\\tcout<<\\\"Yes\\\"<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<\\\"No\\\"<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621519670084.jpg\",\"articleTitle\":\"博弈论基础\",\"categoryId\":15,\"id\":57,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[33]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:08:05');
INSERT INTO `tb_operation_log` VALUES (102, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n**静态链表**：用数组来实现链式存储结构。\\n\\n#### 原理：\\n\\n+ 定义一个结构体数组，结构体包含一个data域和一个cur指针域\\n+ data域用来存放数据，cur用来指向下一个结点对应的数组下标\\n+ 把数组分为两个链表，数据链表（已经使用的结点）和备用链表（可分配的结点）\\n+ 数组0下标对应的cur指向备用链表，插入时通过它获取可分配的结点\\n+ 释放结点时，把被释放的结点插入到0下标对应结点的下一个结点\\n\\n#### 具体代码实现：\\n\\n```c\\n#include <stdio.h>\\n\\n#define SpaceSize 20\\n\\nstruct Node {\\n    int data; // 数据域\\n    int cur; // 指向下一个结点的指针\\n} CursorSpace[SpaceSize];\\n\\n/**\\n * 初始化静态链表\\n */\\nvoid InitializeCursorSpace() {\\n    int i;\\n\\n    for (i = 0; i < SpaceSize - 1; i++) {\\n        CursorSpace[i].cur = i + 1; // 都指向下一个位置\\n    }\\n    CursorSpace[SpaceSize - 1].cur = 0; // 最后一个结点指向0\\n}\\n\\n/**\\n * 分配结点，返回分配结点的下标\\n */\\nint CursorAlloc() {\\n    int p = CursorSpace[0].cur;  // 0号位置指向的是备用链表，即可分配的结点\\n\\n    if (p) { // 不为空，即可以分配，把下一个结点用来做备用\\n        CursorSpace[0].cur = CursorSpace[p].cur;\\n    }\\n    return p; // 返回分配的结点\\n}\\n\\n/**\\n * 释放结点，将p结点放回备用链表中\\n */\\nvoid CursorFree(int p) {\\n    // 0号结点指向的是备用链表，即可分配的第一个结点\\n    // 把要释放的结点指向0号结点指向的可分配的结点\\n    CursorSpace[p].cur = CursorSpace[0].cur;\\n    // 再把0号结点指向要释放的结点\\n    // 这两步操作把要释放的结点p插入到了0号结点与0号结点指向的可分配的结点之间\\n    // 所以，p结点可以通过0号结点重新分配给新的结点\\n    CursorSpace[0].cur = p;\\n}\\n\\n/**\\n * 判断静态链表是否为空\\n */\\nint Empty(int head) {\\n    return CursorSpace[head].cur == 0;\\n}\\n\\n/**\\n * 判断当前结点是否为最后一个结点\\n */\\nint IsLast(int p) {\\n    return CursorSpace[p].cur == 0;\\n}\\n\\n/**\\n * 返回静态链表的长度\\n */\\nint ListLength(int head) {\\n    int j = 0;\\n    int i = CursorSpace[head].cur;\\n\\n    while (i) {\\n        i = CursorSpace[i].cur;\\n        j++;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 查找某元素在静态链表中的位置\\n * @param e 查找的元素\\n * @param head 静态链表的头指针\\n * @return 元素在静态链表中的位置，查找不到，返回0\\n */\\nint Find(int e, int head) {\\n    int p, k = 1;\\n\\n    p = CursorSpace[head].cur;\\n    while (p && CursorSpace[p].data != e) {\\n        p = CursorSpace[p].cur;\\n        k++;\\n    }\\n    if (p)\\n        return k;\\n    return 0;\\n}\\n\\n/**\\n * 查找某元素在静态链表中的前一个结点的下标\\n * @param e 查找元素\\n * @param head 头指针\\n * @return 前一个结点的下标\\n */\\nint FindPrecious(int e, int head) {\\n    int p = head;\\n\\n    while (CursorSpace[p].cur && CursorSpace[CursorSpace[p].cur].data != e) {\\n        p = CursorSpace[p].cur;\\n    }\\n    return p;\\n}\\n\\n/**\\n * 删除静态链表中的元素\\n * @param e 要被删除的元素\\n * @param head\\n */\\nvoid Delete(int e, int head) {\\n    int p, TmpCell;\\n\\n    p = FindPrecious(e, head); // 找到被删除元素的前一个结点\\n    if (!IsLast(p)) { // 如果该节点不是最后一个结点\\n        TmpCell = CursorSpace[p].cur;\\n        CursorSpace[p].cur = CursorSpace[TmpCell].cur;\\n        CursorFree(TmpCell); // 释放删除元素对应的节点\\n    }\\n}\\n\\n/**\\n * 删除某个位置的结点\\n * @param head\\n * @param p 要删除的位置\\n */\\nvoid Delete_position(int head, int p) {\\n    int j, k;\\n\\n    if (p < 1 || p > ListLength(head)) {\\n        return;\\n    }\\n    k = head;\\n\\n    for (j = 1; j <= p - 1; j++) {\\n        k = CursorSpace[k].cur;\\n    }\\n    j = CursorSpace[k].cur;\\n    CursorSpace[k].cur = CursorSpace[j].cur;\\n    CursorFree(j);\\n}\\n\\n/**\\n * 在指定的下标插入元素\\n * @param e 插入的元素\\n * @param p 插入的下标\\n */\\nvoid Insert(int e, int p) {\\n    int TmpCell;\\n\\n    TmpCell = CursorAlloc();\\n    if (TmpCell == 0) {\\n        printf(\\\"List out of space!\\\\n\\\");\\n    } else {\\n        CursorSpace[TmpCell].data = e;\\n        CursorSpace[TmpCell].cur = CursorSpace[p].cur;\\n        CursorSpace[p].cur = TmpCell;\\n    }\\n}\\n\\n/**\\n * 在指定的位置插入元素\\n * @param head\\n * @param e 插入的元素\\n * @param i 插入的位置\\n */\\nvoid InsertList(int head, int e, int i) {\\n    int j, k, l;\\n\\n    k = head;\\n\\n    if (i < 1 || i > ListLength(head) + 1) {\\n        return;\\n    }\\n    j = CursorAlloc();\\n\\n    if (j) {\\n        CursorSpace[j].data = e;\\n        for (l = 1; l <= i - 1; l++) {\\n            k = CursorSpace[l].cur;\\n        }\\n        CursorSpace[j].cur = CursorSpace[k].cur;\\n        CursorSpace[k].cur = j;\\n    }\\n}\\n\\n/**\\n * 清空静态链表\\n */\\nvoid Delete_List(int head) {\\n    int p, Tem;\\n\\n    p = CursorSpace[head].cur;\\n    CursorSpace[head].cur = 0;\\n\\n    while (p) {\\n        Tem = CursorSpace[p].cur;\\n        CursorFree(p);\\n        p = Tem;\\n    }\\n}\\n\\n/**\\n * 打印静态链表的所有元素\\n */\\nvoid Print_List(int head) {\\n    int p = CursorSpace[head].cur;\\n\\n    if (Empty(head)) {\\n        printf(\\\"Empty!\\\\n\\\");\\n    } else {\\n        while (p) {\\n            printf(\\\"%d \\\", CursorSpace[p].data);\\n            p = CursorSpace[p].cur;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n\\n    int i, m, data_find, data_delete, p_delete, n_insert;\\n    int p, head, t;\\n\\t// 初始化\\n    InitializeCursorSpace();\\n    // 创建头结点，类似于单链表的头结点，方便插入和删除操作\\n    head = CursorAlloc();\\n\\n    printf(\\\"The position of head is %d\\\\n\\\", head);\\n    p = head;\\n\\n    printf(\\\"Please input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &m);\\n\\n    printf(\\\"The original input is as follows :\\\\n\\\");\\n\\n    for (i = 1; i <= m; i++) {\\n        t = CursorAlloc();\\n        scanf(\\\"%d\\\", &CursorSpace[t].data);\\n        CursorSpace[p].cur = t;\\n        p = t;\\n    }\\n    CursorSpace[p].cur = 0;\\n\\n    Print_List(head);\\n\\n    printf(\\\"input the data to find :\\\\n\\\");\\n    scanf(\\\"%d\\\", &data_find);\\n    p = Find(data_find, head);\\n    printf(\\\"The position of data is %d\\\\n\\\", p);\\n\\n    printf(\\\"input the data to delete :\\\\n\\\");\\n    scanf(\\\"%d\\\", &data_delete);\\n    Delete(data_delete, head);\\n    Print_List(head);\\n\\n    printf(\\\"input the position to delete :\\\\n\\\");\\n    scanf(\\\"%d\\\", &p_delete);\\n    Delete_position(head, p_delete);\\n    Print_List(head);\\n\\n    printf(\\\"input the inserted number :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n_insert);\\n    printf(\\\"input the inserted position :\\\\n\\\");\\n    scanf(\\\"%d\\\", &p);\\n    InsertList(head, n_insert, p);\\n    Print_List(head);\\n\\n    printf(\\\"Now , the ListLength is %d.\\\\n\\\", ListLength(head));\\n    Delete_List(head);\\n    printf(\\\"After clearing , now the list is :\\\\n\\\");\\n    Print_List(head);\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081221275976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621520468622.jpg\",\"articleTitle\":\"线性表的静态链表实现（游标）\",\"categoryId\":16,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:21:44');
INSERT INTO `tb_operation_log` VALUES (103, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n**静态链表**：用数组来实现链式存储结构。\\n\\n#### 原理：\\n\\n+ 定义一个结构体数组，结构体包含一个data域和一个cur指针域\\n+ data域用来存放数据，cur用来指向下一个结点对应的数组下标\\n+ 把数组分为两个链表，数据链表（已经使用的结点）和备用链表（可分配的结点）\\n+ 数组0下标对应的cur指向备用链表，插入时通过它获取可分配的结点\\n+ 释放结点时，把被释放的结点插入到0下标对应结点的下一个结点\\n\\n#### 具体代码实现：\\n\\n```c\\n#include <stdio.h>\\n\\n#define SpaceSize 20\\n\\nstruct Node {\\n    int data; // 数据域\\n    int cur; // 指向下一个结点的指针\\n} CursorSpace[SpaceSize];\\n\\n/**\\n * 初始化静态链表\\n */\\nvoid InitializeCursorSpace() {\\n    int i;\\n\\n    for (i = 0; i < SpaceSize - 1; i++) {\\n        CursorSpace[i].cur = i + 1; // 都指向下一个位置\\n    }\\n    CursorSpace[SpaceSize - 1].cur = 0; // 最后一个结点指向0\\n}\\n\\n/**\\n * 分配结点，返回分配结点的下标\\n */\\nint CursorAlloc() {\\n    int p = CursorSpace[0].cur;  // 0号位置指向的是备用链表，即可分配的结点\\n\\n    if (p) { // 不为空，即可以分配，把下一个结点用来做备用\\n        CursorSpace[0].cur = CursorSpace[p].cur;\\n    }\\n    return p; // 返回分配的结点\\n}\\n\\n/**\\n * 释放结点，将p结点放回备用链表中\\n */\\nvoid CursorFree(int p) {\\n    // 0号结点指向的是备用链表，即可分配的第一个结点\\n    // 把要释放的结点指向0号结点指向的可分配的结点\\n    CursorSpace[p].cur = CursorSpace[0].cur;\\n    // 再把0号结点指向要释放的结点\\n    // 这两步操作把要释放的结点p插入到了0号结点与0号结点指向的可分配的结点之间\\n    // 所以，p结点可以通过0号结点重新分配给新的结点\\n    CursorSpace[0].cur = p;\\n}\\n\\n/**\\n * 判断静态链表是否为空\\n */\\nint Empty(int head) {\\n    return CursorSpace[head].cur == 0;\\n}\\n\\n/**\\n * 判断当前结点是否为最后一个结点\\n */\\nint IsLast(int p) {\\n    return CursorSpace[p].cur == 0;\\n}\\n\\n/**\\n * 返回静态链表的长度\\n */\\nint ListLength(int head) {\\n    int j = 0;\\n    int i = CursorSpace[head].cur;\\n\\n    while (i) {\\n        i = CursorSpace[i].cur;\\n        j++;\\n    }\\n    return j;\\n}\\n\\n/**\\n * 查找某元素在静态链表中的位置\\n * @param e 查找的元素\\n * @param head 静态链表的头指针\\n * @return 元素在静态链表中的位置，查找不到，返回0\\n */\\nint Find(int e, int head) {\\n    int p, k = 1;\\n\\n    p = CursorSpace[head].cur;\\n    while (p && CursorSpace[p].data != e) {\\n        p = CursorSpace[p].cur;\\n        k++;\\n    }\\n    if (p)\\n        return k;\\n    return 0;\\n}\\n\\n/**\\n * 查找某元素在静态链表中的前一个结点的下标\\n * @param e 查找元素\\n * @param head 头指针\\n * @return 前一个结点的下标\\n */\\nint FindPrecious(int e, int head) {\\n    int p = head;\\n\\n    while (CursorSpace[p].cur && CursorSpace[CursorSpace[p].cur].data != e) {\\n        p = CursorSpace[p].cur;\\n    }\\n    return p;\\n}\\n\\n/**\\n * 删除静态链表中的元素\\n * @param e 要被删除的元素\\n * @param head\\n */\\nvoid Delete(int e, int head) {\\n    int p, TmpCell;\\n\\n    p = FindPrecious(e, head); // 找到被删除元素的前一个结点\\n    if (!IsLast(p)) { // 如果该节点不是最后一个结点\\n        TmpCell = CursorSpace[p].cur;\\n        CursorSpace[p].cur = CursorSpace[TmpCell].cur;\\n        CursorFree(TmpCell); // 释放删除元素对应的节点\\n    }\\n}\\n\\n/**\\n * 删除某个位置的结点\\n * @param head\\n * @param p 要删除的位置\\n */\\nvoid Delete_position(int head, int p) {\\n    int j, k;\\n\\n    if (p < 1 || p > ListLength(head)) {\\n        return;\\n    }\\n    k = head;\\n\\n    for (j = 1; j <= p - 1; j++) {\\n        k = CursorSpace[k].cur;\\n    }\\n    j = CursorSpace[k].cur;\\n    CursorSpace[k].cur = CursorSpace[j].cur;\\n    CursorFree(j);\\n}\\n\\n/**\\n * 在指定的下标插入元素\\n * @param e 插入的元素\\n * @param p 插入的下标\\n */\\nvoid Insert(int e, int p) {\\n    int TmpCell;\\n\\n    TmpCell = CursorAlloc();\\n    if (TmpCell == 0) {\\n        printf(\\\"List out of space!\\\\n\\\");\\n    } else {\\n        CursorSpace[TmpCell].data = e;\\n        CursorSpace[TmpCell].cur = CursorSpace[p].cur;\\n        CursorSpace[p].cur = TmpCell;\\n    }\\n}\\n\\n/**\\n * 在指定的位置插入元素\\n * @param head\\n * @param e 插入的元素\\n * @param i 插入的位置\\n */\\nvoid InsertList(int head, int e, int i) {\\n    int j, k, l;\\n\\n    k = head;\\n\\n    if (i < 1 || i > ListLength(head) + 1) {\\n        return;\\n    }\\n    j = CursorAlloc();\\n\\n    if (j) {\\n        CursorSpace[j].data = e;\\n        for (l = 1; l <= i - 1; l++) {\\n            k = CursorSpace[l].cur;\\n        }\\n        CursorSpace[j].cur = CursorSpace[k].cur;\\n        CursorSpace[k].cur = j;\\n    }\\n}\\n\\n/**\\n * 清空静态链表\\n */\\nvoid Delete_List(int head) {\\n    int p, Tem;\\n\\n    p = CursorSpace[head].cur;\\n    CursorSpace[head].cur = 0;\\n\\n    while (p) {\\n        Tem = CursorSpace[p].cur;\\n        CursorFree(p);\\n        p = Tem;\\n    }\\n}\\n\\n/**\\n * 打印静态链表的所有元素\\n */\\nvoid Print_List(int head) {\\n    int p = CursorSpace[head].cur;\\n\\n    if (Empty(head)) {\\n        printf(\\\"Empty!\\\\n\\\");\\n    } else {\\n        while (p) {\\n            printf(\\\"%d \\\", CursorSpace[p].data);\\n            p = CursorSpace[p].cur;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n\\n    int i, m, data_find, data_delete, p_delete, n_insert;\\n    int p, head, t;\\n\\t// 初始化\\n    InitializeCursorSpace();\\n    // 创建头结点，类似于单链表的头结点，方便插入和删除操作\\n    head = CursorAlloc();\\n\\n    printf(\\\"The position of head is %d\\\\n\\\", head);\\n    p = head;\\n\\n    printf(\\\"Please input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &m);\\n\\n    printf(\\\"The original input is as follows :\\\\n\\\");\\n\\n    for (i = 1; i <= m; i++) {\\n        t = CursorAlloc();\\n        scanf(\\\"%d\\\", &CursorSpace[t].data);\\n        CursorSpace[p].cur = t;\\n        p = t;\\n    }\\n    CursorSpace[p].cur = 0;\\n\\n    Print_List(head);\\n\\n    printf(\\\"input the data to find :\\\\n\\\");\\n    scanf(\\\"%d\\\", &data_find);\\n    p = Find(data_find, head);\\n    printf(\\\"The position of data is %d\\\\n\\\", p);\\n\\n    printf(\\\"input the data to delete :\\\\n\\\");\\n    scanf(\\\"%d\\\", &data_delete);\\n    Delete(data_delete, head);\\n    Print_List(head);\\n\\n    printf(\\\"input the position to delete :\\\\n\\\");\\n    scanf(\\\"%d\\\", &p_delete);\\n    Delete_position(head, p_delete);\\n    Print_List(head);\\n\\n    printf(\\\"input the inserted number :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n_insert);\\n    printf(\\\"input the inserted position :\\\\n\\\");\\n    scanf(\\\"%d\\\", &p);\\n    InsertList(head, n_insert, p);\\n    Print_List(head);\\n\\n    printf(\\\"Now , the ListLength is %d.\\\\n\\\", ListLength(head));\\n    Delete_List(head);\\n    printf(\\\"After clearing , now the list is :\\\\n\\\");\\n    Print_List(head);\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081221275976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621520468622.jpg\",\"articleTitle\":\"线性表的静态链表实现（游标）\",\"categoryId\":16,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:22:44');
INSERT INTO `tb_operation_log` VALUES (104, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[58],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:23:15');
INSERT INTO `tb_operation_log` VALUES (105, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[56]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:23:22');
INSERT INTO `tb_operation_log` VALUES (106, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[58]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:23:24');
INSERT INTO `tb_operation_log` VALUES (107, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [HDU-1166 敌兵布阵](http://acm.hdu.edu.cn/showproblem.php?pid=1166): 区间求和、单点修改、区间查询\\n\\n**Problem Description**\\n\\nC国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。\\n中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:\\\"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：\\\"我知错了。。。\\\"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.\\n\\n**Input**\\n\\n第一行一个整数T，表示有T组数据。\\n每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。\\n接下来每行有一条命令，命令有4种形式：\\n(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）\\n(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;\\n(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数;\\n(4)End 表示结束，这条命令在每组数据最后出现;\\n每组数据最多有40000条命令\\n\\n**Output**\\n\\n对第i组数据,首先输出“Case i:”和回车,\\n对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10\\n1 2 3 4 5 6 7 8 9 10\\nQuery 1 3\\nAdd 3 6\\nQuery 2 7\\nSub 10 2\\nAdd 6 3\\nQuery 3 10\\nEnd \\n```\\n\\n**Sample Output**\\n\\n```c++\\nCase 1:\\n6\\n33\\n59\\n```\\n\\n **题解**：模板题\\n\\n```c++\\n#include<iostream>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 50005;\\nint a[maxn], t[maxn<<2];\\nint ans, T, n;\\n\\nvoid pushup(int i) {\\n\\tt[i] = t[i<<1] + t[i<<1|1];\\n}\\n\\nvoid build(int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = a[left];\\n\\t\\treturn;\\n\\t}\\n\\tint mid = left + ((right - left) >> 1);\\n\\tbuild(left, mid, index<<1);\\n\\tbuild(mid + 1, right, index<<1|1);\\n\\tpushup(index);\\n}\\n\\nvoid update(int p, int v, int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] += v;\\n\\t} else {\\n\\t\\tint mid = left + ((right - left) >> 1);\\n\\t\\tif (p <= mid) {\\n\\t\\t\\tupdate(p, v, left, mid, index << 1);\\n\\t\\t} else {\\n\\t\\t\\tupdate(p, v, mid + 1, right, index<<1|1);\\n\\t\\t}\\n\\t\\tpushup(index);\\n\\t}\\n}\\n\\nint query(int index, int L, int R, int l, int r) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn t[index];\\n\\t}\\n\\tint s = 0;\\n\\tint mid = l + ((r - l) >> 1);\\n\\tif (L <= mid) {\\n\\t\\ts += query(index<<1, L, R, l, mid);\\n\\t} \\n\\tif (R > mid) {\\n\\t\\ts += query(index<<1|1, L, R, mid + 1, r);\\n\\t}\\n\\treturn s;\\n}\\n\\nint main() {\\n\\tint x, y;\\n\\tscanf(\\\"%d\\\", &T);\\n\\tfor (int k = 1; k <= T; k++) {\\n\\t\\tprintf(\\\"Case %d:\\\\n\\\", k);\\n\\t\\tcin>>n;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tchar str[20];\\n\\t\\twhile (scanf(\\\"%s\\\", str) && str[0] != \'E\') {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\t\\t\\tif (str[0] == \'Q\') {\\n\\t\\t\\t\\tcout<<query(1, x, y, 1, n)<<endl;\\n\\t\\t\\t}\\n\\t\\t\\tif (str[0] == \'A\') {\\n\\t\\t\\t\\tupdate(x, y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (str[0] == \'S\') {\\n\\t\\t\\t\\tupdate(x, -y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [HDU-1754 I Hate It](http://acm.hdu.edu.cn/showproblem.php?pid=1754): 区间最值、单点修改、区间查询\\n\\n**Problem Description**\\n\\n很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。\\n这让很多学生很反感。\\n不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\\n\\n**Input**\\n\\n本题目包含多组测试，请处理到文件结束。\\n在每个测试的第一行，有两个正整数 N 和 M ( 0<N<=200000,0<M<5000 )，分别代表学生的数目和操作的数目。\\n学生ID编号分别从1编到N。\\n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。\\n接下来有M行。每一行有一个字符 C (只取\'Q\'或\'U\') ，和两个正整数A，B。\\n当C为\'Q\'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。\\n当C为\'U\'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。\\n\\n**Output**\\n\\n对于每一次询问操作，在一行里面输出最高成绩。\\n\\n**Sample Input**\\n\\n```C++\\n5 6\\n1 2 3 4 5\\nQ 1 5\\nU 3 6\\nQ 3 4\\nQ 4 5\\nU 2 9\\nQ 1 5\\n```\\n\\n**Sample Output**\\n\\n```C++\\n5\\n6\\n5\\n9\\n\\nHint\\nHuge input,the C function scanf() will work better than cin\\n```\\n\\n**题解**：模板题\\n\\n```c++\\n// 最值-单点更新，批量查询\\n#include<iostream>\\n#include<algorithm>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int INF = 1e8;\\nconst int maxn = 2000005;\\nint a[maxn], t[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tt[i] = max(t[i<<1], t[i<<1|1]);\\n}\\n\\nvoid build(int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = a[left];\\n\\t\\treturn;\\n\\t}\\n\\tint mid = left + ((right - left) >> 1);\\n\\tbuild(left, mid, index<<1);\\n\\tbuild(mid + 1, right, index<<1|1);\\n\\tpushup(index);\\n}\\n\\nvoid update(int p, int v, int left, int right, int index) {\\n\\tif (left == right) {\\n\\t\\tt[index] = v;\\n\\t} else {\\n\\t\\tint mid = left + ((right - left) >> 1);\\n\\t\\tif (p <= mid) {\\n\\t\\t\\tupdate(p, v, left, mid, index << 1);\\n\\t\\t} else {\\n\\t\\t\\tupdate(p, v, mid + 1, right, index<<1|1);\\n\\t\\t}\\n\\t\\tpushup(index);\\n\\t}\\n}\\n\\nint query(int index, int L, int R, int l, int r) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn t[index];\\n\\t}\\n\\tint smax = -INF;\\n\\tint mid = l + ((r - l) >> 1);\\n\\tif (L <= mid) {\\n\\t\\tsmax = max(smax, query(index<<1, L, R, l, mid));\\n\\t} \\n\\tif (R > mid) {\\n\\t\\tsmax = max(smax, query(index<<1|1, L, R, mid + 1, r));\\n\\t}\\n\\treturn smax;\\n}\\n\\nint n, m;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\tchar c;\\n\\t\\tint x, y;\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tscanf(\\\" %c%d%d\\\", &c, &x, &y);\\n\\t\\t\\tif (c == \'Q\') {\\n\\t\\t\\t\\tprintf(\\\"%d\\\\n\\\", query(1, x, y, 1, n));\\n\\t\\t\\t} else if (c == \'U\') {\\n\\t\\t\\t\\tupdate(x, y, 1, n, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n### [HDU-2795 Billboard](http://acm.hdu.edu.cn/showproblem.php?pid=2795): 区间最值、单点更新、区间查询\\n\\n**Problem Description**\\n\\nAt the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.\\nOn September 1, the billboard was empty. One by one, the announcements started being put on the billboard.\\nEach announcement is a stripe of paper of unit height. More specifically, the i-th announcement is a rectangle of size 1 * wi.\\nWhen someone puts a new announcement on the billboard, she would always choose the topmost possible position for the announcement. Among all possible topmost positions she would always choose the leftmost one.\\nIf there is no valid location for a new announcement, it is not put on the billboard (that\'s why some programming contests have no participants from this university).\\nGiven the sizes of the billboard and the announcements, your task is to find the numbers of rows in which the announcements are placed.\\n\\n**Input**\\n\\nThere are multiple cases (no more than 40 cases).\\nThe first line of the input file contains three integer numbers, h, w, and n (1 <= h,w <= 10^9; 1 <= n <= 200,000) - the dimensions of the billboard and the number of announcements.\\nEach of the next n lines contains an integer number wi (1 <= wi <= 10^9) - the width of i-th announcement.\\n\\n**Output**\\n\\nFor each announcement (in the order they are given in the input file) output one number - the number of the row in which this announcement is placed. Rows are numbered from 1 to h, starting with the top row. If an announcement can\'t be put on the billboard, output \\\"-1\\\" for this announcement.\\n\\n**Sample Input**\\n\\n```C++\\n3 5 5\\n2\\n4\\n3\\n3\\n3\\n```\\n\\n**Sample Output**\\n\\n```C++\\n1\\n2\\n1\\n3\\n-1\\n```\\n\\n**题解：**\\n\\n​        该题的大意就是在一块广告牌上张贴公告，广告牌有高宽限制，公告默认高度为1，输入广告牌的高度、宽度、公告的数量及每个公告的宽度，输出公告张贴的行号。（广告张贴高度优先，从高往低贴，高度一致，尽量贴左侧）\\n\\n​\\t用线段树的每个结点存储对应区间内最大的那一行的剩余宽度，只要维护好每个区间的最大值就行了。输入每一个公告的宽度，与树根比较，如果大于树根对应的最大宽度，直接输出-1，否则，与左子树比较，若比它小，就查询左子树，否则查询右子树。查询到之后再减去相应的宽度。\\n\\n​\\t如果广告牌的高度大于公告的数量时，即 h > n，令 h = n 。高出的部分没有意义。每行只能贴一个公告。\\n\\n```c++\\n// 最值-单点更新、批量查询\\n#include<iostream>\\n#include<algorithm>\\n#include<cstdio>\\n#include<cstring>\\nusing namespace std;\\n\\n#define maxn 200005\\nint tree[maxn<<2]; //每个结点存储的是宽度的最大值，区间为高度的区间 \\nint n, h, w, x;\\n\\nvoid pushup(int root) {\\n\\ttree[root] = max(tree[root<<1], tree[root<<1|1]);\\n}\\n\\nvoid build(int l, int r, int root) {\\n    if (l == r) {\\n        tree[root] = w; //初始高度均为w \\n        return;\\n    }\\n    int mid = (l + r) >> 1;\\n    build(l, mid, root<<1);\\n    build(mid + 1, r, root<<1|1);\\n    pushup(root);\\n}\\n\\nint query(int val, int l, int r, int root) {\\n    if (l == r) { //查询到合适的高度 \\n        tree[root] -= val; //对应的宽度减少val \\n        return l; //返回行号 \\n    }\\n    int mid = (l + r) >> 1;\\n    int ans;\\n    if (tree[root<<1] >= val) { //如果左子树的宽度最大值大于val，则去左子树查询 \\n    \\tans = query(val, l, mid, root<<1);\\n\\t} else { //否则，去右子树查询 \\n\\t\\tans = query(val, mid + 1, r, root<<1|1);\\t\\n\\t}  \\n    pushup(root);\\n    return ans;\\n}\\n\\nint main() {\\n    while (~scanf(\\\"%d%d%d\\\", &h, &w, &n)) {\\n        if (h > n) { //如果高度超过了广告牌的个数，高度置为个数，每层只能放一个广告牌 \\n        \\th = n;\\t\\n\\t\\t}  \\n        build(1, h, 1);\\n        for (int i = 1; i <= n; i++) {\\n            scanf(\\\"%d\\\", &x);\\n            if (x > tree[1]) { //如果宽度大于最大宽度，则输出-1 \\n            \\tprintf(\\\"%d\\\\n\\\", -1);\\n\\t\\t\\t} else { //否则，在线段树中查询 \\n\\t\\t\\t\\tprintf(\\\"%d\\\\n\\\", query(x, 1, h, 1));\\n\\t\\t\\t}     \\n        }\\n    }\\n    return 0;\\n}\\n```\\n\\n### [POJ-2828 Buy Tickets](http://poj.org/problem?id=2828): 排队、区间求和、单点更新\\n\\n**Description**\\n\\n*Railway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…*\\n\\nThe Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.\\n\\nIt was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!\\n\\nPeople kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.\\n\\n**Input**\\n\\nThere will be several test cases in the input. Each test case consists of *N* + 1 lines where *N* (1 ≤ *N* ≤ 200,000) is given in the first line of the test case. The next *N* lines contain the pairs of values *Posi* and *Vali* in the increasing order of *i* (1 ≤ *i* ≤ *N*). For each *i*, the ranges and meanings of *Posi* and *Vali* are as follows:\\n\\n- *Posi* ∈ [0, *i* − 1] — The *i*-th person came to the queue and stood right behind the *Posi*-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.\\n- *Vali* ∈ [0, 32767] — The *i*-th person was assigned the value *Vali*.\\n\\nThere no blank lines between test cases. Proceed to the end of input.\\n\\n**Output**\\n\\nFor each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.\\n\\n**Sample Input**\\n\\n```C++\\n4\\n0 77\\n1 51\\n1 33\\n2 69\\n4\\n0 20523\\n1 19243\\n1 3890\\n0 31492\\n```\\n\\n**Sample Output**\\n\\n```C++\\n77 33 69 51\\n31492 20523 3890 19243\\n```\\n\\n**Hint**  \\n\\n​      The figure below shows how the Little Cat found out the final order of people in the queue described in the first test case of the sample input.\\n\\n![img](http://poj.org/images/2828.gif)\\n\\n**题解：**\\n\\n​\\t题目大意，插队的问题，每个案例给出 n ，代表有 n 个插队的，每个给出 p, v，意思是代号为 v 的人插在了第 p 个人的后面，问最后的队伍的排列。\\n\\n​\\t一开始的队列是空的，如果输入i，j：代表代号为 j 的人插在代号为 i 的人的后面，也就是说他前面一定有了 i 个人，而他是第 i + 1 个人。\\n\\n​\\t所以从后往前推导，最后的人选定的位置是不会变的，同样，在第 i 个人后面插队，他的前面一定要留下 i 个空位。用线段树的每个结点存储对应区间的空位数的和。建树时叶子结点默认的空位为 1，每次输入 p 和 v 时，更新位数和为 p + 1 的结点，对应的位数和减 1，用数组记录对应的位置和序号。\\n\\n```c++\\n// 排队，求和-单点更新 \\n// 从后往前进行 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 2e5 + 5;\\nint sum[maxn<<2], b[maxn]; //sum中的每个结点存储对应区间中的空位数，b用来记录排队序列 \\n\\nstruct node {\\n\\tint p;\\n\\tint num;\\n} a[maxn];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] + sum[i<<1|1];\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\nvoid update(int p, int num, int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tsum[i]--;\\n\\t\\tb[l] = num;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tif (sum[i<<1] >= p) {\\n\\t\\tupdate(p, num, l, mid, i<<1); \\n\\t} else {\\n\\t// p-sum[i<<1]，从后往前推导，在第p个人后插队，他的前面一定要有p个空位，所以要减去左边的空位数 \\n\\t\\tupdate(p - sum[i<<1], num, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n} \\n\\nint main() {\\n\\tint n;\\n\\twhile (scanf(\\\"%d\\\", &n) != EOF) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &a[i].p, &a[i].num);\\n\\t\\t\\ta[i].p++; //开始把位置都加1，更新时只需找到sum为p的结点\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n        // 从后往前推\\n\\t\\tfor (int i = n; i > 0; i--) {\\n\\t\\t\\tupdate(a[i].p, a[i].num, 1, n, 1);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tprintf(\\\"%d \\\", b[i]);\\n\\t\\t}\\n\\t\\tprintf(\\\"\\\\n\\\");\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n### [HDU-1698 Just a Hook](http://acm.hdu.edu.cn/showproblem.php?pid=1698): 区间修改、延迟标记、区间求和\\n\\n**Problem Description**\\n\\nIn the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.\\n![img](http://acm.hdu.edu.cn/data/images/C116-1010-1.JPG)\\nNow Pudge wants to do some operations on the hook.\\nLet us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.\\nThe total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:\\nFor each cupreous stick, the value is 1.\\nFor each silver stick, the value is 2.\\nFor each golden stick, the value is 3.\\nPudge wants to know the total value of the hook after performing the operations.\\nYou may consider the original hook is made up of cupreous sticks.\\n\\n**Input**\\n\\nThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.\\nFor each case, the first line contains an integer N, 1<=N<=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0<=Q<=100,000, which is the number of the operations.\\nNext Q lines, each line contains three integers X, Y, 1<=X<=Y<=N, Z, 1<=Z<=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.\\n\\n**Output**\\n\\nFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10\\n2\\n1 5 2\\n5 9 3\\n```\\n\\n**Sample Output**\\n\\n```C++\\nCase 1: The total value of the hook is 24.\\n```\\n\\n**题解：**\\n\\n​\\t题目大意：有T组样例，每组样例给出n个棍子，开始时每个棍子的价值均为1，给出q个操作，可以把编号[x,y]之间的棍子d的价值改为z（z可以是1，2，3），求最终价值。\\n\\n​\\t线段树每个结点存储对应区间的价值和，开始叶子结点默认价值为1。区间修改模板。\\n\\n```c++\\n// 区间染色-区间修改，延迟标记 ，区间求和 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\nint lazy[maxn<<2];\\nint sum[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] + sum[i<<1|1];\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tlazy[i] = 0;\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1; // 初始值为1 \\n\\t\\treturn; \\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\n//更新子树的lazy值\\nvoid pushdown(int l, int r, int i) {\\n\\tint mid = (l + r) >> 1;\\n\\tif (lazy[i]) { //如果有lazy标记\\n\\t\\tlazy[i<<1] = lazy[i]; //更新左子树的lazy值 \\n\\t\\tlazy[i<<1|1] = lazy[i]; //更新右子树的lazy值\\n\\t\\tsum[i<<1] = lazy[i<<1] * (mid - l + 1); //更新左子树的和 \\n\\t\\tsum[i<<1|1] = lazy[i<<1|1] * (r - mid); //更新右子树的和 \\n\\t\\tlazy[i] = 0; //取消标记 \\n\\t}\\n}\\n\\nvoid update(int l, int r, int z, int L, int R, int i) {\\n\\tif (l <= L && R <= r) {\\n\\t\\tlazy[i] = z;\\n\\t\\tsum[i] = lazy[i] * (R - L + 1);\\n\\t\\treturn;\\n\\t}\\n\\tpushdown(L, R, i); //每次都需要更新子树的lazy标记 \\n\\tint mid = (L + R) >> 1;\\n\\tif (l <= mid) {\\n\\t\\tupdate(l, r, z, L, mid, i<<1);\\n\\t}\\n\\tif (r > mid) {\\n\\t\\tupdate(l, r, z, mid + 1, R, i<<1|1);\\n\\t}\\n\\tpushup(i); //更新父结点 \\n}\\n/*\\nint query(int l, int r, int L, int R, int i) {\\n\\tif (l <= L && R <= r) {\\n\\t\\treturn sum[i];\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tint res = 0;\\n\\tif (l <= mid) {\\n\\t\\tres += query(l, r, L, mid, i<<1);\\n\\t}\\n\\tif (r > mid) {\\n\\t\\tres += query(l, r, mid + 1, R, i<<1|1);\\n\\t} \\n\\treturn res;\\n}*/\\n\\nint main() {\\n    int T;\\n    scanf(\\\"%d\\\", &T);\\n    int kase = 0;\\n    while(T--) {\\n        int n, q;\\n        scanf(\\\"%d%d\\\", &n, &q);\\n        build(1, n, 1);\\n        for (int i = 0; i < q; i++) {\\n            int x, y, z;\\n            scanf(\\\"%d%d%d\\\", &x, &y, &z);\\n            update(x, y, z, 1, n, 1);\\n        }\\n        printf(\\\"Case %d: The total value of the hook is %d.\\\\n\\\", ++kase, sum[1]);\\n    }\\n    return 0;\\n}\\n```\\n\\n### [HDU-5023 A Corrupt Mayor\'s Performance Art](http://acm.hdu.edu.cn/showproblem.php?pid=5023): 区间染色、区间更新、区间查询、延迟标记、位运算\\n\\n**Problem Description**\\n\\nCorrupt governors always find ways to get dirty money. Paint something, then sell the worthless painting at a high price to someone who wants to bribe him/her on an auction, this seemed a safe way for mayor X to make money.\\nBecause a lot of people praised mayor X\'s painting(of course, X was a mayor), mayor X believed more and more that he was a very talented painter. Soon mayor X was not satisfied with only making money. He wanted to be a famous painter. So he joined the local painting associates. Other painters had to elect him as the chairman of the associates. Then his painting sold at better price.\\nThe local middle school from which mayor X graduated, wanted to beat mayor X\'s horse fart(In Chinese English, beating one\'s horse fart means flattering one hard). They built a wall, and invited mayor X to paint on it. Mayor X was very happy. But he really had no idea about what to paint because he could only paint very abstract paintings which nobody really understand. Mayor X\'s secretary suggested that he could make this thing not only a painting, but also a performance art work.\\nThis was the secretary\'s idea:\\nThe wall was divided into N segments and the width of each segment was one cun(cun is a Chinese length unit). All segments were numbered from 1 to N, from left to right. There were 30 kinds of colors mayor X could use to paint the wall. They named those colors as color 1, color 2 .... color 30. The wall\'s original color was color 2. Every time mayor X would paint some consecutive segments with a certain kind of color, and he did this for many times. Trying to make his performance art fancy, mayor X declared that at any moment, if someone asked how many kind of colors were there on any consecutive segments, he could give the number immediately without counting.\\nBut mayor X didn\'t know how to give the right answer. Your friend, Mr. W was an secret officer of anti-corruption bureau, he helped mayor X on this problem and gained his trust. Do you know how Mr. Q did this？\\n\\n**Input**\\n\\nThere are several test cases.\\nFor each test case:\\nThe first line contains two integers, N and M ,meaning that the wall is divided into N segments and there are M operations(0 < N <= 1,000,000; 0<M<=100,000)\\nThen M lines follow, each representing an operation. There are two kinds of operations, as described below:\\n1) P a b c\\na, b and c are integers. This operation means that mayor X painted all segments from segment a to segment b with color c ( 0 < a<=b <= N, 0 < c <= 30).\\n2) Q a b\\na and b are integers. This is a query operation. It means that someone asked that how many kinds of colors were there from segment a to segment b ( 0 < a<=b <= N).\\nPlease note that the operations are given in time sequence.\\nThe input ends with M = 0 and N = 0.\\n\\n**Output**\\n\\nFor each query operation, print all kinds of color on the queried segments. For color 1, print 1, for color 2, print 2 ... etc. And this color sequence must be in ascending order.\\n\\n**Sample Input**\\n\\n```C++\\n5 10\\nP 1 2 3\\nP 2 3 4\\nQ 2 3\\nQ 1 3\\nP 3 5 4\\nP 1 2 7\\nQ 1 3\\nQ 3 4\\nP 5 5 8\\nQ 1 5\\n0 0\\n```\\n\\n**Sample Output**\\n\\n```C++\\n4\\n3 4\\n4 7\\n4\\n4 7 8\\n```\\n\\n**题解：**\\n\\n题目大意：有最多30种颜色，一个长度为n的墙。一开始所有墙的颜色都是2。有两种操作：\\n\\n+ P l r x ：把区间[l,r]中所有的墙的颜色都改为x\\n+ Q l r ：询问[l,r]里面的颜色，把颜色升序输出\\n\\n\\n因为颜色种数最大只有30，可以直接用二进制表示是否含有某种颜色。就是利用优美的位运算的性质，初始为1，当有某种颜色时就<<代表此种颜色的数字，最后在每次输出的时候再从1到30种颜色中逐一>>并&1就可以检验是否含有这种颜色！\\n\\n```c++\\n// 区间染色-区间更新-区间查询-延迟标记 \\n#include<iostream>\\nusing namespace std;\\n\\nconst int maxn = 1e6+5;\\nint sum[maxn<<2];\\nint lazy[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tsum[i] = sum[i<<1] | sum[i<<1|1]; // 总共的颜色 \\n}\\n\\nvoid pushdown(int i) {\\n\\tif (lazy[i]) {\\n\\t\\tlazy[i<<1] = lazy[i];\\n\\t\\tlazy[i<<1|1] = lazy[i];\\n\\t\\tsum[i<<1] = lazy[i];\\n\\t\\tsum[i<<1|1] = lazy[i];\\n\\t\\tlazy[i] = 0;\\n\\t}\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tlazy[i] = 0;\\n\\tif (l == r) {\\n\\t\\tsum[i] = 1<<1;//初始颜色为2，即1<<1，左移1为\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n} \\n\\nvoid update(int L, int R, int c, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\tsum[i] = 1<<(c-1);\\n\\t\\tlazy[i] = 1<<(c-1);\\n\\t\\treturn;\\n\\t}\\n\\tpushdown(i);\\n\\tint mid = (l + r) >> 1;\\n\\tif (L <= mid) {\\n\\t\\tupdate(L, R, c, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tupdate(L, R, c, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n}\\n\\nint query(int L, int R, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\treturn sum[i];\\n\\t}\\n\\tpushdown(i);\\n\\tint mid = (l + r) >> 1;\\n\\tint res = 0;\\n\\tif (L <= mid) {\\n\\t\\tres |= query(L, R, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tres |= query(L, R, mid + 1, r, i<<1|1);\\n\\t}\\n\\treturn res;\\n}\\n\\nint main() {\\n\\tint N, Q;\\n    int a, b, c;\\n    while (~scanf(\\\"%d%d\\\", &N, &Q)) {\\n        if (N == 0 && Q == 0) {\\n            break;\\n\\t\\t}\\n        build(1, N, 1);//建树\\n        while (Q--) {\\n            char op[2];\\n            scanf(\\\"%s\\\",op);\\n            if (op[0] == \'Q\') {\\n                scanf(\\\"%d%d\\\", &a, &b);\\n                int tt = query(a, b, 1, N, 1);\\n                int flag = 0;\\n                for (int i = 1; i <= 30; i++) {\\n                    //通过右移来判断是否存在i号颜色\\n                    if (tt>>(i-1)&1 && flag == 0) { // flag用来控制输出格式 \\n                        printf(\\\"%d\\\", i);\\n                        flag = 1;\\n                    } else if (tt>>(i-1)&1) {\\n                    \\tprintf(\\\" %d\\\", i);\\n\\t\\t\\t\\t   }                      \\n                }\\n                printf(\\\"\\\\n\\\");\\n            } else {\\n                scanf(\\\"%d%d%d\\\", &a, &b, &c);\\n                update(a, b, c, 1, N, 1);\\n            }\\n        }\\n    }\\n\\treturn 0;\\n} \\n\\n//普通解法\\n#include<iostream>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1e6+5;\\nint t[maxn<<2];\\n\\nvoid pushup(int i) {\\n\\tif (t[i<<1] == t[i<<1|1]) { //如果两个儿子的颜色是一样的，说明大区间颜色一样\\n\\t\\tt[i] = t[i<<1];\\n\\t} else { //否则，整个区间颜色不一，大区间改为0\\n\\t\\tt[i] = 0;\\n\\t}\\n} \\n\\nvoid pushdown(int i) {\\n\\tif (!t[i]) { //如果大区间的颜色都是不确定的，没有必要往下传\\n\\t\\treturn;\\n\\t}\\n\\t//大区间颜色确定，说明下面所有小区间颜色都是一样的\\n\\tt[i<<1] = t[i];\\n\\tt[i<<1|1] = t[i];\\n\\tt[i] = 0;\\n}\\n\\nvoid build(int l, int r, int i) {\\n\\tif (l == r) {\\n\\t\\tt[i] = 2;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, i<<1);\\n\\tbuild(mid + 1, r, i<<1|1);\\n\\tpushup(i);\\n}\\n\\nvoid update(int L, int R, int v, int l, int r, int i) {\\n\\tif (l >= L && r <= R) {\\n\\t\\tt[i] = v; //找到大区间后，把大区间的颜色更改，下面的小区间等要用到的时候更新\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l + r) >> 1;\\n\\tpushdown(i);\\n\\tif (L <= mid) {\\n\\t\\tupdate(L, R, v, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tupdate(L, R, v, mid + 1, r, i<<1|1);\\n\\t}\\n\\tpushup(i);\\n}\\n\\nint ans[35];\\nvoid query(int L, int R, int l, int r, int i) {\\n\\tif (t[i]) { //如果这个大区间的颜色是知道的，那么下面所有的小区间的颜色都一样，不用再找了\\n\\t\\tans[t[i]] = 1;\\n\\t\\treturn;\\n\\t}\\n\\t//大区间颜色不确定，再往下找\\n\\tint mid = (l + r) >> 1;\\n\\tpushdown(i);\\n\\tif (L <= mid) {\\n\\t\\tquery(L, R, l, mid, i<<1);\\n\\t}\\n\\tif (R > mid) {\\n\\t\\tquery(L, R, mid + 1, r, i<<1|1);\\n\\t}\\n}\\n\\nint main() {\\n\\tint n, m;\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &m)) {\\n        if (!n && !m) {\\n        \\tbreak;\\n\\t\\t}\\n        build(1, n, 1);\\n        char o[2];\\n        int x, y, z;\\n        for (int i = 1; i <= m; i++) {\\n            scanf(\\\"%s\\\",o);\\n            if (o[0] == \'P\') {\\n                scanf(\\\"%d%d%d\\\", &x, &y, &z);\\n                update(x, y, z, 1, n, 1);\\n            } else if (o[0] == \'Q\') {\\n                scanf(\\\"%d%d\\\", &x, &y);\\n                memset(ans, 0, sizeof(ans));//预置为0\\n                query(x, y, 1, n, 1);\\n                bool fir = false;//注意行尾空格\\n                for (int i = 1; i <= 30; i++) {\\n                    if (ans[i]) {\\n                        if (!fir) {\\n                            printf(\\\"%d\\\", i);\\n                            fir = true;\\n                        } else {\\n                            printf(\\\" %d\\\", i);\\n                        }  \\n                    }\\n                }\\n                printf(\\\"\\\\n\\\");\\n            }\\n        }\\n    }\\n\\treturn 0;\\n}\\n```\\n### [HDU-3308 LCIS](http://acm.hdu.edu.cn/showproblem.php?pid=3308): 区间合并、区间最值、单点更新、区间查询\\n\\n**Problem Description**\\n\\nGiven n integers.\\nYou have two operations:\\nU A B: replace the Ath number by B. (index counting from 0)\\nQ A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].\\n\\n**Input**\\n\\nT in the first line, indicating the case number.\\nEach case starts with two integers n , m(0<n,m<=105).\\nThe next line has n integers(0<=val<=105).\\nThe next m lines each has an operation:\\nU A B(0<=A,n , 0<=B=105)\\nOR\\nQ A B(0<=A<=B< n).\\n\\n**Output**\\n\\nFor each Q, output the answer.\\n\\n**Sample Input**\\n\\n```C++\\n1\\n10 10\\n7 7 3 3 5 9 9 8 1 8 \\nQ 6 6\\nU 3 4\\nQ 0 1\\nQ 0 5\\nQ 4 7\\nQ 3 5\\nQ 0 2\\nQ 4 6\\nU 6 10\\nQ 0 9\\n```\\n\\n**Sample Output**\\n\\n```C++\\n1\\n1\\n4\\n2\\n3\\n1\\n2\\n5\\n```\\n\\n**题解：**\\n\\n题目大意：给你n个数，m个操作。操作有两种：1.U x y 将数组第x位变为y   2. Q x y 问数组第x位到第y位连续最长子序列的长度。对于每次询问，输出一结果。\\n\\n分析：线段树单点修改区间合并。线段树维护三个值，lv是区间左端点开始的最长上升连续值，rv是以区间右端点结束的最长上升连续值，mv是该区间的最长上升连续值，pushup时分类讨论，当a[mid]<a[mid+1]时，可以知道该区间中间两个点是递增的。这需要合并操作，具体细节看代码注释：\\n\\n```c++\\n// 区间合并、单点更新、区间查询、区间最值 \\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1e5 + 5;\\nstruct Tree {\\n\\tint l, r;\\n\\t//lv是区间左端点开始的最长上升连续值\\n    //rv是以区间右端点结束的最长上升连续值\\n    //mv是该区间的最长上升连续值\\n\\tint lv, rv, mv; \\n} tree[maxn<<2];\\nint a[maxn];\\nint n, m, t;\\n\\nvoid pushup(int l, int r, int rt) {\\n\\ttree[rt].lv = tree[rt<<1].lv; //默认为左子树的lv \\n\\ttree[rt].rv = tree[rt<<1|1].rv;//默认为右子树的rv \\n\\ttree[rt].mv = max(tree[rt<<1].mv, tree[rt<<1|1].mv);//默认为左右子树mv的较大值 \\n\\tint mid = (l + r) >> 1;\\n\\tif (a[mid] < a[mid + 1]) { //左右可以合并 \\n\\t\\tif (tree[rt<<1].lv == mid - l + 1) { //左子树的lv长度等于区间长度 \\n\\t\\t\\ttree[rt].lv = tree[rt<<1].lv + tree[rt<<1|1].lv;\\n\\t\\t}\\n\\t\\tif (tree[rt<<1|1].rv == r - mid) { //右子树的lv长度等于区间长度 \\n\\t\\t\\ttree[rt].rv = tree[rt<<1].rv + tree[rt<<1|1].rv; \\n\\t\\t}\\n        // 更新区间的最大值，与合并后的比较，左区间右端点和右区间左端点合并\\n\\t\\ttree[rt].mv = max(tree[rt].mv, tree[rt<<1].rv + tree[rt<<1|1].lv);\\n\\t}\\n}\\n\\nvoid build(int l, int r, int rt) {\\n\\ttree[rt].l = l;\\n\\ttree[rt].r = r;\\n\\tif (l == r) {\\n\\t\\ttree[rt].lv = tree[rt].rv = tree[rt].mv = 1;\\n\\t\\treturn;\\n\\t} \\n\\tint mid = (l + r) >> 1;\\n\\tbuild(l, mid, rt<<1);\\n\\tbuild(mid + 1, r, rt<<1|1);\\n\\tpushup(l, r, rt);\\n}\\n\\n//单点更新 \\nvoid update(int l, int r, int p, int rt) {\\n    if (l == r) {\\n        return;\\n    }\\n    int mid = (l + r) >> 1;\\n    if (p <= mid) {\\n    \\tupdate(l, mid, p, rt<<1);\\n\\t} else {\\n\\t\\tupdate(mid + 1, r, p, rt<<1|1);\\n\\t}\\n    pushup(l, r, rt);\\n}\\n\\n//区间查询 \\nint query(int l, int r, int rt) {\\n\\tif (tree[rt].l >= l && tree[rt].r <= r) {\\n        return tree[rt].mv;\\n    }\\n    int mid = (tree[rt].l + tree[rt].r) >> 1;\\n    int ans = 0;\\n    //分别在左子区间和右子区间查找，结果分别为x,y,如果左右两个区间不能延续，\\n    //那肯定是在x,y中找一个最大值\\n    if (l <= mid) {\\n    \\tans = max(ans, query(l, r, rt<<1)); //x \\n\\t} \\n\\tif (r > mid) {\\n\\t\\tans = max(ans, query(l, r, rt<<1|1)); //y\\n\\t}\\n //如果能够延续,设两端延续区间长度为z,那么肯定是在 x,y,z找最大值，另外，对于左区间,我们要保证\\n //向左延续的区间(rv)肯定是在[l,mid]中的(不然超过我们要查询的区间了),所以长度必须要在 mid - l+1之内\\n    //向右亦如此.\\n\\tif (a[mid] < a[mid+1]) {\\n        ans = max(ans, min(mid-l+1, tree[rt<<1].rv) + min(r-mid, tree[rt<<1|1].lv));\\n    }\\n   \\treturn ans;\\n}\\n\\nint main() {\\n\\tscanf(\\\"%d\\\", &t);\\n\\twhile (t--) {\\n\\t\\tscanf(\\\"%d%d\\\", &n, &m);\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%d\\\", &a[i]);\\n\\t\\t}\\n\\t\\tbuild(1, n, 1);\\n\\t\\twhile (m--) {\\n\\t        char s[5];\\n\\t        scanf(\\\"%s\\\", s);\\n            if (s[0] == \'U\'){\\n                int b, c;\\n                scanf(\\\"%d%d\\\", &b, &c);\\n                a[++b] = c;  //由于题目下标从0开始，所以++\\n                update(1, n, b, 1);\\n            } else {\\n                int b, c;\\n                scanf(\\\"%d%d\\\", &b, &c);\\n                b++;\\n\\t\\t\\t   c++;\\n                printf(\\\"%d\\\\n\\\", query(b, c, 1));\\n            }\\n\\t    }\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621154837870.jpg\",\"articleTitle\":\"线段树刷题记录\",\"categoryId\":15,\"id\":55,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[32]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:28:21');
INSERT INTO `tb_operation_log` VALUES (108, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\\n\\n**Description**\\n\\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\\n每天只能卖一个商品.\\n现在你要让超市获得最大的利润.\\n\\n**Input**\\n\\n多组数据.\\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\\n\\n**Output**\\n\\n对于每一组数据, 输出当前条件下超市的最大利润\\n\\n**Sample Input**\\n\\n4\\n50 2\\n10 1\\n20 2\\n30 1\\n\\n7\\n20 1\\n2 1\\n10 3\\n100 2\\n8 2\\n5 20\\n50 10\\n\\n**Sample Output**\\n\\n80\\n185\\n\\n**解题思路**\\n\\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\n\\nusing namespace std;\\n\\ntypedef struct Node {\\n\\tint p;\\n\\tint d;\\n} Product;\\n\\nbool cmp(Product p1, Product p2) {\\n\\treturn p1.p > p2.p;\\n}\\n\\nProduct pro[10001];\\nint visit[10001]; //标记某天是否卖过商品\\n\\nint main() {\\n\\tint n, sum;\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tcin>>pro[i].p>>pro[i].d;\\n\\t\\t// 按利润从高到低排序\\n\\t\\tsort(pro + 1, pro + n + 1, cmp);\\n\\t\\tsum = 0;\\n\\t\\tmemset(visit, 0, sizeof(visit));\\n         // 先售卖高利润的商品\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (visit[pro[i].d] == 0) {\\n\\t\\t\\t\\tvisit[pro[i].d] = 1;\\n\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t} else {\\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\\n\\t\\t\\t\\tfor (int j = pro[i].d - 1; j >= 1; j--) {\\n\\t\\t\\t\\t\\tif (visit[j] == 0) {\\n\\t\\t\\t\\t\\t\\tvisit[j] = 1;\\n\\t\\t\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\\n\\n**Problem Description**\\n\\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\\n\\n**Input**\\n\\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\\n\\n**Output**\\n\\nFor each test case, you should output the smallest total reduced score, one line per test case.\\n\\n**Sample Input**\\n\\n```c++\\n3\\n3\\n3 3 3\\n10 5 1\\n3\\n1 3 1\\n6 2 3\\n7\\n1 4 6 4 2 4 3\\n3 2 1 7 6 5 4\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n3\\n5\\n```\\n\\n**解题思路**\\n\\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint deadline;\\n\\tint score;\\n} work[1005];\\n\\nint T, N;\\nint day[1005]; // 标记当天有没有做过作业 \\n\\nint cmp(Node a, Node b) {\\n\\treturn a.score > b.score; \\n}\\n\\nint main() {\\n\\tcin>>T;\\n\\tfor (int i = 0; i < T; i++) {\\n\\t\\tint res = 0;\\n\\t\\tmemset(day, 0, sizeof(day));\\n\\t\\tcin>>N;\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].deadline;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].score;\\n\\t\\t}\\n\\t\\t// 按分数降序排列 \\n\\t\\tsort(work, work + N, cmp);\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tint d = work[j].deadline;\\n\\t\\t\\t// 若当天没做作业 \\n\\t\\t\\tif (!day[d]) {\\n\\t\\t\\t\\t// 标记做过 \\n\\t\\t\\t\\tday[d] = 1;\\n\\t\\t\\t} else { // 当天做过作业 \\n\\t\\t\\t\\tint flag = 0; // 标记有没有找到 \\n\\t\\t\\t\\t// 往前找到没有做过作业的那天 \\n\\t\\t\\t\\tfor (int k = d - 1; k >= 1; k--) {\\n\\t\\t\\t\\t\\tif (!day[k]) { \\n\\t\\t\\t\\t\\t\\tday[k] = 1;\\n\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t// 没找到，则扣分 \\n\\t\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\t\\tres += work[j].score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\\n\\n**Problem Description**\\n\\n“今年暑假不AC？”\\n“是的。”\\n“那你干什么呢？”\\n“看世界杯呀，笨蛋！”\\n“@#$%^&*%...”\\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\\n\\n**Input**\\n\\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\\n\\n**Output**\\n\\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n12\\n1 3\\n3 4\\n0 7\\n3 8\\n15 19\\n15 20\\n10 15\\n8 18\\n6 12\\n5 10\\n4 14\\n2 9\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n5\\n```\\n\\n**解题思路**\\n\\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint tis;\\n\\tint tie;\\n} p[105];\\n \\nint cmp(Node a, Node b) {\\n\\treturn a.tie < b.tie;\\n}\\n\\nint main() {\\n\\tint n;\\n\\twhile (cin>>n && n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].tis>>p[i].tie;\\n\\t\\t}\\n\\t\\t// 按结束时间升序列 \\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint res = 1;\\n\\t\\tint pTie = p[0].tie; // 记录上个节目结束的时间 \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \\n\\t\\t\\tif (p[i].tis >= pTie) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tpTie = p[i].tie; // 更新 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn  0;\\n}\\n```\\n\\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\\n\\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \\\"carbon\\\"的字串是: \\\"c\\\", \\\"ca\\\", \\\"car\\\", \\\"carb\\\", \\\"carbo\\\", 和 \\\"carbon\\\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \\\"carbohydrate\\\" 通常用\\\"carb\\\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\\n在下面的例子中，\\\"carbohydrate\\\" 能被缩略成\\\"carboh\\\", 但是不能被缩略成\\\"carbo\\\" (或其余更短的前缀) 因为已经有一个单词用\\\"carbo\\\"开始\\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\\\"car\\\"精确匹配单词\\\"car\\\". 因此 \\\"car\\\" 是 \\\"car\\\"的缩略语是没有二义性的 , “car”不会被当成\\\"carriage\\\"或者任何在列表中以\\\"car\\\"开始的单词.\\n\\n**Input**\\n\\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\\n\\n**Output**\\n\\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\\n\\n**Sample Input**\\n\\n```c++\\ncarbohydrate\\ncart\\ncarburetor\\ncaramel\\ncaribou\\ncarbonic\\ncartilage\\ncarbon\\ncarriage\\ncarton\\ncar\\ncarbonate\\n```\\n\\n**Sample Output**\\n\\n```c++\\ncarbohydrate carboh\\ncart cart\\ncarburetor carbu\\ncaramel cara\\ncaribou cari\\ncarbonic carboni\\ncartilage carti\\ncarbon carbon\\ncarriage carr\\ncarton carto\\ncar car\\ncarbonate carbona\\n```\\n\\n**解题**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstring ss[1005];\\nchar str[25];\\n\\nint main() {\\n\\tint len = 0;\\n\\tint i, j, k;\\n\\twhile (cin>>ss[len]) {\\n\\t\\tlen++;\\n\\t}\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint size = ss[i].length();\\n        // 遍历当前字符串的每个字符\\n\\t\\tfor (j = 0; j < size; j++) {\\n\\t\\t\\tmemset(str, 0, sizeof str); \\n            // 前缀\\n\\t\\t\\tfor (k = 0; k <= j; k++) {\\n\\t\\t\\t\\tstr[k] = ss[i][k];\\n\\t\\t\\t}\\n\\t\\t\\tstr[k] = \'\\\\0\';\\n            // 与其他字符串挨个比较\\n\\t\\t\\tfor (k = 0; k < len; k++) {\\n\\t\\t\\t\\tif (k != i) {\\n\\t\\t\\t\\t\\t// strstr(a, b):返回b在a中的起始位置，a是b的字串\\n\\t\\t\\t\\t\\t//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \\n\\t\\t\\t\\t\\tif (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (k == len) {\\n\\t\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i].substr(0, j + 1)<<endl;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (j == size) {\\n\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\\n\\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\\n\\n**Input**\\n\\n第一行t, 表示有t组数据；\\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\\n\\n**Output**\\n\\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n9128456 2\\n1444 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\n12456\\n1\\n```\\n\\n**解题思路**\\n\\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\\n\\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\\n\\n```c++\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n\\tint t, k;\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tstring str; \\n\\t\\tcin>>str>>k;\\n\\t\\tint len = str.size();\\n\\t\\twhile (k--) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\t// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\\n\\t\\t\\t\\tif (str[i] > str[i + 1] || i == len - 1) {\\n\\t\\t\\t\\t\\tstr.erase(i, 1);\\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\n\\t\\t}\\n        // 处理一下高位为0的情况\\n\\t\\tint j = 0;\\n\\t\\tint newLen = str.size();\\n\\t\\twhile(j < newLen && str[j] == \'0\') {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == newLen) {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<str.substr(j, newLen)<<endl; \\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\\n\\n**Problem Description**\\n\\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\\n\\n**Input**\\n\\n多组数据。对于每组数据：\\n第一行为正整数n，表示菜的数量。n<=1000。\\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\\nn=0表示数据结束。\\n\\n**Output**\\n\\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\\n\\n**Sample Input**\\n\\n```c++\\n1\\n50\\n5\\n10\\n1 2 3 2 1 1 2 3 2 1\\n50\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n-45\\n32\\n```\\n\\n**解题思路**\\n\\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n, m;\\nint v[1005];\\nint dp[1005]; \\n\\nint main() {\\n\\twhile (cin>>n && n) {\\n\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>v[i];\\n\\t\\t}\\n\\t\\t// 升序排列 \\n\\t\\tsort(v, v + n);\\n\\t\\tcin>>m;\\n\\t\\t// 余额小于5直接输出 \\n\\t\\tif (m < 5) {\\n\\t\\t\\tcout<<m<<endl;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// 0/1背包，减5后的余额买最多的菜\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = m - 5; j >= v[i]; j--) {\\n\\t\\t\\t\\tdp[j] = max(dp[j], dp[j - v[i]] + v[i]);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tcout<<m-dp[m-5]-v[n-1]<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [Task（HDU-4864）](http://acm.hdu.edu.cn/showproblem.php?pid=4864)\\n\\n**Problem Description**\\n\\nToday the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500*xi+2*yi) dollars.\\nThe company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.\\n\\n**Input**\\n\\nThe input contains several test cases.\\nThe first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 < =N <= 100000,1<=M<=100000).\\nThe following N lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the maximum time the machine can work.yi is the level of the machine.\\nThe following M lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the time we need to complete the task.yi is the level of the task.\\n\\n**Output**\\n\\nFor each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.\\n\\n**Sample Input**\\n\\n```c++\\n1 2\\n100 3\\n100 2\\n100 1\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 50004\\n```\\n\\n**题目大意**：有Ｎ个机器，机器有最大执行时间和等级；有Ｍ个任务，每个任务有执行时间和等级，只有当机器的执行时间和等级均大于等于任务的执行时间和等级时，该台机器才能执行该任务，每执行一个任务能获得500*xi+2*yi的酬劳（xi是任务时长，yi是任务等级），每台机器每天只能使用一次，问一天最多能获得多大的酬劳。(机器的数据范围：0<xi<1440，0=<yi<=100)，(任务的数据范围：0<xi<1440，0=<yi<=100)。\\n\\n**解题思路**：根据酬劳的计算公式和xi、yi的范围可知，对酬劳大小其决定作用的是执行时长xi，所以对所有机器和任务按执行时长进行降序排列，若时长相等，按等级降序排列。贪心暴力。核心点：**后面的任务必然能够被先前加进来的机器执行完毕，因为任务是按时间降序排列的**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn]; // 机器\\nP w[maxn]; // 任务\\nint level[105]; // 满足任务时长的对应等级的机器数\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(level, 0, sizeof(level));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\t// 后面的加进来的任务必然能够被先前加进来的机所完毕，因为任务是按时间降序排列的\\n\\t\\tfor (int i = 0, j = 0; i < M; i++) {\\n\\t\\t\\twhile (j < N && m[j].x >= w[i].x) {\\n\\t\\t\\t\\tlevel[m[j].y]++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k = w[i].y; k <= 100; k++) {\\n\\t\\t\\t\\tif (level[k]) {\\n\\t\\t\\t\\t\\tlevel[k]--;\\n\\t\\t\\t\\t\\tsum += w[i].x * 500 + w[i].y * 2;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n\\n---------------------------------------------------------------------------\\n// 这种写法会超时\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn];\\nP w[maxn];\\nint vis[maxn];\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tfor (int j = N - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (vis[j]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (m[j].x >= w[i].x && m[j].y >= w[i].y) {\\n\\t\\t\\t\\t\\tvis[j] = 1;\\n\\t\\t\\t\\t\\tsum += 500 * w[i].x + 2 * w[i].y;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## [Intervals POJ-1089](http://poj.org/problem?id=1089)\\n\\n**Description**\\n\\nThere is given the series of n closed intervals [ai; bi], where i=1,2,...,n. The sum of those intervals may be represented as a sum of closed pairwise non−intersecting intervals. The task is to find such representation with the minimal number of intervals. The intervals of this representation should be written in the output file in acceding order. We say that the intervals [a; b] and [c; d] are in ascending order if, and only if a <= b < c <= d.\\nTask\\nWrite a program which:\\nreads from the std input the description of the series of intervals,\\ncomputes pairwise non−intersecting intervals satisfying the conditions given above,\\nwrites the computed intervals in ascending order into std output\\n\\n**Input**\\n\\nIn the first line of input there is one integer n, 3 <= n <= 50000. This is the number of intervals. In the (i+1)−st line, 1 <= i <= n, there is a description of the interval [ai; bi] in the form of two integers ai and bi separated by a single space, which are respectively the beginning and the end of the interval,1 <= ai <= bi <= 1000000.\\n\\n**Output**\\n\\nThe output should contain descriptions of all computed pairwise non−intersecting intervals. In each line should be written a description of one interval. It should be composed of two integers, separated by a single space, the beginning and the end of the interval respectively. The intervals should be written into the output in ascending order.\\n\\n**Sample Input**\\n\\n```c++\\n5\\n5 6\\n1 4\\n10 10\\n6 9\\n8 10\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 4\\n5 10\\n```\\n\\n**题目大意**：输入n个区间，求出最大的区间覆盖\\n\\n**解题思路**：对所有区间按左端点升序排列，遍历所有区间， 如果当前区间的左端点大于上一区间的右端点，则形成新的区间，否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 50005;\\n\\nstruct Node {\\n\\tint x;\\n\\tint y;\\n} p[maxn], r[maxn]; \\n\\n// 按左端点大小升序排列 \\nint cmp(Node a, Node b) {\\n\\treturn a.x < b.x;\\n}\\n\\nint n;\\nint main() {\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].x>>p[i].y;\\n\\t\\t}\\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint cnt = 0;\\n\\t\\tr[0].x = p[0].x;\\n\\t\\tr[0].y = p[0].y; \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前区间的左端点大于上一区间的右端点，则形成新的区间 \\n\\t\\t\\tif (p[i].x > r[cnt].y) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tr[cnt].x = p[i].x;\\n\\t\\t\\t\\tr[cnt].y = p[i].y;\\n             // 否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \\n\\t\\t\\t} else if (p[i].y > r[cnt].y ) { \\n\\t\\t\\t\\tr[cnt].y = p[i].y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= cnt; i++) {\\n\\t\\t\\tcout<<r[i].x<<\\\" \\\"<<r[i].y<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg\",\"articleTitle\":\"贪心算法刷题记录\",\"categoryId\":15,\"id\":47,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:31:50');
INSERT INTO `tb_operation_log` VALUES (109, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Supermarket（POJ-1456）](http://poj.org/problem?id=1456)\\n\\n**Description**\\n\\n超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.\\n每天只能卖一个商品.\\n现在你要让超市获得最大的利润.\\n\\n**Input**\\n\\n多组数据.\\n每组数据第一行为一个整数N (0 <= N <= 10000), 即超市的商品数目\\n之后N行各有两个整数, 第i行为 pi, di (1 <= pi, di <= 10000)\\n\\n**Output**\\n\\n对于每一组数据, 输出当前条件下超市的最大利润\\n\\n**Sample Input**\\n\\n4\\n50 2\\n10 1\\n20 2\\n30 1\\n\\n7\\n20 1\\n2 1\\n10 3\\n100 2\\n8 2\\n5 20\\n50 10\\n\\n**Sample Output**\\n\\n80\\n185\\n\\n**解题思路**\\n\\n对所有物品进行排序，按利润从大到小，从高利润开始卖商品，如果当天已经卖过商品，往前找没有卖过商品的天。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cstring>\\n\\nusing namespace std;\\n\\ntypedef struct Node {\\n\\tint p;\\n\\tint d;\\n} Product;\\n\\nbool cmp(Product p1, Product p2) {\\n\\treturn p1.p > p2.p;\\n}\\n\\nProduct pro[10001];\\nint visit[10001]; //标记某天是否卖过商品\\n\\nint main() {\\n\\tint n, sum;\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tcin>>pro[i].p>>pro[i].d;\\n\\t\\t// 按利润从高到低排序\\n\\t\\tsort(pro + 1, pro + n + 1, cmp);\\n\\t\\tsum = 0;\\n\\t\\tmemset(visit, 0, sizeof(visit));\\n         // 先售卖高利润的商品\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (visit[pro[i].d] == 0) {\\n\\t\\t\\t\\tvisit[pro[i].d] = 1;\\n\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t} else {\\n                 // 如果当天卖过商品，则往前找没有卖过商品的那一天\\n\\t\\t\\t\\tfor (int j = pro[i].d - 1; j >= 1; j--) {\\n\\t\\t\\t\\t\\tif (visit[j] == 0) {\\n\\t\\t\\t\\t\\t\\tvisit[j] = 1;\\n\\t\\t\\t\\t\\t\\tsum += pro[i].p;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<sum<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n## [Doing Homework again（HDU-1789）](http://acm.hdu.edu.cn/showproblem.php?pid=1789)\\n\\n**Problem Description**\\n\\nIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.\\n\\n**Input**\\n\\nThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.\\nEach test case start with a positive integer N(1<=N<=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.\\n\\n**Output**\\n\\nFor each test case, you should output the smallest total reduced score, one line per test case.\\n\\n**Sample Input**\\n\\n```c++\\n3\\n3\\n3 3 3\\n10 5 1\\n3\\n1 3 1\\n6 2 3\\n7\\n1 4 6 4 2 4 3\\n3 2 1 7 6 5 4\\n```\\n\\n**Sample Output**\\n\\n```c++\\n0\\n3\\n5\\n```\\n\\n**解题思路**\\n\\n对所有作业按分数的降序排列，从分数高的作业开始做。若当天没做过作业，则做该作业；若当天已经做过其他作业，则往前找到没有做过作业的那一天，找到的话，标记改天做过作业，没找到，则扣分。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint deadline;\\n\\tint score;\\n} work[1005];\\n\\nint T, N;\\nint day[1005]; // 标记当天有没有做过作业 \\n\\nint cmp(Node a, Node b) {\\n\\treturn a.score > b.score; \\n}\\n\\nint main() {\\n\\tcin>>T;\\n\\tfor (int i = 0; i < T; i++) {\\n\\t\\tint res = 0;\\n\\t\\tmemset(day, 0, sizeof(day));\\n\\t\\tcin>>N;\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].deadline;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tcin>>work[j].score;\\n\\t\\t}\\n\\t\\t// 按分数降序排列 \\n\\t\\tsort(work, work + N, cmp);\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tint d = work[j].deadline;\\n\\t\\t\\t// 若当天没做作业 \\n\\t\\t\\tif (!day[d]) {\\n\\t\\t\\t\\t// 标记做过 \\n\\t\\t\\t\\tday[d] = 1;\\n\\t\\t\\t} else { // 当天做过作业 \\n\\t\\t\\t\\tint flag = 0; // 标记有没有找到 \\n\\t\\t\\t\\t// 往前找到没有做过作业的那天 \\n\\t\\t\\t\\tfor (int k = d - 1; k >= 1; k--) {\\n\\t\\t\\t\\t\\tif (!day[k]) { \\n\\t\\t\\t\\t\\t\\tday[k] = 1;\\n\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t// 没找到，则扣分 \\n\\t\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\t\\tres += work[j].score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [今年暑假不AC（HDU-2037）](http://acm.hdu.edu.cn/showproblem.php?pid=2037)\\n\\n**Problem Description**\\n\\n“今年暑假不AC？”\\n“是的。”\\n“那你干什么呢？”\\n“看世界杯呀，笨蛋！”\\n“@#$%^&*%...”\\n确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。\\n作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）\\n\\n**Input**\\n\\n输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。\\n\\n**Output**\\n\\n对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。\\n\\n**Sample Input**\\n\\n```c++\\n12\\n1 3\\n3 4\\n0 7\\n3 8\\n15 19\\n15 20\\n10 15\\n8 18\\n6 12\\n5 10\\n4 14\\n2 9\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n5\\n```\\n\\n**解题思路**\\n\\n对所有的节目按结束时间升序排列，依次遍历，如果当前节目的开始时间大于等于上个观看节目的结束时间，则该节目可以观看，记录数+1，具体细节见注释。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Node {\\n\\tint tis;\\n\\tint tie;\\n} p[105];\\n \\nint cmp(Node a, Node b) {\\n\\treturn a.tie < b.tie;\\n}\\n\\nint main() {\\n\\tint n;\\n\\twhile (cin>>n && n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].tis>>p[i].tie;\\n\\t\\t}\\n\\t\\t// 按结束时间升序列 \\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint res = 1;\\n\\t\\tint pTie = p[0].tie; // 记录上个节目结束的时间 \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前节目的开始时间大于等于上个节目的结束时间，则该比赛可以观看 \\n\\t\\t\\tif (p[i].tis >= pTie) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tpTie = p[i].tie; // 更新 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<res<<endl;\\n\\t}\\n\\treturn  0;\\n}\\n```\\n\\n## [最短前缀 openjudge-2797](http://bailian.openjudge.cn/practice/2797)\\n\\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \\\"carbon\\\"的字串是: \\\"c\\\", \\\"ca\\\", \\\"car\\\", \\\"carb\\\", \\\"carbo\\\", 和 \\\"carbon\\\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \\\"carbohydrate\\\" 通常用\\\"carb\\\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\\n在下面的例子中，\\\"carbohydrate\\\" 能被缩略成\\\"carboh\\\", 但是不能被缩略成\\\"carbo\\\" (或其余更短的前缀) 因为已经有一个单词用\\\"carbo\\\"开始\\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\\\"car\\\"精确匹配单词\\\"car\\\". 因此 \\\"car\\\" 是 \\\"car\\\"的缩略语是没有二义性的 , “car”不会被当成\\\"carriage\\\"或者任何在列表中以\\\"car\\\"开始的单词.\\n\\n**Input**\\n\\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\\n\\n**Output**\\n\\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\\n\\n**Sample Input**\\n\\n```c++\\ncarbohydrate\\ncart\\ncarburetor\\ncaramel\\ncaribou\\ncarbonic\\ncartilage\\ncarbon\\ncarriage\\ncarton\\ncar\\ncarbonate\\n```\\n\\n**Sample Output**\\n\\n```c++\\ncarbohydrate carboh\\ncart cart\\ncarburetor carbu\\ncaramel cara\\ncaribou cari\\ncarbonic carboni\\ncartilage carti\\ncarbon carbon\\ncarriage carr\\ncarton carto\\ncar car\\ncarbonate carbona\\n```\\n\\n**解题**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nstring ss[1005];\\nchar str[25];\\n\\nint main() {\\n\\tint len = 0;\\n\\tint i, j, k;\\n\\twhile (cin>>ss[len]) {\\n\\t\\tlen++;\\n\\t}\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint size = ss[i].length();\\n        // 遍历当前字符串的每个字符\\n\\t\\tfor (j = 0; j < size; j++) {\\n\\t\\t\\tmemset(str, 0, sizeof str); \\n            // 前缀\\n\\t\\t\\tfor (k = 0; k <= j; k++) {\\n\\t\\t\\t\\tstr[k] = ss[i][k];\\n\\t\\t\\t}\\n\\t\\t\\tstr[k] = \'\\\\0\';\\n            // 与其他字符串挨个比较\\n\\t\\t\\tfor (k = 0; k < len; k++) {\\n\\t\\t\\t\\tif (k != i) {\\n\\t\\t\\t\\t\\t// strstr(a, b):返回b在a中的起始位置，a是b的字串\\n\\t\\t\\t\\t\\t//  b在a中的起始位置 与 a 的起始位置相同，则b是a的前缀字串 \\n\\t\\t\\t\\t\\tif (strstr(ss[k].c_str(), str) == ss[k].c_str()) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (k == len) {\\n\\t\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i].substr(0, j + 1)<<endl;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (j == size) {\\n\\t\\t\\tcout<<ss[i]<<\\\" \\\"<<ss[i]<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [最小新整数](http://bailian.openjudge.cn/practice/4137)\\n\\n给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。\\n现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？\\n例如: n = 9128456, k = 2, 则生成的新整数最小为12456\\n\\n**Input**\\n\\n第一行t, 表示有t组数据；\\n接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\\n\\n**Output**\\n\\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\\n\\n**Sample Input**\\n\\n```c++\\n2\\n9128456 2\\n1444 3\\n```\\n\\n**Sample Output**\\n\\n```c++\\n12456\\n1\\n```\\n\\n**解题思路**\\n\\n错误思路：删除最大的 k 个数，如1243865 ，删8是124365，删4是123865，显然删4结果更小。\\n\\n正确思路：删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)，最后再处理一下高位为0的情况。\\n\\n```c++\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n\\tint t, k;\\n\\tcin>>t;\\n\\twhile(t--) {\\n\\t\\tstring str; \\n\\t\\tcin>>str>>k;\\n\\t\\tint len = str.size();\\n\\t\\twhile (k--) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\t// 删除遇到的第一个递减序列的第一个数字(若整个字符串为非递减序列，则删去末尾的数字)\\n\\t\\t\\t\\tif (str[i] > str[i + 1] || i == len - 1) {\\n\\t\\t\\t\\t\\tstr.erase(i, 1);\\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\n\\t\\t}\\n        // 处理一下高位为0的情况\\n\\t\\tint j = 0;\\n\\t\\tint newLen = str.size();\\n\\t\\twhile(j < newLen && str[j] == \'0\') {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == newLen) {\\n\\t\\t\\tcout<<0<<endl;\\n\\t\\t} else {\\n\\t\\t\\tcout<<str.substr(j, newLen)<<endl; \\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## [饭卡（HDU-2546）](http://acm.hdu.edu.cn/showproblem.php?pid=2546)\\n\\n**Problem Description**\\n\\n电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。\\n某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。\\n\\n**Input**\\n\\n多组数据。对于每组数据：\\n第一行为正整数n，表示菜的数量。n<=1000。\\n第二行包括n个正整数，表示每种菜的价格。价格不超过50。\\n第三行包括一个正整数m，表示卡上的余额。m<=1000。\\nn=0表示数据结束。\\n\\n**Output**\\n\\n对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。\\n\\n**Sample Input**\\n\\n```c++\\n1\\n50\\n5\\n10\\n1 2 3 2 1 1 2 3 2 1\\n50\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n-45\\n32\\n```\\n\\n**解题思路**\\n\\n用sort排序将饭菜价格从小到大排序，将最贵的饭菜挑出，用c-5尽可能买多的饭菜，\\n最后用剩余接近5的余额，买最贵的菜，将买的饭钱加一块，用m减去花的钱就是结果，0/1背包。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint n, m;\\nint v[1005];\\nint dp[1005]; \\n\\nint main() {\\n\\twhile (cin>>n && n) {\\n\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>v[i];\\n\\t\\t}\\n\\t\\t// 升序排列 \\n\\t\\tsort(v, v + n);\\n\\t\\tcin>>m;\\n\\t\\t// 余额小于5直接输出 \\n\\t\\tif (m < 5) {\\n\\t\\t\\tcout<<m<<endl;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// 0/1背包，减5后的余额买最多的菜\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = m - 5; j >= v[i]; j--) {\\n\\t\\t\\t\\tdp[j] = max(dp[j], dp[j - v[i]] + v[i]);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tcout<<m-dp[m-5]-v[n-1]<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [Task（HDU-4864）](http://acm.hdu.edu.cn/showproblem.php?pid=4864)\\n\\n**Problem Description**\\n\\nToday the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500*xi+2*yi) dollars.\\nThe company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.\\n\\n**Input**\\n\\nThe input contains several test cases.\\nThe first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 < =N <= 100000,1<=M<=100000).\\nThe following N lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the maximum time the machine can work.yi is the level of the machine.\\nThe following M lines each contains two integers xi(0<xi<1440),yi(0=<yi<=100).xi is the time we need to complete the task.yi is the level of the task.\\n\\n**Output**\\n\\nFor each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.\\n\\n**Sample Input**\\n\\n```c++\\n1 2\\n100 3\\n100 2\\n100 1\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 50004\\n```\\n\\n**题目大意**：有Ｎ个机器，机器有最大执行时间和等级；有Ｍ个任务，每个任务有执行时间和等级，只有当机器的执行时间和等级均大于等于任务的执行时间和等级时，该台机器才能执行该任务，每执行一个任务能获得500*xi+2*yi的酬劳（xi是任务时长，yi是任务等级），每台机器每天只能使用一次，问一天最多能获得多大的酬劳。(机器的数据范围：0<xi<1440，0=<yi<=100)，(任务的数据范围：0<xi<1440，0=<yi<=100)。\\n\\n**解题思路**：根据酬劳的计算公式和xi、yi的范围可知，对酬劳大小其决定作用的是执行时长xi，所以对所有机器和任务按执行时长进行降序排列，若时长相等，按等级降序排列。贪心暴力。核心点：**后面的任务必然能够被先前加进来的机器执行完毕，因为任务是按时间降序排列的**\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn]; // 机器\\nP w[maxn]; // 任务\\nint level[105]; // 满足任务时长的对应等级的机器数\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(level, 0, sizeof(level));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\t// 后面的加进来的任务必然能够被先前加进来的机所完毕，因为任务是按时间降序排列的\\n\\t\\tfor (int i = 0, j = 0; i < M; i++) {\\n\\t\\t\\twhile (j < N && m[j].x >= w[i].x) {\\n\\t\\t\\t\\tlevel[m[j].y]++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k = w[i].y; k <= 100; k++) {\\n\\t\\t\\t\\tif (level[k]) {\\n\\t\\t\\t\\t\\tlevel[k]--;\\n\\t\\t\\t\\t\\tsum += w[i].x * 500 + w[i].y * 2;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n\\n---------------------------------------------------------------------------\\n// 这种写法会超时\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\ntypedef struct Node {\\n\\tint x;\\n\\tint y;\\n} P;\\n\\nint cmp(P p1, P p2) {\\n\\tif (p1.x == p2.x) {\\n\\t\\treturn p1.y > p2.y;\\n\\t}\\n\\treturn p1.x > p2.x;\\n}\\n\\nP m[maxn];\\nP w[maxn];\\nint vis[maxn];\\nint N, M;\\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &N, &M)) {\\n\\t\\tmemset(vis, 0, sizeof(vis));\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &m[i].x, &m[i].y);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tscanf(\\\"%d%d\\\", &w[i].x, &w[i].y);\\n\\t\\t}\\n\\t\\tsort(m, m + N, cmp);\\n\\t\\tsort(w, w + M, cmp);\\n\\t\\tlong long sum = 0; \\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < M; i++) {\\n\\t\\t\\tfor (int j = N - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (vis[j]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (m[j].x >= w[i].x && m[j].y >= w[i].y) {\\n\\t\\t\\t\\t\\tvis[j] = 1;\\n\\t\\t\\t\\t\\tsum += 500 * w[i].x + 2 * w[i].y;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprintf(\\\"%d %lld\\\\n\\\", count, sum);\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## [Intervals POJ-1089](http://poj.org/problem?id=1089)\\n\\n**Description**\\n\\nThere is given the series of n closed intervals [ai; bi], where i=1,2,...,n. The sum of those intervals may be represented as a sum of closed pairwise non−intersecting intervals. The task is to find such representation with the minimal number of intervals. The intervals of this representation should be written in the output file in acceding order. We say that the intervals [a; b] and [c; d] are in ascending order if, and only if a <= b < c <= d.\\nTask\\nWrite a program which:\\nreads from the std input the description of the series of intervals,\\ncomputes pairwise non−intersecting intervals satisfying the conditions given above,\\nwrites the computed intervals in ascending order into std output\\n\\n**Input**\\n\\nIn the first line of input there is one integer n, 3 <= n <= 50000. This is the number of intervals. In the (i+1)−st line, 1 <= i <= n, there is a description of the interval [ai; bi] in the form of two integers ai and bi separated by a single space, which are respectively the beginning and the end of the interval,1 <= ai <= bi <= 1000000.\\n\\n**Output**\\n\\nThe output should contain descriptions of all computed pairwise non−intersecting intervals. In each line should be written a description of one interval. It should be composed of two integers, separated by a single space, the beginning and the end of the interval respectively. The intervals should be written into the output in ascending order.\\n\\n**Sample Input**\\n\\n```c++\\n5\\n5 6\\n1 4\\n10 10\\n6 9\\n8 10\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1 4\\n5 10\\n```\\n\\n**题目大意**：输入n个区间，求出最大的区间覆盖\\n\\n**解题思路**：对所有区间按左端点升序排列，遍历所有区间， 如果当前区间的左端点大于上一区间的右端点，则形成新的区间，否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nconst int maxn = 50005;\\n\\nstruct Node {\\n\\tint x;\\n\\tint y;\\n} p[maxn], r[maxn]; \\n\\n// 按左端点大小升序排列 \\nint cmp(Node a, Node b) {\\n\\treturn a.x < b.x;\\n}\\n\\nint n;\\nint main() {\\n\\twhile (cin>>n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcin>>p[i].x>>p[i].y;\\n\\t\\t}\\n\\t\\tsort(p, p + n, cmp);\\n\\t\\tint cnt = 0;\\n\\t\\tr[0].x = p[0].x;\\n\\t\\tr[0].y = p[0].y; \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t// 如果当前区间的左端点大于上一区间的右端点，则形成新的区间 \\n\\t\\t\\tif (p[i].x > r[cnt].y) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tr[cnt].x = p[i].x;\\n\\t\\t\\t\\tr[cnt].y = p[i].y;\\n             // 否则，若当前区间的右端点大于上一区间的右端点，则更新右端点 \\n\\t\\t\\t} else if (p[i].y > r[cnt].y ) { \\n\\t\\t\\t\\tr[cnt].y = p[i].y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= cnt; i++) {\\n\\t\\t\\tcout<<r[i].x<<\\\" \\\"<<r[i].y<<endl;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1620463695190.jpg\",\"articleTitle\":\"贪心算法刷题记录\",\"categoryId\":15,\"id\":47,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:31:58');
INSERT INTO `tb_operation_log` VALUES (110, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n这里队列的判满方法，采用的是少用一个元素空间的方法，即 (**rear + 1) % MaxSize == front** 时，队列满。\\n\\n**代码**\\n\\n```c++\\n#include<stdio.h>\\n#include<malloc.h>\\n\\n#define MaxSize 100  // 队列的最大长度为 100-1=99\\n\\ntypedef struct {\\n    int data[MaxSize];\\n    int front; // 头指针指向队首元素 \\n\\tint rear; // 尾指针指向队尾元素的下一个元素 \\n} SeqQueue, *PSeqQueue;\\n\\n// 初始化队列 \\nPSeqQueue Init_SeqQueue() {\\n    PSeqQueue Q;\\n\\n    Q = (PSeqQueue)malloc(sizeof(SeqQueue));\\n    if (!Q) {\\n        return NULL;\\n    }\\n    // 将队头和队尾指针置为0 \\n    Q->front = 0;\\n    Q->rear = 0;\\n    return Q;\\n}\\n\\n// 返回队列的实际长度 = (rear - front + maxSize) % maxSize \\nint Length_SeqQueue(PSeqQueue Q) {\\n    return ((Q->rear - Q->front + MaxSize) % MaxSize);\\n}\\n\\n// 判断队列是否为空，队首和队尾指针相等时为空 \\nint Empty_SeqQueue(PSeqQueue Q) {\\n    return Q->front == Q->rear;\\n}\\n\\n// 入队操作，参数x为入队元素 \\nvoid In_SeqQueue(PSeqQueue Q, int x) {\\n\\t// 判断队列是否已满，这里通过少用一个元素空间来判断队列是否已满 \\n    if ((Q->rear + 1) % MaxSize == Q->front) {\\n        printf(\\\"Queue is full!\\\\n\\\");\\n        return;\\n    }\\n    Q->data[Q->rear] = x; // 对应元素入队 \\n    Q->rear = (Q->rear + 1) % MaxSize; // 队尾指针后移  \\n}\\n\\n// 出队操作，参数e用来存储出队的元素 \\nvoid Out_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) { // 判断队列是否为空 \\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return;\\n    }\\n    *e = Q->data[Q->front]; // 出队元素的赋值 \\n    Q->front = (Q->front + 1) % MaxSize; // 队首元素后移 \\n}\\n\\n// 获取队首元素，存放在参数e中 \\nint Front_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = Q->data[Q->front];\\n    return 1;\\n}\\n\\n// 遍历打印队列中的元素 \\nvoid Print_SeqQueue(PSeqQueue Q) {\\n    int i;\\n\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        i = Q->front;\\n        while (i != Q->rear) {\\n            printf(\\\"%d \\\", Q->data[i]);\\n            i = (i + 1) % MaxSize;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    PSeqQueue Q;\\n    int e, n, i;\\n\\n    printf(\\\"input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    Q = Init_SeqQueue();\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        In_SeqQueue(Q, e);\\n    }\\n    printf(\\\"The Queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n    Out_SeqQueue(Q, &e);\\n    printf(\\\"The out data is %d.\\\\n\\\", e);\\n\\n    Front_SeqQueue(Q, &e);\\n    printf(\\\"The front data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"Now , the queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of the new Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082021454422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\"\",\"articleTitle\":\"循环队列的C语言实现\",\"categoryId\":15,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:34:34');
INSERT INTO `tb_operation_log` VALUES (111, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n这里队列的判满方法，采用的是少用一个元素空间的方法，即 (**rear + 1) % MaxSize == front** 时，队列满。\\n\\n**代码**\\n\\n```c++\\n#include<stdio.h>\\n#include<malloc.h>\\n\\n#define MaxSize 100  // 队列的最大长度为 100-1=99\\n\\ntypedef struct {\\n    int data[MaxSize];\\n    int front; // 头指针指向队首元素 \\n\\tint rear; // 尾指针指向队尾元素的下一个元素 \\n} SeqQueue, *PSeqQueue;\\n\\n// 初始化队列 \\nPSeqQueue Init_SeqQueue() {\\n    PSeqQueue Q;\\n\\n    Q = (PSeqQueue)malloc(sizeof(SeqQueue));\\n    if (!Q) {\\n        return NULL;\\n    }\\n    // 将队头和队尾指针置为0 \\n    Q->front = 0;\\n    Q->rear = 0;\\n    return Q;\\n}\\n\\n// 返回队列的实际长度 = (rear - front + maxSize) % maxSize \\nint Length_SeqQueue(PSeqQueue Q) {\\n    return ((Q->rear - Q->front + MaxSize) % MaxSize);\\n}\\n\\n// 判断队列是否为空，队首和队尾指针相等时为空 \\nint Empty_SeqQueue(PSeqQueue Q) {\\n    return Q->front == Q->rear;\\n}\\n\\n// 入队操作，参数x为入队元素 \\nvoid In_SeqQueue(PSeqQueue Q, int x) {\\n\\t// 判断队列是否已满，这里通过少用一个元素空间来判断队列是否已满 \\n    if ((Q->rear + 1) % MaxSize == Q->front) {\\n        printf(\\\"Queue is full!\\\\n\\\");\\n        return;\\n    }\\n    Q->data[Q->rear] = x; // 对应元素入队 \\n    Q->rear = (Q->rear + 1) % MaxSize; // 队尾指针后移  \\n}\\n\\n// 出队操作，参数e用来存储出队的元素 \\nvoid Out_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) { // 判断队列是否为空 \\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return;\\n    }\\n    *e = Q->data[Q->front]; // 出队元素的赋值 \\n    Q->front = (Q->front + 1) % MaxSize; // 队首元素后移 \\n}\\n\\n// 获取队首元素，存放在参数e中 \\nint Front_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = Q->data[Q->front];\\n    return 1;\\n}\\n\\n// 遍历打印队列中的元素 \\nvoid Print_SeqQueue(PSeqQueue Q) {\\n    int i;\\n\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        i = Q->front;\\n        while (i != Q->rear) {\\n            printf(\\\"%d \\\", Q->data[i]);\\n            i = (i + 1) % MaxSize;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    PSeqQueue Q;\\n    int e, n, i;\\n\\n    printf(\\\"input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    Q = Init_SeqQueue();\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        In_SeqQueue(Q, e);\\n    }\\n    printf(\\\"The Queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n    Out_SeqQueue(Q, &e);\\n    printf(\\\"The out data is %d.\\\\n\\\", e);\\n\\n    Front_SeqQueue(Q, &e);\\n    printf(\\\"The front data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"Now , the queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of the new Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082021454422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\"\",\"articleTitle\":\"循环队列的C语言实现\",\"categoryId\":15,\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:37:18');
INSERT INTO `tb_operation_log` VALUES (112, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"循环队列\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:37:35');
INSERT INTO `tb_operation_log` VALUES (113, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"队列\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:37:42');
INSERT INTO `tb_operation_log` VALUES (114, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"链队\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:38:03');
INSERT INTO `tb_operation_log` VALUES (115, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[60],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:38:18');
INSERT INTO `tb_operation_log` VALUES (116, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n这里队列的判满方法，采用的是少用一个元素空间的方法，即 (**rear + 1) % MaxSize == front** 时，队列满。\\n\\n**代码**\\n\\n```c++\\n#include<stdio.h>\\n#include<malloc.h>\\n\\n#define MaxSize 100  // 队列的最大长度为 100-1=99\\n\\ntypedef struct {\\n    int data[MaxSize];\\n    int front; // 头指针指向队首元素 \\n\\tint rear; // 尾指针指向队尾元素的下一个元素 \\n} SeqQueue, *PSeqQueue;\\n\\n// 初始化队列 \\nPSeqQueue Init_SeqQueue() {\\n    PSeqQueue Q;\\n\\n    Q = (PSeqQueue)malloc(sizeof(SeqQueue));\\n    if (!Q) {\\n        return NULL;\\n    }\\n    // 将队头和队尾指针置为0 \\n    Q->front = 0;\\n    Q->rear = 0;\\n    return Q;\\n}\\n\\n// 返回队列的实际长度 = (rear - front + maxSize) % maxSize \\nint Length_SeqQueue(PSeqQueue Q) {\\n    return ((Q->rear - Q->front + MaxSize) % MaxSize);\\n}\\n\\n// 判断队列是否为空，队首和队尾指针相等时为空 \\nint Empty_SeqQueue(PSeqQueue Q) {\\n    return Q->front == Q->rear;\\n}\\n\\n// 入队操作，参数x为入队元素 \\nvoid In_SeqQueue(PSeqQueue Q, int x) {\\n\\t// 判断队列是否已满，这里通过少用一个元素空间来判断队列是否已满 \\n    if ((Q->rear + 1) % MaxSize == Q->front) {\\n        printf(\\\"Queue is full!\\\\n\\\");\\n        return;\\n    }\\n    Q->data[Q->rear] = x; // 对应元素入队 \\n    Q->rear = (Q->rear + 1) % MaxSize; // 队尾指针后移  \\n}\\n\\n// 出队操作，参数e用来存储出队的元素 \\nvoid Out_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) { // 判断队列是否为空 \\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return;\\n    }\\n    *e = Q->data[Q->front]; // 出队元素的赋值 \\n    Q->front = (Q->front + 1) % MaxSize; // 队首元素后移 \\n}\\n\\n// 获取队首元素，存放在参数e中 \\nint Front_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = Q->data[Q->front];\\n    return 1;\\n}\\n\\n// 遍历打印队列中的元素 \\nvoid Print_SeqQueue(PSeqQueue Q) {\\n    int i;\\n\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        i = Q->front;\\n        while (i != Q->rear) {\\n            printf(\\\"%d \\\", Q->data[i]);\\n            i = (i + 1) % MaxSize;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    PSeqQueue Q;\\n    int e, n, i;\\n\\n    printf(\\\"input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    Q = Init_SeqQueue();\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        In_SeqQueue(Q, e);\\n    }\\n    printf(\\\"The Queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n    Out_SeqQueue(Q, &e);\\n    printf(\\\"The out data is %d.\\\\n\\\", e);\\n\\n    Front_SeqQueue(Q, &e);\\n    printf(\\\"The front data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"Now , the queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of the new Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082021454422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621521586845.jpg\",\"articleTitle\":\"循环队列的C语言实现\",\"categoryId\":15,\"id\":61,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[34]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:43:31');
INSERT INTO `tb_operation_log` VALUES (117, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### **用带头结点的单链表来实现队列**\\n\\n+ 队头指针始终指向头结点，队尾指针指向最后一个结点（队尾结点）。\\n+ 空链队的队头指针和队尾指针均指向头结点\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823165353245.png#pic_center)\\n\\n### 完整代码\\n\\n```c++\\n#include<stdio.h>\\n#include<malloc.h>\\n\\n/*\\n\\t用带头结点的单链表来实现队列 \\n*/\\ntypedef struct Node { // 结点结构 \\n    int data; // 数据域 \\n    struct Node *next; // 指向下一个结点的指针 \\n} QNode, *PQNode;\\n\\ntypedef struct {\\n    PQNode front, rear;  // 队头、队尾指针 \\n} LinkQueue, *PLinkQueue;\\n\\n// 初始化队列 \\nvoid Init_LinkQueue(PLinkQueue Q) {\\n    Q->front = Q->rear = (PQNode)malloc(sizeof(QNode)); // 开辟头结点，队头、队尾指针都指向头结点 \\n\\n    if (!Q->front) {\\n        return;\\n    }\\n    Q->front->next = NULL; // 头结点的next指针指向NULL \\n}\\n\\n// 进队操作，参数e是进队的元素 \\nvoid In_LinkQueue(PLinkQueue Q, int e) {\\n    PQNode p;\\n\\n    p = (PQNode)malloc(sizeof(QNode));\\t// 开辟新的结点 \\n    if (p == NULL) {\\n        return;\\n    } \\n    p->data = e; // 赋值元素 \\n    p->next = NULL; // 新结点指向NULL \\n    Q->rear->next = p; // 尾结点的next指针指向新结点 \\n    Q->rear = p; // 尾指针置为新节点 \\n}\\n\\n// 出队操作，参数e用来存放出队元素 \\nvoid Out_LinkQueue(PLinkQueue Q, int *e) {\\n    PQNode p;\\n    \\n    if (Q->front == Q->rear) { // 为空直接返回 \\n        return;\\n    }\\n    p = Q->front->next; // 获取队头结点，即头结点的下一个结点 \\n    *e = p->data; // 获取对应元素 \\n    Q->front->next = p->next; // 将队头结点置为队头的下一个结点，为删除队头结点做准备 \\n\\n    if (Q->rear == p) { // 如果队尾结点与要删除的队头结点相同\\n        Q->rear = Q->front; // 将队尾指针置为头结点 \\n    }\\n    free(p); // 释放队头结点 \\n}\\n\\n// 获取队头元素 \\nint GetFront_LinkQueue(PLinkQueue Q) {\\n    PQNode p;\\n\\n    if (Q->front == Q->rear) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        p = Q->front->next;\\n        return p->data;\\n    }\\n}\\n\\n// 获取队列的长度 \\nint Length_LinkQueue(PLinkQueue Q) {\\n    int count = 0;\\n    PQNode p;\\n\\n    p = Q->front->next;\\n    while (p != NULL) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n// 依次遍历打印队列中的元素 \\nvoid Print_LinkQueue(PLinkQueue Q) {\\n    PQNode p;\\n\\n    p = Q->front->next;\\n    if (p == NULL) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\n// 销毁队列 \\nvoid Destroy_LinkQueue(PLinkQueue Q) {\\n    while (Q->front) {\\n        Q->rear = Q->front->next;\\n        free(Q->front);\\n        Q->front = Q->rear;\\n    }\\n}\\n\\nint main() {\\n    LinkQueue q;\\n    PLinkQueue Q = &q;\\n    int n, e, i;\\n\\n    Init_LinkQueue(Q);\\n    printf(\\\"input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    printf(\\\"input Queue :\\\\n\\\");\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        In_LinkQueue(Q, e);\\n    }\\n    printf(\\\"The Queue is :\\\\n\\\");\\n    Print_LinkQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_LinkQueue(Q));\\n\\n    Out_LinkQueue(Q, &e);\\n    printf(\\\"The out data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"The front data is %d.\\\\n\\\", GetFront_LinkQueue(Q));\\n\\n    printf(\\\"Now , the new Queue is :\\\\n\\\");\\n    Print_LinkQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_LinkQueue(Q));\\n\\n    Destroy_LinkQueue(Q);\\n\\n    return 0;\\n} ![](QQ截图20200823165218.png)\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823165406449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621522019040.jpg\",\"articleTitle\":\"链队C语言实现\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[36]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:47:53');
INSERT INTO `tb_operation_log` VALUES (118, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"二叉树\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:49:08');
INSERT INTO `tb_operation_log` VALUES (119, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### 二叉树的四种遍历方式\\n\\n+ 先序遍历   根左右\\n+ 中序遍历   左根右\\n+ 后序遍历   左右根\\n+ 层次遍历   从第一层依次向下遍历每一层（使用队列实现）\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200827094951548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\\n\\n### 递归实现\\n\\n```c++\\n#include<iostream>\\n#include<queue>\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\ntypedef char ElemType;\\n\\n// 二叉树结点的结构 \\ntypedef struct BiTNode {\\n\\tElemType data; // 数据库 \\n\\tstruct BiTNode *lchild, *rchild; // 左右孩子的指针 \\n} BiTNode, *BiTree;\\n\\n// 先序创建二叉树\\nvoid CreateBiTree(BiTree *T) {\\n\\tElemType data;\\n\\t\\n\\tscanf(\\\"%c\\\", &data);\\n\\tif (data == \' \') {\\n\\t\\t*T = NULL;\\n\\t} else {\\n\\t\\t*T = (BiTree)malloc(sizeof(BiTNode));\\n\\t\\t(*T)->data = data;\\n\\t\\tCreateBiTree(&(*T)->lchild);\\n\\t\\tCreateBiTree(&(*T)->rchild);\\n\\t}\\n} \\n\\n// 输出二叉树结点\\nvoid visit(BiTree T) {\\n\\tif (T->data != \' \') {\\n\\t\\tprintf(\\\"%c\\\", T->data);\\n\\t}\\n} \\n\\n// 线序遍历二叉树\\nvoid PreOrderTraverse(BiTree T) {\\n\\tif (T) {\\n\\t\\tvisit(T);\\n\\t\\tPreOrderTraverse(T->lchild);\\n\\t\\tPreOrderTraverse(T->rchild);\\n\\t}\\n} \\n\\n// 中序遍历二叉树\\nvoid InOrderTraverse(BiTree T) {\\n\\tif (T) {\\n\\t\\tInOrderTraverse(T->lchild);\\n\\t\\tvisit(T);\\n\\t\\tInOrderTraverse(T->rchild);\\n\\t}\\n}\\n\\n// 后序遍历二叉树\\nvoid PostOrderTraverse(BiTree T) {\\n\\tif (T) {\\n\\t\\tPostOrderTraverse(T->lchild);\\n\\t\\tPostOrderTraverse(T->rchild);\\n\\t\\tvisit(T);\\n\\t}\\n} \\n\\n// 层次遍历，队列实现\\nvoid LevelOrderTraverse(BiTree T) {\\n\\tqueue<BiTNode*> q;\\n\\tBiTree p;\\n\\tq.push(T);\\n\\twhile (!q.empty()) {\\n\\t\\tp = q.front();\\n\\t\\tq.pop();\\n\\t\\tvisit(p);\\n\\t\\tif (p->lchild) {\\n\\t\\t\\tq.push(p->lchild);\\n\\t\\t}\\n\\t\\tif (p->rchild) {\\n\\t\\t\\tq.push(p->rchild);\\n\\t\\t}\\n\\t}\\n} \\n```\\n\\n### 非递归实现\\n[后序遍历方式3参考博客](http://blog.csdn.net/zhangxiangdavaid/article/details/37115355)\\n```c++\\n/* 非递归实现 */\\n// 先序遍历 \\nvoid PreOrderByStack(BiTree T) {\\n\\tstack<BiTree> s;\\n\\tBiTree p = T;\\n\\t\\n\\twhile (p || !s.empty()) { // 栈不为空或p不为空时循环 \\n\\t\\tif (p != NULL) {\\n\\t\\t\\ts.push(p); // 存入栈中 \\n\\t\\t\\tvisit(p); // 输出结点元素 \\n\\t\\t\\tp = p->lchild; // 遍历左子树 \\n\\t\\t} else {\\n\\t\\t\\tp = s.top(); // 栈顶结点 \\n\\t\\t\\ts.pop(); // 出栈 \\n\\t\\t\\tp = p->rchild; // 遍历右子树 \\n\\t\\t} \\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n// 中序遍历 \\nvoid InOrderByStack(BiTree T) {\\n\\tstack<BiTree> s;\\n\\tBiTree p = T;\\n\\t\\n\\twhile (p || !s.empty()) {\\n\\t\\tif (p != NULL) { \\n\\t\\t\\ts.push(p); // 入栈 \\n\\t\\t\\tp = p->lchild; // 遍历左子树 \\n\\t\\t} else {\\n\\t\\t\\tp = s.top(); // 栈顶结点 \\n\\t\\t\\ts.pop(); // 出栈 \\n\\t\\t\\tvisit(p); // 访问结点 \\n\\t\\t\\tp = p->rchild; // 遍历右子树 \\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n/*\\n\\t后序遍历1：\\n\\t后序遍历：左右根，可以看作根右左的逆序输出\\n\\t所以可以利用两个栈：\\n\\t1. push第一个结点进栈 s 中\\n\\t2. 从 s 中pop一个结点temp，存入栈output中\\n\\t3. 然后push temp结点的左孩子和右孩子到 s 中\\n\\t4. 重复过程2,3，直到栈s为空\\n\\t5. 完成后，所有的结点已经push到栈output中，且按照后序遍历二点逆序存放，直接依次pop并输出即位后序遍历的结果 \\n*/ \\nvoid PostOrderByStack1(BiTree T) {\\n\\tstack<BiTree> s, output;\\n\\tBiTree temp = NULL;\\n\\t\\n\\ts.push(T);\\n\\twhile (!s.empty()) {\\n\\t\\ttemp = s.top();\\n\\t\\ts.pop();\\n\\t\\toutput.push(temp);\\n\\t\\tif (temp->lchild) {\\n\\t\\t\\ts.push(temp->lchild);\\n\\t\\t}\\n\\t\\tif (temp->rchild) {\\n\\t\\t\\ts.push(temp->rchild);\\n\\t\\t}\\n\\t}\\n\\twhile (!output.empty()) {\\n\\t\\tprintf(\\\"%c\\\", output.top()->data);\\n\\t\\toutput.pop();\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n// 后序遍历2\\nvoid PostOrderByStack2(BiTree T) {\\n\\tstack<BiTree> s;\\n\\tBiTree p = T, r = NULL;\\n\\t\\n\\twhile (p || !s.empty()) {\\n\\t\\tif (p) { // 入栈左孩子 \\n\\t\\t\\ts.push(p);\\n\\t\\t\\tp = p->lchild;\\n\\t\\t} else {\\n\\t\\t\\tp = s.top();\\n\\t\\t\\tif (p->rchild && p->rchild != r) { // 当前结点有右孩子并且没有访问过，继续往下走 \\n\\t\\t\\t // 下面p位置NULL后，下次会来到改代码块，p更新为栈顶结点，而此时，该结点的右孩子已经访问过\\n\\t\\t\\t\\tp = p->rchild;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts.pop(); // 出栈 \\n\\t\\t\\t\\tvisit(p); // 访问节点 \\n\\t\\t\\t\\tr = p; // 记录该节点 \\n\\t\\t\\t\\tp = NULL; // 置为NULL，使程序能进入到外层的else里面 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n// 后序遍历3\\nvoid PostOrderByStack3(BiTree root)\\n{\\n\\tif (root == NULL) {\\n\\t\\treturn;\\n\\t}\\n\\tstack<BiTree> s;\\n\\t// pCur:当前访问节点，pLastVisit:上次访问节点\\n\\tBiTree pCur, pLastVisit;\\n\\t// pCur = root;\\n\\tpCur = root;\\n\\tpLastVisit = NULL;\\n\\t// 先把pCur移动到左子树最下边\\n\\twhile (pCur) {\\n\\t\\ts.push(pCur);\\n\\t\\tpCur = pCur->lchild;\\n\\t}\\n\\twhile (!s.empty())\\t{\\n\\t\\t// 走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子)\\n\\t\\tpCur = s.top();\\n\\t\\ts.pop();\\n\\t\\t// 一个根节点被访问的前提是：无右子树或右子树已被访问过\\n\\t\\tif (pCur->rchild == NULL || pCur->rchild == pLastVisit)\\t{\\n\\t\\t\\tprintf(\\\"%c\\\", pCur->data);\\n\\t\\t\\t// 修改最近被访问的节点\\n\\t\\t\\tpLastVisit = pCur;\\n\\t\\t}\\n\\t\\t/*  \\n\\t\\t\\t这里的else语句可换成带条件的else if:\\n\\t\\t\\telse if (pCur->lchild == pLastVisit)//若左子树刚被访问过，则需先进入右子树(根节点需再次入栈)\\n\\t\\t\\t因为：上面的条件没通过就一定是下面的条件满足。仔细想想！\\n\\t\\t*/\\n\\t\\telse {\\n\\t\\t\\t// 根节点再次入栈\\n\\t\\t\\ts.push(pCur);\\n\\t\\t\\t// 进入右子树，且可肯定右子树一定不为空\\n\\t\\t\\tpCur = pCur->rchild;\\n\\t\\t\\twhile (pCur) {\\n\\t\\t\\t\\ts.push(pCur);\\n\\t\\t\\t\\tpCur = pCur->lchild;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n}\\n```\\n### 完整代码及测试\\n\\n```c++\\n#include<iostream>\\n#include<queue>\\n#include<stack> \\n#include<cstdlib>\\n\\nusing namespace std;\\n\\ntypedef char ElemType;\\n\\n// 二叉树结点的结构 \\ntypedef struct BiTNode {\\n\\tElemType data; // 数据库 \\n\\tstruct BiTNode *lchild, *rchild; // 左右孩子的指针 \\n} BiTNode, *BiTree;\\n\\n// 先序创建二叉树\\nvoid CreateBiTree(BiTree *T) {\\n\\tElemType data;\\n\\t\\n\\tscanf(\\\"%c\\\", &data);\\n\\tif (data == \' \') {\\n\\t\\t*T = NULL;\\n\\t} else {\\n\\t\\t*T = (BiTree)malloc(sizeof(BiTNode));\\n\\t\\t(*T)->data = data;\\n\\t\\tCreateBiTree(&(*T)->lchild);\\n\\t\\tCreateBiTree(&(*T)->rchild);\\n\\t}\\n} \\n\\n// 输出二叉树结点\\nvoid visit(BiTree T) {\\n\\tif (T->data != \' \') {\\n\\t\\tprintf(\\\"%c\\\", T->data);\\n\\t}\\n} \\n\\n// 线序遍历二叉树\\nvoid PreOrderTraverse(BiTree T) {\\n\\tif (T) {\\n\\t\\tvisit(T);\\n\\t\\tPreOrderTraverse(T->lchild);\\n\\t\\tPreOrderTraverse(T->rchild);\\n\\t}\\n} \\n\\n// 中序遍历二叉树\\nvoid InOrderTraverse(BiTree T) {\\n\\tif (T) {\\n\\t\\tInOrderTraverse(T->lchild);\\n\\t\\tvisit(T);\\n\\t\\tInOrderTraverse(T->rchild);\\n\\t}\\n}\\n\\n// 后序遍历二叉树\\nvoid PostOrderTraverse(BiTree T) {\\n\\tif (T) {\\n\\t\\tPostOrderTraverse(T->lchild);\\n\\t\\tPostOrderTraverse(T->rchild);\\n\\t\\tvisit(T);\\n\\t}\\n} \\n\\n// 层次遍历\\nvoid LevelOrderTraverse(BiTree T) {\\n\\tqueue<BiTree> q;\\n\\tBiTree p;\\n\\tq.push(T);\\n\\twhile (!q.empty()) {\\n\\t\\tp = q.front();\\n\\t\\tq.pop();\\n\\t\\tvisit(p);\\n\\t\\tif (p->lchild) {\\n\\t\\t\\tq.push(p->lchild);\\n\\t\\t}\\n\\t\\tif (p->rchild) {\\n\\t\\t\\tq.push(p->rchild);\\n\\t\\t}\\n\\t}\\n} \\n\\n/* 非递归实现 */\\n// 先序遍历 \\nvoid PreOrderByStack(BiTree T) {\\n\\tstack<BiTree> s;\\n\\tBiTree p = T;\\n\\t\\n\\twhile (p || !s.empty()) { // 栈不为空或p不为空时循环 \\n\\t\\tif (p != NULL) {\\n\\t\\t\\ts.push(p); // 存入栈中 \\n\\t\\t\\tvisit(p); // 输出结点元素 \\n\\t\\t\\tp = p->lchild; // 遍历左子树 \\n\\t\\t} else {\\n\\t\\t\\tp = s.top(); // 栈顶结点 \\n\\t\\t\\ts.pop(); // 出栈 \\n\\t\\t\\tp = p->rchild; // 遍历右子树 \\n\\t\\t} \\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n// 中序遍历 \\nvoid InOrderByStack(BiTree T) {\\n\\tstack<BiTree> s;\\n\\tBiTree p = T;\\n\\t\\n\\twhile (p || !s.empty()) {\\n\\t\\tif (p != NULL) { \\n\\t\\t\\ts.push(p); // 入栈 \\n\\t\\t\\tp = p->lchild; // 遍历左子树 \\n\\t\\t} else {\\n\\t\\t\\tp = s.top(); // 栈顶结点 \\n\\t\\t\\ts.pop(); // 出栈 \\n\\t\\t\\tvisit(p); // 访问结点 \\n\\t\\t\\tp = p->rchild; // 遍历右子树 \\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n/*\\n\\t后序遍历1：\\n\\t后序遍历：左右根，可以看作根右左的逆序输出\\n\\t所以可以利用两个栈：\\n\\t1. push第一个结点进栈 s 中\\n\\t2. 从 s 中pop一个结点temp，存入栈output中\\n\\t3. 然后push temp结点的左孩子和右孩子到 s 中\\n\\t4. 重复过程2,3，直到栈s为空\\n\\t5. 完成后，所有的结点已经push到栈output中，且按照后序遍历二点逆序存放，直接依次pop并输出即位后序遍历的结果 \\n*/ \\nvoid PostOrderByStack1(BiTree T) {\\n\\tstack<BiTree> s, output;\\n\\tBiTree temp = NULL;\\n\\t\\n\\ts.push(T);\\n\\twhile (!s.empty()) {\\n\\t\\ttemp = s.top();\\n\\t\\ts.pop();\\n\\t\\toutput.push(temp);\\n\\t\\tif (temp->lchild) {\\n\\t\\t\\ts.push(temp->lchild);\\n\\t\\t}\\n\\t\\tif (temp->rchild) {\\n\\t\\t\\ts.push(temp->rchild);\\n\\t\\t}\\n\\t}\\n\\twhile (!output.empty()) {\\n\\t\\tprintf(\\\"%c\\\", output.top()->data);\\n\\t\\toutput.pop();\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n// 后序遍历2\\nvoid PostOrderByStack2(BiTree T) {\\n\\tstack<BiTree> s;\\n\\tBiTree p = T, r = NULL;\\n\\t\\n\\twhile (p || !s.empty()) {\\n\\t\\tif (p) { // 入栈左孩子 \\n\\t\\t\\ts.push(p);\\n\\t\\t\\tp = p->lchild;\\n\\t\\t} else {\\n\\t\\t\\tp = s.top();\\n\\t\\t\\tif (p->rchild && p->rchild != r) { // 当前结点有右孩子并且没有访问过，继续往下走 \\n\\t\\t\\t // 下面p位置NULL后，下次会来到改代码块，p更新为栈顶结点，而此时，该结点的右孩子已经访问过\\n\\t\\t\\t\\tp = p->rchild;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts.pop(); // 出栈 \\n\\t\\t\\t\\tvisit(p); // 访问节点 \\n\\t\\t\\t\\tr = p; // 记录该节点 \\n\\t\\t\\t\\tp = NULL; // 置为NULL，使程序能进入到外层的else里面 \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n} \\n\\n// 后序遍历3\\nvoid PostOrderByStack3(BiTree root)\\n{\\n\\tif (root == NULL) {\\n\\t\\treturn;\\n\\t}\\n\\tstack<BiTree> s;\\n\\t// pCur:当前访问节点，pLastVisit:上次访问节点\\n\\tBiTree pCur, pLastVisit;\\n\\t// pCur = root;\\n\\tpCur = root;\\n\\tpLastVisit = NULL;\\n\\t// 先把pCur移动到左子树最下边\\n\\twhile (pCur) {\\n\\t\\ts.push(pCur);\\n\\t\\tpCur = pCur->lchild;\\n\\t}\\n\\twhile (!s.empty())\\t{\\n\\t\\t// 走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子)\\n\\t\\tpCur = s.top();\\n\\t\\ts.pop();\\n\\t\\t// 一个根节点被访问的前提是：无右子树或右子树已被访问过\\n\\t\\tif (pCur->rchild == NULL || pCur->rchild == pLastVisit)\\t{\\n\\t\\t\\tprintf(\\\"%c\\\", pCur->data);\\n\\t\\t\\t// 修改最近被访问的节点\\n\\t\\t\\tpLastVisit = pCur;\\n\\t\\t}\\n\\t\\t/*  \\n\\t\\t\\t这里的else语句可换成带条件的else if:\\n\\t\\t\\telse if (pCur->lchild == pLastVisit)//若左子树刚被访问过，则需先进入右子树(根节点需再次入栈)\\n\\t\\t\\t因为：上面的条件没通过就一定是下面的条件满足。仔细想想！\\n\\t\\t*/\\n\\t\\telse {\\n\\t\\t\\t// 根节点再次入栈\\n\\t\\t\\ts.push(pCur);\\n\\t\\t\\t// 进入右子树，且可肯定右子树一定不为空\\n\\t\\t\\tpCur = pCur->rchild;\\n\\t\\t\\twhile (pCur) {\\n\\t\\t\\t\\ts.push(pCur);\\n\\t\\t\\t\\tpCur = pCur->lchild;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprintf(\\\"\\\\n\\\");\\n}\\n\\nint main()\\n{\\n    BiTree T = NULL;\\n\\n    CreateBiTree(&T);\\n    printf(\\\"========递归实现========\\\\n\\\");\\n    printf(\\\"先序遍历：\\\"); \\n    PreOrderTraverse(T);\\n    printf(\\\"\\\\n\\\");\\n    printf(\\\"中序遍历：\\\");\\n    InOrderTraverse(T);\\n    printf(\\\"\\\\n\\\");\\n    printf(\\\"后序遍历：\\\"); \\n    PostOrderTraverse(T); \\n    printf(\\\"\\\\n\\\");\\n    printf(\\\"层次遍历：\\\");\\n    LevelOrderTraverse(T);\\n    printf(\\\"\\\\n\\\");\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"========非递归实现========\\\\n\\\");\\n    printf(\\\"先序遍历：\\\");\\n    PreOrderByStack(T);\\n    printf(\\\"中序遍历：\\\");\\n    InOrderByStack(T);\\n    printf(\\\"后序遍历1：\\\");\\n    PostOrderByStack1(T);\\n    printf(\\\"后序遍历2：\\\");\\n    PostOrderByStack2(T);\\n    printf(\\\"后序遍历3：\\\"); \\n    PostOrderByStack3(T);\\n    \\n\\treturn 0;\\n} \\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200827095008292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621522256214.jpg\",\"articleTitle\":\"二叉树遍历递归及非递归完整代码实现\",\"categoryId\":16,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[37]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:51:08');
INSERT INTO `tb_operation_log` VALUES (120, '文章模块', '修改', '/admin/articles/top/55', 'top.bravecoder.blog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[55,1]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:51:40');
INSERT INTO `tb_operation_log` VALUES (121, '文章模块', '修改', '/admin/articles/top/47', 'top.bravecoder.blog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[47,1]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:51:47');
INSERT INTO `tb_operation_log` VALUES (122, '文章模块', '修改', '/admin/articles/top/51', 'top.bravecoder.blog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[51,1]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:51:50');
INSERT INTO `tb_operation_log` VALUES (123, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### **用带头结点的单链表来实现队列**\\n\\n+ 队头指针始终指向头结点，队尾指针指向最后一个结点（队尾结点）。\\n+ 空链队的队头指针和队尾指针均指向头结点\\n\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823165353245.png#pic_center)\\n\\n### 完整代码\\n\\n```c++\\n#include<stdio.h>\\n#include<malloc.h>\\n\\n/*\\n\\t用带头结点的单链表来实现队列 \\n*/\\ntypedef struct Node { // 结点结构 \\n    int data; // 数据域 \\n    struct Node *next; // 指向下一个结点的指针 \\n} QNode, *PQNode;\\n\\ntypedef struct {\\n    PQNode front, rear;  // 队头、队尾指针 \\n} LinkQueue, *PLinkQueue;\\n\\n// 初始化队列 \\nvoid Init_LinkQueue(PLinkQueue Q) {\\n    Q->front = Q->rear = (PQNode)malloc(sizeof(QNode)); // 开辟头结点，队头、队尾指针都指向头结点 \\n\\n    if (!Q->front) {\\n        return;\\n    }\\n    Q->front->next = NULL; // 头结点的next指针指向NULL \\n}\\n\\n// 进队操作，参数e是进队的元素 \\nvoid In_LinkQueue(PLinkQueue Q, int e) {\\n    PQNode p;\\n\\n    p = (PQNode)malloc(sizeof(QNode));\\t// 开辟新的结点 \\n    if (p == NULL) {\\n        return;\\n    } \\n    p->data = e; // 赋值元素 \\n    p->next = NULL; // 新结点指向NULL \\n    Q->rear->next = p; // 尾结点的next指针指向新结点 \\n    Q->rear = p; // 尾指针置为新节点 \\n}\\n\\n// 出队操作，参数e用来存放出队元素 \\nvoid Out_LinkQueue(PLinkQueue Q, int *e) {\\n    PQNode p;\\n    \\n    if (Q->front == Q->rear) { // 为空直接返回 \\n        return;\\n    }\\n    p = Q->front->next; // 获取队头结点，即头结点的下一个结点 \\n    *e = p->data; // 获取对应元素 \\n    Q->front->next = p->next; // 将队头结点置为队头的下一个结点，为删除队头结点做准备 \\n\\n    if (Q->rear == p) { // 如果队尾结点与要删除的队头结点相同\\n        Q->rear = Q->front; // 将队尾指针置为头结点 \\n    }\\n    free(p); // 释放队头结点 \\n}\\n\\n// 获取队头元素 \\nint GetFront_LinkQueue(PLinkQueue Q) {\\n    PQNode p;\\n\\n    if (Q->front == Q->rear) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        p = Q->front->next;\\n        return p->data;\\n    }\\n}\\n\\n// 获取队列的长度 \\nint Length_LinkQueue(PLinkQueue Q) {\\n    int count = 0;\\n    PQNode p;\\n\\n    p = Q->front->next;\\n    while (p != NULL) {\\n        count++;\\n        p = p->next;\\n    }\\n    return count;\\n}\\n\\n// 依次遍历打印队列中的元素 \\nvoid Print_LinkQueue(PLinkQueue Q) {\\n    PQNode p;\\n\\n    p = Q->front->next;\\n    if (p == NULL) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        while (p != NULL) {\\n            printf(\\\"%d \\\", p->data);\\n            p = p->next;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\n// 销毁队列 \\nvoid Destroy_LinkQueue(PLinkQueue Q) {\\n    while (Q->front) {\\n        Q->rear = Q->front->next;\\n        free(Q->front);\\n        Q->front = Q->rear;\\n    }\\n}\\n\\nint main() {\\n    LinkQueue q;\\n    PLinkQueue Q = &q;\\n    int n, e, i;\\n\\n    Init_LinkQueue(Q);\\n    printf(\\\"input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    printf(\\\"input Queue :\\\\n\\\");\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        In_LinkQueue(Q, e);\\n    }\\n    printf(\\\"The Queue is :\\\\n\\\");\\n    Print_LinkQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_LinkQueue(Q));\\n\\n    Out_LinkQueue(Q, &e);\\n    printf(\\\"The out data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"The front data is %d.\\\\n\\\", GetFront_LinkQueue(Q));\\n\\n    printf(\\\"Now , the new Queue is :\\\\n\\\");\\n    Print_LinkQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_LinkQueue(Q));\\n\\n    Destroy_LinkQueue(Q);\\n\\n    return 0;\\n} ![](QQ截图20200823165218.png)\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823165406449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621522019040.jpg\",\"articleTitle\":\"链队C语言实现\",\"categoryId\":16,\"id\":62,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[36]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:53:19');
INSERT INTO `tb_operation_log` VALUES (124, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"\\n这里队列的判满方法，采用的是少用一个元素空间的方法，即 (**rear + 1) % MaxSize == front** 时，队列满。\\n\\n**代码**\\n\\n```c++\\n#include<stdio.h>\\n#include<malloc.h>\\n\\n#define MaxSize 100  // 队列的最大长度为 100-1=99\\n\\ntypedef struct {\\n    int data[MaxSize];\\n    int front; // 头指针指向队首元素 \\n\\tint rear; // 尾指针指向队尾元素的下一个元素 \\n} SeqQueue, *PSeqQueue;\\n\\n// 初始化队列 \\nPSeqQueue Init_SeqQueue() {\\n    PSeqQueue Q;\\n\\n    Q = (PSeqQueue)malloc(sizeof(SeqQueue));\\n    if (!Q) {\\n        return NULL;\\n    }\\n    // 将队头和队尾指针置为0 \\n    Q->front = 0;\\n    Q->rear = 0;\\n    return Q;\\n}\\n\\n// 返回队列的实际长度 = (rear - front + maxSize) % maxSize \\nint Length_SeqQueue(PSeqQueue Q) {\\n    return ((Q->rear - Q->front + MaxSize) % MaxSize);\\n}\\n\\n// 判断队列是否为空，队首和队尾指针相等时为空 \\nint Empty_SeqQueue(PSeqQueue Q) {\\n    return Q->front == Q->rear;\\n}\\n\\n// 入队操作，参数x为入队元素 \\nvoid In_SeqQueue(PSeqQueue Q, int x) {\\n\\t// 判断队列是否已满，这里通过少用一个元素空间来判断队列是否已满 \\n    if ((Q->rear + 1) % MaxSize == Q->front) {\\n        printf(\\\"Queue is full!\\\\n\\\");\\n        return;\\n    }\\n    Q->data[Q->rear] = x; // 对应元素入队 \\n    Q->rear = (Q->rear + 1) % MaxSize; // 队尾指针后移  \\n}\\n\\n// 出队操作，参数e用来存储出队的元素 \\nvoid Out_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) { // 判断队列是否为空 \\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return;\\n    }\\n    *e = Q->data[Q->front]; // 出队元素的赋值 \\n    Q->front = (Q->front + 1) % MaxSize; // 队首元素后移 \\n}\\n\\n// 获取队首元素，存放在参数e中 \\nint Front_SeqQueue(PSeqQueue Q, int *e) {\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n        return 0;\\n    }\\n    *e = Q->data[Q->front];\\n    return 1;\\n}\\n\\n// 遍历打印队列中的元素 \\nvoid Print_SeqQueue(PSeqQueue Q) {\\n    int i;\\n\\n    if (Empty_SeqQueue(Q)) {\\n        printf(\\\"Queue NULL!\\\\n\\\");\\n    } else {\\n        i = Q->front;\\n        while (i != Q->rear) {\\n            printf(\\\"%d \\\", Q->data[i]);\\n            i = (i + 1) % MaxSize;\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main() {\\n    PSeqQueue Q;\\n    int e, n, i;\\n\\n    printf(\\\"input the number of data :\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    Q = Init_SeqQueue();\\n\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &e);\\n        In_SeqQueue(Q, e);\\n    }\\n    printf(\\\"The Queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n    Out_SeqQueue(Q, &e);\\n    printf(\\\"The out data is %d.\\\\n\\\", e);\\n\\n    Front_SeqQueue(Q, &e);\\n    printf(\\\"The front data is %d.\\\\n\\\", e);\\n\\n    printf(\\\"Now , the queue is :\\\\n\\\");\\n    Print_SeqQueue(Q);\\n\\n    printf(\\\"The length of the new Queue is %d.\\\\n\\\", Length_SeqQueue(Q));\\n\\n    return 0;\\n}\\n```\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082021454422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNDk0Nzcx,size_16,color_FFFFFF,t_70#pic_center)\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621521586845.jpg\",\"articleTitle\":\"循环队列的C语言实现\",\"categoryId\":16,\"id\":61,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[34]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-20 22:53:38');
INSERT INTO `tb_operation_log` VALUES (125, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [问题 A: 机器人足球](https://acm.webturing.com/problem.php?cid=1355&pid=0&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n足球场地长为100,宽为20,对方的球门坐标为(100,10),你要控制一个个机器人踢球，初始位置为(x,y).机器人可以朝任何方向移动，但不能超出场地边界，当机器人与球门距离不超过10时，可以射门。 问机器人从初始位置出发到射门，最少要移动多少距离? (四舍五人到小数点后3位)\\n\\n**输入**\\n\\n每组输人为2个整数，分别为x ,y\\n0<= x<=100\\n0<= y<=20\\n\\n**输出**\\n\\n输出最小移动的距离\\n\\n**样例输入**\\n\\n```c++\\n10 10\\n1\\n```\\n\\n**样例输出**\\n\\n```c++\\n80.000\\n```\\n\\n**题解: ** 到球门中心的距离减去半径10\\n\\n```c++\\n#include<stdio.h>\\n#include<math.h>\\n\\nint main() {\\n\\tint x, y;\\n\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\tdouble s = sqrt((x-100)*(x-100) + (y-10)*(y-10));\\n\\tprintf(\\\"%.3lf\\\\n\\\", s - 10);\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 B: 纸牌识别](https://acm.webturing.com/problem.php?cid=1355&pid=1&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\nAlice沉迷于机器人研究，他打算做- - 个机器人来检查-副扑克是否完整。现在，他想请你帮他写-一个程序，来识别纸牌，每张纸牌都有-个花色(四种花色，分别用大写字母P，K, H, T表示)和一一个数字点数(1-13) .纸牌可以用ABC的形式来表示，A代表花色，BC代表数字，如果数字小于10，会有一位补0.\\n​ 比如花色是P,数字是9的纸牌会表示成P09.一副完整的纸牌有52张牌，四种不同的花色各有1张数字1-13的牌.你的程序要读人一个字符串，表示缺少的纸牌有哪些。如果包含相同的纸牌(花色数字都相同)输出GRESKA,否则输出每种花色剩余的纸牌数量。\\n\\n**输入**\\n\\n输人只有一行，一个字符串S, S的长度长度小于等于1000\\n\\n**输出**\\n\\n如果输人中包含相同的纸牌，输出GRESKA,否则分别输出四个整数，代表P,K, H, T四种花色纸牌的剩余数量\\n\\n**样例输入**\\n\\n```c++\\nP01K02H03H04\\n1\\n```\\n\\n**样例输出**\\n\\n```c++\\n12 12 11 13\\n```\\n\\n**题解：**模拟，利用四个数组分别表示四种花色牌的状态，对输入的字符串每3个字符一组进行判断，判断对应花色的牌是否存在，若不存在，将对应下标的数组置 1，对应花色的数量减 1，否则输出 GRESKA。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n// 分别代表四种花色对应牌是否已经含有 \\nint c1[14], c2[14], c3[14], c4[14];\\nchar str[1005];\\n// 分别表示四种花色的牌的数量 \\nint s1 = 13, s2 = 13, s3 = 13, s4 = 13; \\nint flag;\\n\\nint main() {\\n\\tcin>>str;\\n\\tfor (int i = 0; i < 14; i++) {\\n\\t\\tc1[i] = 0;\\n\\t\\tc2[i] = 0;\\n\\t\\tc3[i] = 0;\\n\\t\\tc4[i] = 0;\\t\\n\\t}\\n\\tint i = 0;\\n\\tint len = strlen(str);\\n\\tflag = 0;\\n\\twhile (i < len)\\t{\\n\\t\\tint num;\\n\\t\\tnum = (str[i+1] - \'0\') * 10 + str[i+2] - \'0\';\\n\\t\\tif (str[i] == \'P\') {\\n\\t\\t\\tif (c1[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc1[num] = 1;\\n\\t\\t\\t\\ts1--;\\n\\t\\t\\t}\\n\\t\\t} else if (str[i] == \'K\') {\\n\\t\\t\\tif (c2[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc2[num] = 1;\\n\\t\\t\\t\\ts2--;\\n\\t\\t\\t}\\n\\t\\t} else if (str[i] == \'H\') {\\n\\t\\t\\tif (c3[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc3[num] = 1;\\n\\t\\t\\t\\ts3--;\\n\\t\\t\\t}\\n\\t\\t} else if (str[i] == \'T\') {\\n\\t\\t\\tif (c4[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc4[num] = 1;\\n\\t\\t\\t\\ts4--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ti += 3;\\n\\t}\\n\\tif (!flag) {\\n\\t\\tcout<<s1<<\\\" \\\"<<s2<<\\\" \\\"<<s3<<\\\" \\\"<<s4<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 C: 卡牌对决](https://acm.webturing.com/problem.php?cid=1355&pid=2&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n有2N张牌，它们的点数分别为1到2N。Alice拿了其中的N张，Bob拿了剩下的N张. Alice和Bob会进行N轮游戏，在每轮游戏中，Alice 和Bob 各出一张牌。出了的牌不能收回。在前N/2轮中，每轮谁的牌点数大谁就赢;在后N/2轮中，每轮谁的牌点数小谁就赢。已知Bob 每一轮会出什么牌，试求Alice 最多能赢多少轮。\\n\\n**输入**\\n\\n第一行是一个整数N,\\n接下来N行，每行一个整数，表示Bob这轮会出什么。\\n2<=N <= 50000,保证N是偶数\\n\\n**输出**\\n\\n输出Alice最多能赢几轮\\n\\n**样例输入**\\n\\n```c++\\n4\\n1\\n8\\n4\\n3\\n1\\n2\\n3\\n4\\n5\\n```\\n\\n**样例输出**\\n\\n```c++\\n2\\n```\\n\\n**题解：**贪心，先把 b 的牌分成前 N/2 和 后 N/2，再根据 b 的牌得出 a 的牌，对 a、b的牌升序排列。因为前 N/2 轮，a 的牌大于 b 的牌，a 胜利，所以，用 a 的后 N/2 张牌（a 的较大值）与 b 的前 N/2 张牌（b 的较小值）进行比较；对于后 N/2 轮，则反过来。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint s[100001];  // 全部的牌 \\nint a[50001]; // Alice 的牌 \\nint b1[25001]; // Bob 前 N/2 的牌 \\nint b2[25001]; // Bob 后 N/2 的牌 \\nint N;\\n\\nint main() {\\n\\tint x, y;\\n\\tcin>>N;\\n\\tfor (int i = 1; i <= 2*N; i++) {\\n\\t\\ts[i] = i;\\n\\t}\\n\\tmemset(b1, 0, sizeof(b1));\\n\\tmemset(b2, 0, sizeof(b2));\\n\\t// 输入 Bob 的牌 \\n\\tfor (int i = 1, j = 1, k = 1; i <= N; i++) {\\n\\t\\tif (i <= N/2) {\\n\\t\\t\\tcin>>x;\\n\\t\\t\\tb1[j++] = x;\\n\\t\\t\\ts[x] = 0;\\n\\t\\t} else {\\n\\t\\t\\tcin>>y;\\n\\t\\t\\tb2[k++] = y;\\n\\t\\t\\ts[y] = 0;\\n\\t\\t}\\n\\t}\\n\\t// 根据 Bob 的牌和全部的牌得出 Alice 的牌 \\n\\tfor (int i = 1, k = 1; i <= 2*N; i++) {\\n\\t\\tif (s[i]) {\\n\\t\\t\\ta[k++] = s[i];\\n\\t\\t}\\n\\t}\\n\\t// 各自的牌都升序排列 \\n\\tsort(a + 1, a + N + 1);\\n\\tsort(b2 + 1, b2 + N/2 + 1);\\n\\tsort(b1 + 1, b1 + N/2 + 1);\\n\\tint count = 0;\\n\\t// a 的后 N/2 与 b 的前 N/2 比较，a > b 胜 \\n\\t// a 的后 N/2 是 a 的较大值，b 的前 N/2 是 b 的较小值 \\n\\tint i = N/2 + 1;\\n\\tint j = 1;\\n\\twhile (i <= N && j <= N/2) {\\n\\t\\tif (a[i] > b1[j]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t} else {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n\\t// a 的前 N/2 与 b 的后 N/2 比较，a < b 胜 \\n\\t// a 的较小值与 b 的较大值 \\n\\ti = N/2;\\n\\tj = N/2;\\n\\twhile (i >= 1 && j >= 1) {\\n\\t\\tif (a[i] < b2[j]) {\\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t\\tcount++;\\n\\t\\t} else {\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t}\\n\\tcout<<count<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n\\n## [问题 H: 不要回文](https://acm.webturing.com/problem.php?cid=1355&pid=7&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n给出一个字符串 S，你需要尽可能少的修改 S 中的字符， 使得 S 不包含长度大于等于 2 的回文子串。\\n\\n**输入**\\n\\n输入的第一行是一个字符串 S， S只包含小写字母\\nS 的长度大于 5 小于 300\\n\\n**输出**\\n\\n输出使得 S 中不包含长度大于等于 2 的回文， 最少需要修改几个字符 （可以修改成任意字符）\\n\\n**样例输入**\\n\\n```c++\\nabbaa\\n1\\n```\\n\\n**样例输出**\\n\\n```c++\\n2\\n```\\n\\n**题解：**贪心\\n\\n+ 把字符串中的字符转化成数字\\n+ 进行两轮扫描，第一轮消除 3个字符的回文；第二轮消除 2个字符的回文\\n+ 消除回文时，对**可能构成多个回文的字符**进行重新赋值，赋值一个不存在的数字即可\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint a[305], ans = 0;\\nint t = 30;\\nstring s;\\n\\nint main() {\\n\\tcin>>s;\\n\\tint len = s.length();\\n\\t// 把字符串的字符转化成数字 \\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\ta[i+1] = s[i] - \'a\' + 1;\\n\\t}\\n\\t// 第一轮扫描，消除 3个字符的回文 \\n\\tfor (int i = 1; i <= len - 2; i++) {\\n \\t  \\tif (a[i] == a[i+2]) { \\n \\t  \\t\\tif (a[i] == a[i-1]) { \\n \\t  \\t\\t\\ta[i] = t++;\\n \\t  \\t\\t\\tans++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta[i+2] = t++;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// 第二轮扫描，消除 2个字符的回文 \\n\\tfor (int i = 1; i <= len - 1; i++) {\\n\\t\\tif (a[i] == a[i+1]) {\\n\\t\\t\\ta[i+1] = t++;\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t}\\n\\tcout<<ans;\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 I: 你的名字](https://acm.webturing.com/problem.php?cid=1355&pid=8&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n​ Alice 想要计算他那 N 只猫的名字的价值每只猫的名字由不超过 1000 个大小写字母构成，没有一个名字是空字体串。 Alice有一张*价值字符串表”， 上面有 M个代表价值的字符串。每个字符串由不超过30个大小写字母构成，同样不存在空字符串。一个猫的名字蕴含多少个价值字符串，这个名字就有多少价值，所谓 “蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现 (不一定一个紧接着一个) .\\n​ 所有的大写字母和小写字母都是等价的。比如，在贝黄的名字\\\"Bessie\\\"里， 蕴含有 “Be” “si” “EE” 以及 “Es” 等等字符串，但不蕴含\\\"Ls°或\\\"eB\\\"请帮Alice计算他的猫的名字的价值.\\n\\n**输入**\\n\\n输人的第-行是两个整数 N M\\n接下来N行，每行一个字符串表示猫的名字。\\n接下来M行，每行一个价值字符串\\n1 <=N<= 1000\\n1 <= M<=100\\n\\n**输出**\\n\\n输出每只猫蕴含多少个价值字符串。\\n\\n**样例输入**\\n\\n```c++\\n5 3\\nBessie\\nJonathan\\nMontgomery\\nAlicia\\nAngola\\nSe  \\nnGo  \\noNt\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n```\\n\\n**样例输出**\\n\\n```c++\\n1\\n1\\n2\\n0\\n1\\n```\\n\\n**题解：**暴力，对每个名字，在价值字符串中扫描\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nchar cat[1005][1005];\\nchar val[105][35];\\nint n, m;\\n\\nint main() {\\n\\tcin>>n>>m;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>cat[i];\\n\\t\\tint len = strlen(cat[i]);\\n\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\tcat[i][j] = tolower(cat[i][j]); // 转化为小写 \\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tcin>>val[i];\\n\\t\\tint len = strlen(val[i]);\\n\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\tval[i][j] = tolower(val[i][j]); // 转化为小写 \\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {  // 名字循环\\n\\t\\tint count = 0;\\n\\t\\tfor (int j = 0; j < m; j++) { // 价值循环（多个价值字符串）\\n\\t\\t\\tint lenCat = strlen(cat[i]);\\n\\t\\t\\tint lenVal = strlen(val[j]);\\n\\t\\t\\tint p = 0, flag = 0;\\n\\t\\t\\tfor (int k = 0; k < lenVal; k++) { // 价值字符串长度\\n\\t\\t\\t\\twhile (p < lenCat && cat[i][p] != val[j][k]) {\\n\\t\\t\\t\\t\\tp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (p == lenCat) {\\n\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp++;\\n\\t\\t\\t}\\n\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<count<<endl;\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## [问题 L: 曲奇工厂](https://acm.webturing.com/problem.php?cid=1355&pid=11&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n曲奇工厂是一个经典好玩的益智游戏，游戏中你的目标是生产至少 C 块曲奇:游戏的规则十分简单; 游戏开始时你有 0 块曲奇，每分钟可以手工作出 S 块曲奇。你也可以从 N 个工厂中选择些买下来; 工厂依次编号为 1-N ,买下第 i 个工厂需要花费 Ai 个曲奇饼。但是工厂会为你带来更多收益，买下第 i 个工厂后，每分钟曲奇产出会增加 Bi 块。\\n对于每个工厂，你只能买一次: 你只能在整数分钟时购买工厂，并且可以一次买多个工厂, 请问达成日标所用最短时间是多少?\\n\\n**输入**\\n\\n输人的第一行是三个整数 N, C 和 S\\n接下来 N 行，每行两个整数 Ai 和 Bi\\n1 <=N<= 5\\n1<= C, S, Ai, Bi <=.10^5\\n\\n**输出**\\n\\n输出得到至少C块曲奇,最少要多长时间。\\n\\n**样例输入**\\n\\n```c++\\n2 18 1\\n6 2\\n5 1\\n1\\n2\\n3\\n```\\n\\n**样例输出**\\n\\n```c++\\n12\\n```\\n\\n**题解：**求出工厂的全排列，依次按每种排列进行生产曲奇，每种排列中依次增加工厂，并计算每次需要花费的时间，这样所有情况都涉及到，取最小的时间即可。\\n\\n**技巧**：对工厂数组的下标进行全排列，也可以得到工厂数组的全排列。\\n\\n```c++\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nint n, c, s, ans;\\nint a[5], b[5];\\nint f[5] = {0, 1, 2, 3, 4};\\n\\nint main() {\\n    cin >> n >> c >> s;\\n    for (int i = 0; i < n; i++) {\\n    \\tcin >> a[i] >> b[i];\\n\\t}\\n    ans = 0x3f3f3f3f;\\n    do {\\n        int i, j, k, t, w, val;\\n        // (c + s - 1) / S 不使用工厂完成任务需要花费的时间 \\n        ans = min(ans, (c + s - 1) / s);\\n        for (j = f[i = 0], t = val = 0, w = s; i < n; i++, j = f[i]) {\\n        \\t// 买 j 工厂需要花费多长时间 \\n            k = max(0, a[j] - val + w - 1) / w;\\n            // 花费的时间增加 \\n            t += k;\\n            // 买工厂后剩余的曲奇饼 \\n\\t\\t\\tval += k * w - a[j];\\n\\t\\t\\t// 买工厂后，每分钟能做出的曲奇饼数量增加了 \\n\\t\\t\\tw += b[j];\\n\\t\\t\\t// 有该工厂后，完成任务需要多少时间，更新 ans \\n            ans = min(ans, t + max(0, (c - val + w - 1) / w));\\n        }\\n    } while (next_permutation(f, f + n));\\n    cout << ans << endl;\\n    return 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621603583016.jpg\",\"articleTitle\":\"2019年安徽省程序设计大赛题解\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26,22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 21:26:26');
INSERT INTO `tb_operation_log` VALUES (126, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"分数规划\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 22:07:57');
INSERT INTO `tb_operation_log` VALUES (127, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Dropping tests POJ-2976](http://poj.org/problem?id=2976) 0/1分数规划 最大化平均值\\n\\n**Description**\\n\\nIn a certain course, you take *n* tests. If you get *ai* out of *bi* questions correct on test *i*, your cumulative average is defined to be\\n\\n![img](http://poj.org/images/2976_1.gif).\\n\\nGiven your test scores and a positive integer *k*, determine how high you can make your cumulative average if you are allowed to drop any *k* of your test scores.\\n\\nSuppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is ![img](http://poj.org/images/2976_3.gif). However, if you drop the third test, your cumulative average becomes ![img](http://poj.org/images/2976_2.gif).\\n\\n**Input**\\n\\nThe input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ *n* ≤ 1000 and 0 ≤ *k* < *n*. The second line contains *n* integers indicating *ai* for all *i*. The third line contains *n* positive integers indicating *bi* for all *i*. It is guaranteed that 0 ≤ *ai* ≤ *bi* ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with *n* = *k* = 0 and should not be processed.\\n\\n**Output**\\n\\nFor each test case, write a single line with the highest cumulative average possible after dropping *k* of the given test scores. The average should be rounded to the nearest integer.\\n\\n**Sample Input**\\n\\n```c++\\n3 1\\n5 0 2\\n5 1 6\\n4 2\\n1 2 7 9\\n5 6 7 9\\n0 0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n83\\n100\\n```\\n\\n**解题思路**\\n\\n给定两个数组a，b，a[i] 和 b[i] 是相对应的，不能改变位置，去掉其中的 k 个元素，求最大的 r = ∑a[i]/∑b[i]。\\n\\n对上面的式子进行转化，只要给每个物品重新赋值为 a[i] - r\' * b[i]，排序之后直接取前 n - k 大，判断这个值的正负性，进行二分，大于0，mid 偏小，l = mid，小于0，mid 偏大，r = mid。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\nconst int inf = 0x3f3f3f3f;\\n\\nint n, k;\\ndouble a[maxn], b[maxn], d[maxn];\\n\\ndouble check(double len) {\\n\\tdouble sum = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\td[i] = a[i] - b[i] * len;\\n\\t}\\n\\t// 升序排列 \\n\\tsort(d, d + n);\\n\\t// 去掉前 k 个元素 \\n\\tfor (int i = k; i < n; i++) {\\n\\t\\tsum += d[i];\\n\\t}\\n\\treturn sum;\\n}\\n \\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &k)) {\\n\\t\\tif (!n && !k) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%lf\\\", &b[i]);\\n\\t\\t}\\n\\t\\tdouble l = inf, r = -inf;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tl = min(l, a[i] / b[i]);\\n\\t\\t\\tr = max(r, a[i] / b[i]);\\n\\t\\t} \\n\\t\\twhile (r - l > 1e-7) {\\n\\t\\t\\tdouble mid = (l + r) / 2;\\n\\t\\t\\t// 大于0，mid 偏小 \\n\\t\\t\\tif (check(mid) > 0) {\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\t} else { // mid 偏大 \\n\\t\\t\\t\\tr = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%.0f\\\\n\\\", l * 100);\\n\\t} \\n\\treturn 0;\\n}\\n```\\n\\n## [Desert King POJ-2728](http://poj.org/problem?id=2728) 最优比率生成树\\n\\n**Description**\\n\\nDavid the Great has just become the king of a desert country. To win the respect of his people, he decided to build channels all over his country to bring water to every village. Villages which are connected to his capital village will be watered. As the dominate ruler and the symbol of wisdom in the country, he needs to build the channels in a most elegant way.\\nAfter days of study, he finally figured his plan out. He wanted the average cost of each mile of the channels to be minimized. In other words, the ratio of the overall cost of the channels to the total length must be minimized. He just needs to build the necessary channels to bring water to all the villages, which means there will be only one way to connect each village to the capital.\\nHis engineers surveyed the country and recorded the position and altitude of each village. All the channels must go straight between two villages and be built horizontally. Since every two villages are at different altitudes, they concluded that each channel between two villages needed a vertical water lifter, which can lift water up or let water flow down. The length of the channel is the horizontal distance between the two villages. The cost of the channel is the height of the lifter. You should notice that each village is at a different altitude, and different channels can\'t share a lifter. Channels can intersect safely and no three villages are on the same line.\\nAs King David\'s prime scientist and programmer, you are asked to find out the best solution to build the channels.\\n\\n**Input**\\n\\nThere are several test cases. Each test case starts with a line containing a number N (2 <= N <= 1000), which is the number of villages. Each of the following N lines contains three integers, x, y and z (0 <= x, y < 10000, 0 <= z < 10000000). (x, y) is the position of the village and z is the altitude. The first village is the capital. A test case with N = 0 ends the input, and should not be processed.\\n\\n**Output**\\n\\nFor each test case, output one line containing a decimal number, which is the minimum ratio of overall cost of the channels to the total length. This number should be rounded three digits after the decimal point.\\n\\n**Sample Input**\\n\\n```c++\\n4\\n0 0 0\\n0 1 1\\n1 1 2\\n1 0 3\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1.000\\n```\\n\\n**题目大意：**有 n 个村庄，村庄在不同坐标和海拔，现在要对所有村庄供水，只要两个村庄之间有一条路即可，建造水管距离为坐标之间的欧几里德距离，费用为海拔之差，现在要求方案使得费用与距离的比值最小，很显然，这个题目是要求一棵最优比率生成树。\\n\\n**解题思路：**\\n\\n[参考链接](https://blog.csdn.net/sdj222555/article/details/7490797?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.control)\\n\\n求 MIN（ ∑CiXi / ∑DiXi ） Xi∈{0，1} ，对每个生成树，设其比率 r = ∑CiXi / ∑DiXi ，可得 ∑CiXi - ∑DiXi * r=0（条件1）\\n\\n那么对于所有的生成树，显然 ∑CiXi - ∑DiXi * min(r) >= 0，当 ∑CiXi / ∑DiXi = min(r)时，等号成立。 而我们现在不知道min(r)是多少，只好进行枚举，对每个枚举的 r ,构建新的权值（Ci - Di * r），然后求最小生成树，寻找使得生成树的总权值为 0 的可能性，因为只有当其等于0 的时候，才满足了条件 1 这个条件， 说明这个 r 是可行的，并且如果 r 枚举到值为min(r)时，其最小生成树的的总权值必然恰好等于0，但是如果不能等于0， 比如大于0， 显然是对该r值，所有的生成树上无论如何也满足不了条件1，说明 r 值就是偏小了。同理如果小于0，r 值是偏大的，说明可能存在某些生成树使得满足条件1，而我们的目标是在满足条件1的情况下使得 r 最小。\\n\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cmath>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\nconst double eps = 1e-6;\\n\\nint n; \\ndouble x[maxn], y[maxn], z[maxn];\\ndouble dist[maxn], g[maxn][maxn], res; \\nint vis[maxn];\\n\\ndouble cal(int i, int j, double mid) {\\n\\treturn fabs(z[i]-z[j]) - mid*sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\\n}\\n\\ndouble prim(double mid) {\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tfor (int j = i + 1; j <= n; j++) {\\n            // 计算边的新权值\\n\\t\\t\\tg[i][j] = g[j][i] = cal(i, j, mid);\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tvis[i] = 0;\\n\\t\\tdist[i] = g[1][i];\\n\\t}\\n\\tdist[1] = 0;\\n\\tvis[1] = 1;\\n\\n\\tint x;\\n\\tdouble sum = 0;\\n\\tfor (int i = 0; i < n - 1; i++)\\t{\\n\\t\\tdouble mindis = 1000000009;\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (!vis[j] && dist[j] < mindis) {\\n\\t\\t\\t\\tmindis = dist[j];\\n\\t\\t\\t\\tx = j;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tvis[x] = 1;\\n\\t\\tsum += mindis;\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (!vis[j] && dist[j] > g[x][j]) {\\n\\t\\t\\t\\tdist[j] = g[x][j];\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\treturn sum;\\n}\\n\\nint main() {\\n\\twhile (~scanf(\\\"%d\\\", &n) && n) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%lf%lf%lf\\\", &x[i], &y[i], &z[i]);\\n\\t\\t}\\n\\t\\tdouble l = 0.0, r = 1e10;\\n\\t\\twhile (fabs(r - l) > eps) {\\n\\t\\t\\tdouble mid = (l + r) / 2;\\n\\t\\t\\tif (prim(mid) >= eps) {\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%.3lf\\\\n\\\", l);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621606137069.jpg\",\"articleTitle\":\"分数规划入门\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[38,24]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 22:09:02');
INSERT INTO `tb_operation_log` VALUES (128, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [Dropping tests POJ-2976](http://poj.org/problem?id=2976) 0/1分数规划 最大化平均值\\n\\n**Description**\\n\\nIn a certain course, you take *n* tests. If you get *ai* out of *bi* questions correct on test *i*, your cumulative average is defined to be\\n\\n![img](http://poj.org/images/2976_1.gif).\\n\\nGiven your test scores and a positive integer *k*, determine how high you can make your cumulative average if you are allowed to drop any *k* of your test scores.\\n\\nSuppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is ![img](http://poj.org/images/2976_3.gif). However, if you drop the third test, your cumulative average becomes ![img](http://poj.org/images/2976_2.gif).\\n\\n**Input**\\n\\nThe input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ *n* ≤ 1000 and 0 ≤ *k* < *n*. The second line contains *n* integers indicating *ai* for all *i*. The third line contains *n* positive integers indicating *bi* for all *i*. It is guaranteed that 0 ≤ *ai* ≤ *bi* ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with *n* = *k* = 0 and should not be processed.\\n\\n**Output**\\n\\nFor each test case, write a single line with the highest cumulative average possible after dropping *k* of the given test scores. The average should be rounded to the nearest integer.\\n\\n**Sample Input**\\n\\n```c++\\n3 1\\n5 0 2\\n5 1 6\\n4 2\\n1 2 7 9\\n5 6 7 9\\n0 0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n83\\n100\\n```\\n\\n**解题思路**\\n\\n给定两个数组a，b，a[i] 和 b[i] 是相对应的，不能改变位置，去掉其中的 k 个元素，求最大的 r = ∑a[i]/∑b[i]。\\n\\n对上面的式子进行转化，只要给每个物品重新赋值为 a[i] - r\' * b[i]，排序之后直接取前 n - k 大，判断这个值的正负性，进行二分，大于0，mid 偏小，l = mid，小于0，mid 偏大，r = mid。\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\nconst int inf = 0x3f3f3f3f;\\n\\nint n, k;\\ndouble a[maxn], b[maxn], d[maxn];\\n\\ndouble check(double len) {\\n\\tdouble sum = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\td[i] = a[i] - b[i] * len;\\n\\t}\\n\\t// 升序排列 \\n\\tsort(d, d + n);\\n\\t// 去掉前 k 个元素 \\n\\tfor (int i = k; i < n; i++) {\\n\\t\\tsum += d[i];\\n\\t}\\n\\treturn sum;\\n}\\n \\nint main() {\\n\\twhile (~scanf(\\\"%d%d\\\", &n, &k)) {\\n\\t\\tif (!n && !k) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tscanf(\\\"%lf\\\", &b[i]);\\n\\t\\t}\\n\\t\\tdouble l = inf, r = -inf;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tl = min(l, a[i] / b[i]);\\n\\t\\t\\tr = max(r, a[i] / b[i]);\\n\\t\\t} \\n\\t\\twhile (r - l > 1e-7) {\\n\\t\\t\\tdouble mid = (l + r) / 2;\\n\\t\\t\\t// 大于0，mid 偏小 \\n\\t\\t\\tif (check(mid) > 0) {\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\t} else { // mid 偏大 \\n\\t\\t\\t\\tr = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%.0f\\\\n\\\", l * 100);\\n\\t} \\n\\treturn 0;\\n}\\n```\\n\\n## [Desert King POJ-2728](http://poj.org/problem?id=2728) 最优比率生成树\\n\\n**Description**\\n\\nDavid the Great has just become the king of a desert country. To win the respect of his people, he decided to build channels all over his country to bring water to every village. Villages which are connected to his capital village will be watered. As the dominate ruler and the symbol of wisdom in the country, he needs to build the channels in a most elegant way.\\nAfter days of study, he finally figured his plan out. He wanted the average cost of each mile of the channels to be minimized. In other words, the ratio of the overall cost of the channels to the total length must be minimized. He just needs to build the necessary channels to bring water to all the villages, which means there will be only one way to connect each village to the capital.\\nHis engineers surveyed the country and recorded the position and altitude of each village. All the channels must go straight between two villages and be built horizontally. Since every two villages are at different altitudes, they concluded that each channel between two villages needed a vertical water lifter, which can lift water up or let water flow down. The length of the channel is the horizontal distance between the two villages. The cost of the channel is the height of the lifter. You should notice that each village is at a different altitude, and different channels can\'t share a lifter. Channels can intersect safely and no three villages are on the same line.\\nAs King David\'s prime scientist and programmer, you are asked to find out the best solution to build the channels.\\n\\n**Input**\\n\\nThere are several test cases. Each test case starts with a line containing a number N (2 <= N <= 1000), which is the number of villages. Each of the following N lines contains three integers, x, y and z (0 <= x, y < 10000, 0 <= z < 10000000). (x, y) is the position of the village and z is the altitude. The first village is the capital. A test case with N = 0 ends the input, and should not be processed.\\n\\n**Output**\\n\\nFor each test case, output one line containing a decimal number, which is the minimum ratio of overall cost of the channels to the total length. This number should be rounded three digits after the decimal point.\\n\\n**Sample Input**\\n\\n```c++\\n4\\n0 0 0\\n0 1 1\\n1 1 2\\n1 0 3\\n0\\n```\\n\\n**Sample Output**\\n\\n```c++\\n1.000\\n```\\n\\n**题目大意：**有 n 个村庄，村庄在不同坐标和海拔，现在要对所有村庄供水，只要两个村庄之间有一条路即可，建造水管距离为坐标之间的欧几里德距离，费用为海拔之差，现在要求方案使得费用与距离的比值最小，很显然，这个题目是要求一棵最优比率生成树。\\n\\n**解题思路：**\\n\\n[参考链接](https://blog.csdn.net/sdj222555/article/details/7490797?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.control)\\n\\n求 MIN（ ∑CiXi / ∑DiXi ） Xi∈{0，1} ，对每个生成树，设其比率 r = ∑CiXi / ∑DiXi ，可得 ∑CiXi - ∑DiXi * r=0（条件1）\\n\\n那么对于所有的生成树，显然 ∑CiXi - ∑DiXi * min( r ) >= 0，当 ∑CiXi / ∑DiXi = min( r )时，等号成立。 而我们现在不知道 min( r )是多少，只好进行枚举，对每个枚举的 r ,构建新的权值（Ci - Di * r），然后求最小生成树，寻找使得生成树的总权值为 0 的可能性，因为只有当其等于0 的时候，才满足了条件 1 这个条件， 说明这个 r 是可行的，并且如果 r 枚举到值为min( r )时，其最小生成树的的总权值必然恰好等于 0，但是如果不能等于 0， 比如大于 0， 显然是对该r值，所有的生成树上无论如何也满足不了条件1，说明 r 值就是偏小了。同理如果小于0，r 值是偏大的，说明可能存在某些生成树使得满足条件1，而我们的目标是在满足条件1的情况下使得 r 最小。\\n\\n\\n```c++\\n#include<iostream>\\n#include<algorithm>\\n#include<cmath>\\n#include<cstring>\\nusing namespace std;\\n\\nconst int maxn = 1005;\\nconst double eps = 1e-6;\\n\\nint n; \\ndouble x[maxn], y[maxn], z[maxn];\\ndouble dist[maxn], g[maxn][maxn], res; \\nint vis[maxn];\\n\\ndouble cal(int i, int j, double mid) {\\n\\treturn fabs(z[i]-z[j]) - mid*sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\\n}\\n\\ndouble prim(double mid) {\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tfor (int j = i + 1; j <= n; j++) {\\n            // 计算边的新权值\\n\\t\\t\\tg[i][j] = g[j][i] = cal(i, j, mid);\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tvis[i] = 0;\\n\\t\\tdist[i] = g[1][i];\\n\\t}\\n\\tdist[1] = 0;\\n\\tvis[1] = 1;\\n\\n\\tint x;\\n\\tdouble sum = 0;\\n\\tfor (int i = 0; i < n - 1; i++)\\t{\\n\\t\\tdouble mindis = 1000000009;\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (!vis[j] && dist[j] < mindis) {\\n\\t\\t\\t\\tmindis = dist[j];\\n\\t\\t\\t\\tx = j;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tvis[x] = 1;\\n\\t\\tsum += mindis;\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (!vis[j] && dist[j] > g[x][j]) {\\n\\t\\t\\t\\tdist[j] = g[x][j];\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\treturn sum;\\n}\\n\\nint main() {\\n\\twhile (~scanf(\\\"%d\\\", &n) && n) {\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tscanf(\\\"%lf%lf%lf\\\", &x[i], &y[i], &z[i]);\\n\\t\\t}\\n\\t\\tdouble l = 0.0, r = 1e10;\\n\\t\\twhile (fabs(r - l) > eps) {\\n\\t\\t\\tdouble mid = (l + r) / 2;\\n\\t\\t\\tif (prim(mid) >= eps) {\\n\\t\\t\\t\\tl = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\\\"%.3lf\\\\n\\\", l);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621606137069.jpg\",\"articleTitle\":\"分数规划入门\",\"categoryId\":15,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[38,24]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 22:10:26');
INSERT INTO `tb_operation_log` VALUES (129, '友链模块', '新增或修改', '/admin/links', 'top.bravecoder.blog.controller.FriendLinkController.saveOrUpdateFriendLink', '保存或修改友链', '[{\"linkAddress\":\"https://onestar.newstar.net.cn/\",\"linkAvatar\":\"https://onestar.newstar.net.cn/images/me.jpg\",\"linkIntro\":\"欢迎来到我的客栈，我是一颗星，夜空中最亮的那颗\",\"linkName\":\"ONESTARの客栈\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 22:58:51');
INSERT INTO `tb_operation_log` VALUES (130, '文章模块', '修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[66],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 23:12:57');
INSERT INTO `tb_operation_log` VALUES (131, '文章模块', '删除', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[66,60]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功！\"}', 1, 'zhang、', '58.243.254.186', '安徽省合肥市 联通', '2021-05-21 23:13:04');
INSERT INTO `tb_operation_log` VALUES (132, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"## [问题 A: 机器人足球](https://acm.webturing.com/problem.php?cid=1355&pid=0&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n足球场地长为100,宽为20,对方的球门坐标为(100,10),你要控制一个个机器人踢球，初始位置为(x,y).机器人可以朝任何方向移动，但不能超出场地边界，当机器人与球门距离不超过10时，可以射门。 问机器人从初始位置出发到射门，最少要移动多少距离? (四舍五人到小数点后3位)\\n\\n**输入**\\n\\n每组输人为2个整数，分别为x ,y\\n0<= x<=100\\n0<= y<=20\\n\\n**输出**\\n\\n输出最小移动的距离\\n\\n**样例输入**\\n\\n```c++\\n10 10\\n1\\n```\\n\\n**样例输出**\\n\\n```c++\\n80.000\\n```\\n\\n**题解:** 到球门中心的距离减去半径10\\n\\n```c++\\n#include<stdio.h>\\n#include<math.h>\\n\\nint main() {\\n\\tint x, y;\\n\\tscanf(\\\"%d%d\\\", &x, &y);\\n\\tdouble s = sqrt((x-100)*(x-100) + (y-10)*(y-10));\\n\\tprintf(\\\"%.3lf\\\\n\\\", s - 10);\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 B: 纸牌识别](https://acm.webturing.com/problem.php?cid=1355&pid=1&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\nAlice沉迷于机器人研究，他打算做- - 个机器人来检查-副扑克是否完整。现在，他想请你帮他写-一个程序，来识别纸牌，每张纸牌都有-个花色(四种花色，分别用大写字母P，K, H, T表示)和一一个数字点数(1-13) .纸牌可以用ABC的形式来表示，A代表花色，BC代表数字，如果数字小于10，会有一位补0.\\n​ 比如花色是P,数字是9的纸牌会表示成P09.一副完整的纸牌有52张牌，四种不同的花色各有1张数字1-13的牌.你的程序要读人一个字符串，表示缺少的纸牌有哪些。如果包含相同的纸牌(花色数字都相同)输出GRESKA,否则输出每种花色剩余的纸牌数量。\\n\\n**输入**\\n\\n输人只有一行，一个字符串S, S的长度长度小于等于1000\\n\\n**输出**\\n\\n如果输人中包含相同的纸牌，输出GRESKA,否则分别输出四个整数，代表P,K, H, T四种花色纸牌的剩余数量\\n\\n**样例输入**\\n\\n```c++\\nP01K02H03H04\\n1\\n```\\n\\n**样例输出**\\n\\n```c++\\n12 12 11 13\\n```\\n\\n**题解**: 模拟，利用四个数组分别表示四种花色牌的状态，对输入的字符串每3个字符一组进行判断，判断对应花色的牌是否存在，若不存在，将对应下标的数组置 1，对应花色的数量减 1，否则输出 GRESKA。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n// 分别代表四种花色对应牌是否已经含有 \\nint c1[14], c2[14], c3[14], c4[14];\\nchar str[1005];\\n// 分别表示四种花色的牌的数量 \\nint s1 = 13, s2 = 13, s3 = 13, s4 = 13; \\nint flag;\\n\\nint main() {\\n\\tcin>>str;\\n\\tfor (int i = 0; i < 14; i++) {\\n\\t\\tc1[i] = 0;\\n\\t\\tc2[i] = 0;\\n\\t\\tc3[i] = 0;\\n\\t\\tc4[i] = 0;\\t\\n\\t}\\n\\tint i = 0;\\n\\tint len = strlen(str);\\n\\tflag = 0;\\n\\twhile (i < len)\\t{\\n\\t\\tint num;\\n\\t\\tnum = (str[i+1] - \'0\') * 10 + str[i+2] - \'0\';\\n\\t\\tif (str[i] == \'P\') {\\n\\t\\t\\tif (c1[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc1[num] = 1;\\n\\t\\t\\t\\ts1--;\\n\\t\\t\\t}\\n\\t\\t} else if (str[i] == \'K\') {\\n\\t\\t\\tif (c2[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc2[num] = 1;\\n\\t\\t\\t\\ts2--;\\n\\t\\t\\t}\\n\\t\\t} else if (str[i] == \'H\') {\\n\\t\\t\\tif (c3[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc3[num] = 1;\\n\\t\\t\\t\\ts3--;\\n\\t\\t\\t}\\n\\t\\t} else if (str[i] == \'T\') {\\n\\t\\t\\tif (c4[num] != 0) {\\n\\t\\t\\t\\tcout<<\\\"GRESKA\\\"<<endl;\\n\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc4[num] = 1;\\n\\t\\t\\t\\ts4--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ti += 3;\\n\\t}\\n\\tif (!flag) {\\n\\t\\tcout<<s1<<\\\" \\\"<<s2<<\\\" \\\"<<s3<<\\\" \\\"<<s4<<endl;\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 C: 卡牌对决](https://acm.webturing.com/problem.php?cid=1355&pid=2&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n有2N张牌，它们的点数分别为1到2N。Alice拿了其中的N张，Bob拿了剩下的N张. Alice和Bob会进行N轮游戏，在每轮游戏中，Alice 和Bob 各出一张牌。出了的牌不能收回。在前N/2轮中，每轮谁的牌点数大谁就赢;在后N/2轮中，每轮谁的牌点数小谁就赢。已知Bob 每一轮会出什么牌，试求Alice 最多能赢多少轮。\\n\\n**输入**\\n\\n第一行是一个整数N,\\n接下来N行，每行一个整数，表示Bob这轮会出什么。\\n2<=N <= 50000,保证N是偶数\\n\\n**输出**\\n\\n输出Alice最多能赢几轮\\n\\n**样例输入**\\n\\n```c++\\n4\\n1\\n8\\n4\\n3\\n1\\n2\\n3\\n4\\n5\\n```\\n\\n**样例输出**\\n\\n```c++\\n2\\n```\\n\\n**题解**: 贪心，先把 b 的牌分成前 N/2 和 后 N/2，再根据 b 的牌得出 a 的牌，对 a、b的牌升序排列。因为前 N/2 轮，a 的牌大于 b 的牌，a 胜利，所以，用 a 的后 N/2 张牌（a 的较大值）与 b 的前 N/2 张牌（b 的较小值）进行比较；对于后 N/2 轮，则反过来。\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nint s[100001];  // 全部的牌 \\nint a[50001]; // Alice 的牌 \\nint b1[25001]; // Bob 前 N/2 的牌 \\nint b2[25001]; // Bob 后 N/2 的牌 \\nint N;\\n\\nint main() {\\n\\tint x, y;\\n\\tcin>>N;\\n\\tfor (int i = 1; i <= 2*N; i++) {\\n\\t\\ts[i] = i;\\n\\t}\\n\\tmemset(b1, 0, sizeof(b1));\\n\\tmemset(b2, 0, sizeof(b2));\\n\\t// 输入 Bob 的牌 \\n\\tfor (int i = 1, j = 1, k = 1; i <= N; i++) {\\n\\t\\tif (i <= N/2) {\\n\\t\\t\\tcin>>x;\\n\\t\\t\\tb1[j++] = x;\\n\\t\\t\\ts[x] = 0;\\n\\t\\t} else {\\n\\t\\t\\tcin>>y;\\n\\t\\t\\tb2[k++] = y;\\n\\t\\t\\ts[y] = 0;\\n\\t\\t}\\n\\t}\\n\\t// 根据 Bob 的牌和全部的牌得出 Alice 的牌 \\n\\tfor (int i = 1, k = 1; i <= 2*N; i++) {\\n\\t\\tif (s[i]) {\\n\\t\\t\\ta[k++] = s[i];\\n\\t\\t}\\n\\t}\\n\\t// 各自的牌都升序排列 \\n\\tsort(a + 1, a + N + 1);\\n\\tsort(b2 + 1, b2 + N/2 + 1);\\n\\tsort(b1 + 1, b1 + N/2 + 1);\\n\\tint count = 0;\\n\\t// a 的后 N/2 与 b 的前 N/2 比较，a > b 胜 \\n\\t// a 的后 N/2 是 a 的较大值，b 的前 N/2 是 b 的较小值 \\n\\tint i = N/2 + 1;\\n\\tint j = 1;\\n\\twhile (i <= N && j <= N/2) {\\n\\t\\tif (a[i] > b1[j]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t} else {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n\\t// a 的前 N/2 与 b 的后 N/2 比较，a < b 胜 \\n\\t// a 的较小值与 b 的较大值 \\n\\ti = N/2;\\n\\tj = N/2;\\n\\twhile (i >= 1 && j >= 1) {\\n\\t\\tif (a[i] < b2[j]) {\\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t\\tcount++;\\n\\t\\t} else {\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t}\\n\\tcout<<count<<endl;\\n\\treturn 0;\\n}\\n```\\n\\n\\n## [问题 H: 不要回文](https://acm.webturing.com/problem.php?cid=1355&pid=7&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n给出一个字符串 S，你需要尽可能少的修改 S 中的字符， 使得 S 不包含长度大于等于 2 的回文子串。\\n\\n**输入**\\n\\n输入的第一行是一个字符串 S， S只包含小写字母\\nS 的长度大于 5 小于 300\\n\\n**输出**\\n\\n输出使得 S 中不包含长度大于等于 2 的回文， 最少需要修改几个字符 （可以修改成任意字符）\\n\\n**样例输入**\\n\\n```c++\\nabbaa\\n1\\n```\\n\\n**样例输出**\\n\\n```c++\\n2\\n```\\n\\n**题解**: 贪心\\n\\n+ 把字符串中的字符转化成数字\\n+ 进行两轮扫描，第一轮消除 3个字符的回文；第二轮消除 2个字符的回文\\n+ 消除回文时，对**可能构成多个回文的字符**进行重新赋值，赋值一个不存在的数字即可\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint a[305], ans = 0;\\nint t = 30;\\nstring s;\\n\\nint main() {\\n\\tcin>>s;\\n\\tint len = s.length();\\n\\t// 把字符串的字符转化成数字 \\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\ta[i+1] = s[i] - \'a\' + 1;\\n\\t}\\n\\t// 第一轮扫描，消除 3个字符的回文 \\n\\tfor (int i = 1; i <= len - 2; i++) {\\n \\t  \\tif (a[i] == a[i+2]) { \\n \\t  \\t\\tif (a[i] == a[i-1]) { \\n \\t  \\t\\t\\ta[i] = t++;\\n \\t  \\t\\t\\tans++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta[i+2] = t++;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// 第二轮扫描，消除 2个字符的回文 \\n\\tfor (int i = 1; i <= len - 1; i++) {\\n\\t\\tif (a[i] == a[i+1]) {\\n\\t\\t\\ta[i+1] = t++;\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t}\\n\\tcout<<ans;\\n\\treturn 0;\\n}\\n```\\n\\n## [问题 I: 你的名字](https://acm.webturing.com/problem.php?cid=1355&pid=8&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n​ Alice 想要计算他那 N 只猫的名字的价值每只猫的名字由不超过 1000 个大小写字母构成，没有一个名字是空字体串。 Alice有一张*价值字符串表”， 上面有 M个代表价值的字符串。每个字符串由不超过30个大小写字母构成，同样不存在空字符串。一个猫的名字蕴含多少个价值字符串，这个名字就有多少价值，所谓 “蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现 (不一定一个紧接着一个) .\\n​ 所有的大写字母和小写字母都是等价的。比如，在贝黄的名字\\\"Bessie\\\"里， 蕴含有 “Be” “si” “EE” 以及 “Es” 等等字符串，但不蕴含\\\"Ls°或\\\"eB\\\"请帮Alice计算他的猫的名字的价值.\\n\\n**输入**\\n\\n输人的第-行是两个整数 N M\\n接下来N行，每行一个字符串表示猫的名字。\\n接下来M行，每行一个价值字符串\\n1 <=N<= 1000\\n1 <= M<=100\\n\\n**输出**\\n\\n输出每只猫蕴含多少个价值字符串。\\n\\n**样例输入**\\n\\n```c++\\n5 3\\nBessie\\nJonathan\\nMontgomery\\nAlicia\\nAngola\\nSe  \\nnGo  \\noNt\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n```\\n\\n**样例输出**\\n\\n```c++\\n1\\n1\\n2\\n0\\n1\\n```\\n\\n**题解**: 暴力，对每个名字，在价值字符串中扫描\\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nchar cat[1005][1005];\\nchar val[105][35];\\nint n, m;\\n\\nint main() {\\n\\tcin>>n>>m;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tcin>>cat[i];\\n\\t\\tint len = strlen(cat[i]);\\n\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\tcat[i][j] = tolower(cat[i][j]); // 转化为小写 \\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tcin>>val[i];\\n\\t\\tint len = strlen(val[i]);\\n\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\tval[i][j] = tolower(val[i][j]); // 转化为小写 \\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {  // 名字循环\\n\\t\\tint count = 0;\\n\\t\\tfor (int j = 0; j < m; j++) { // 价值循环（多个价值字符串）\\n\\t\\t\\tint lenCat = strlen(cat[i]);\\n\\t\\t\\tint lenVal = strlen(val[j]);\\n\\t\\t\\tint p = 0, flag = 0;\\n\\t\\t\\tfor (int k = 0; k < lenVal; k++) { // 价值字符串长度\\n\\t\\t\\t\\twhile (p < lenCat && cat[i][p] != val[j][k]) {\\n\\t\\t\\t\\t\\tp++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (p == lenCat) {\\n\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp++;\\n\\t\\t\\t}\\n\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcout<<count<<endl;\\n\\t}\\n\\treturn 0;\\n} \\n```\\n\\n## [问题 L: 曲奇工厂](https://acm.webturing.com/problem.php?cid=1355&pid=11&langmask=262141&puzzle_mask=0)\\n\\n**题目描述**\\n\\n曲奇工厂是一个经典好玩的益智游戏，游戏中你的目标是生产至少 C 块曲奇:游戏的规则十分简单; 游戏开始时你有 0 块曲奇，每分钟可以手工作出 S 块曲奇。你也可以从 N 个工厂中选择些买下来; 工厂依次编号为 1-N ,买下第 i 个工厂需要花费 Ai 个曲奇饼。但是工厂会为你带来更多收益，买下第 i 个工厂后，每分钟曲奇产出会增加 Bi 块。\\n对于每个工厂，你只能买一次: 你只能在整数分钟时购买工厂，并且可以一次买多个工厂, 请问达成日标所用最短时间是多少?\\n\\n**输入**\\n\\n输人的第一行是三个整数 N, C 和 S\\n接下来 N 行，每行两个整数 Ai 和 Bi\\n1 <=N<= 5\\n1<= C, S, Ai, Bi <=.10^5\\n\\n**输出**\\n\\n输出得到至少C块曲奇,最少要多长时间。\\n\\n**样例输入**\\n\\n```c++\\n2 18 1\\n6 2\\n5 1\\n1\\n2\\n3\\n```\\n\\n**样例输出**\\n\\n```c++\\n12\\n```\\n\\n**题解**: 求出工厂的全排列，依次按每种排列进行生产曲奇，每种排列中依次增加工厂，并计算每次需要花费的时间，这样所有情况都涉及到，取最小的时间即可。\\n\\n**技巧**：对工厂数组的下标进行全排列，也可以得到工厂数组的全排列。\\n\\n```c++\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nint n, c, s, ans;\\nint a[5], b[5];\\nint f[5] = {0, 1, 2, 3, 4};\\n\\nint main() {\\n    cin >> n >> c >> s;\\n    for (int i = 0; i < n; i++) {\\n    \\tcin >> a[i] >> b[i];\\n\\t}\\n    ans = 0x3f3f3f3f;\\n    do {\\n        int i, j, k, t, w, val;\\n        // (c + s - 1) / S 不使用工厂完成任务需要花费的时间 \\n        ans = min(ans, (c + s - 1) / s);\\n        for (j = f[i = 0], t = val = 0, w = s; i < n; i++, j = f[i]) {\\n        \\t// 买 j 工厂需要花费多长时间 \\n            k = max(0, a[j] - val + w - 1) / w;\\n            // 花费的时间增加 \\n            t += k;\\n            // 买工厂后剩余的曲奇饼 \\n\\t\\t\\tval += k * w - a[j];\\n\\t\\t\\t// 买工厂后，每分钟能做出的曲奇饼数量增加了 \\n\\t\\t\\tw += b[j];\\n\\t\\t\\t// 有该工厂后，完成任务需要多少时间，更新 ans \\n            ans = min(ans, t + max(0, (c - val + w - 1) / w));\\n        }\\n    } while (next_permutation(f, f + n));\\n    cout << ans << endl;\\n    return 0;\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621603583016.jpg\",\"articleTitle\":\"2019年安徽省程序设计大赛题解\",\"categoryId\":15,\"id\":64,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[26,22]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.241', '安徽省合肥市 联通', '2021-05-22 22:38:16');
INSERT INTO `tb_operation_log` VALUES (133, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [206.反转链表 (简单)](https://leetcode-cn.com/problems/reverse-linked-list/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode pre = null;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode temp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return pre;\\n    }\\n}\\n```\\n**递归实现**\\n\\n```c++\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n}\\n```\\n\\n举个例子就容易明白了\\n\\n\\n```c++\\n1->2->3->4->5->null\\n(head)1->reverseList(2->3->4->5->null) //  ListNode newHead = reverseList(head.next);\\n(head)1->2<-3<-4<-5(newHead) // reverseList(head.next)执行完后\\n(head)1<-2<-3<-4<-5(newHead) // head.next.next = head\\nnull<-(head)1<-2<-3<-4<-5(newHead)  // head.next = null\\n```\\n\\n### [92. 反转链表 II (中等)](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\\n\\n**非递归**\\n\\n```c++\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for (int i = 1; i < left; i++) {\\n            pre = pre.next;\\n        }\\n        ListNode cur = pre.next;\\n        for (int i = left; i < right; i++) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**递归版**\\n\\n```c++\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (left == 1) { // left = 1,相当于反转前 right 个节点\\n            return reverseN(head, right);\\n        }\\n        // head.next 为第一个节点，则反转区间从 left - 1 开始，right - 1 结束\\n        head.next = reverseBetween(head.next, left - 1, right - 1);\\n        return head;\\n    }\\n\\n    private ListNode successor = null; // 后继节点\\n\\n    // 反转以 head 为起点的 n 个节点，返回新的头节点\\n    public ListNode reverseN(ListNode head, int n) {\\n        if (n == 1) {\\n            successor = head.next; // 记录后继节点\\n            return head;\\n        }\\n        ListNode newHead = reverseN(head.next, n - 1);\\n        head.next.next = head;\\n        head.next = successor;\\n        return newHead;\\n    }\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621698039364.jpg\",\"articleTitle\":\"反转链表和反转链表II\",\"categoryId\":14,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.241', '安徽省合肥市 联通', '2021-05-22 23:40:43');
INSERT INTO `tb_operation_log` VALUES (134, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [206.反转链表 (简单)](https://leetcode-cn.com/problems/reverse-linked-list/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode pre = null;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode temp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return pre;\\n    }\\n}\\n```\\n**递归实现**\\n\\n```c++\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n}\\n```\\n\\n举个例子就容易明白了\\n\\n\\n```c++\\n1->2->3->4->5->null\\n(head)1->reverseList(2->3->4->5->null) //  ListNode newHead = reverseList(head.next);\\n(head)1->2<-3<-4<-5(newHead) // reverseList(head.next)执行完后\\n(head)1<-2<-3<-4<-5(newHead) // head.next.next = head\\nnull<-(head)1<-2<-3<-4<-5(newHead)  // head.next = null\\n```\\n\\n### [92. 反转链表 II (中等)](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\\n\\n**非递归**\\n\\n```c++\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for (int i = 1; i < left; i++) {\\n            pre = pre.next;\\n        }\\n        ListNode cur = pre.next;\\n        for (int i = left; i < right; i++) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**递归版**\\n\\n```c++\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (left == 1) { // left = 1,相当于反转前 right 个节点\\n            return reverseN(head, right);\\n        }\\n        // head.next 为第一个节点，则反转区间从 left - 1 开始，right - 1 结束\\n        head.next = reverseBetween(head.next, left - 1, right - 1);\\n        return head;\\n    }\\n\\n    private ListNode successor = null; // 后继节点\\n\\n    // 反转以 head 为起点的 n 个节点，返回新的头节点\\n    public ListNode reverseN(ListNode head, int n) {\\n        if (n == 1) {\\n            successor = head.next; // 记录后继节点\\n            return head;\\n        }\\n        ListNode newHead = reverseN(head.next, n - 1);\\n        head.next.next = head;\\n        head.next = successor;\\n        return newHead;\\n    }\\n}\\n```\\n### [25. K 个一组翻转链表 (困难)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\\n\\n```c++\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode p1 = head, p2 = head;\\n        for (int i = 0; i < k; i++) {\\n            if (p2 == null) {  // 不足 k 个直接返回\\n                return head;\\n            }\\n            p2 = p2.next;\\n        }\\n        ListNode newHead = reverse(p1, p2);\\n        p1.next = reverseKGroup(p2, k); // p1.next 指向后面反转的结果\\n        return newHead;\\n    }\\n\\n    // 反转 p1 和 p2 之间的节点，左闭右开\\n    public ListNode reverse(ListNode p1, ListNode p2) {\\n        ListNode pre = null;\\n        ListNode cur = p1;\\n        while (cur != p2) {\\n            ListNode curNext = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = curNext;\\n        }\\n        return pre;\\n    }\\n}\\n\\n\\n // 解法二\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int len = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            cur = cur.next;\\n            len++;\\n        }\\n        // 1->2->3->4->5  k = 3\\n        // 2->1->3->4->5\\n        // 3->2->1->4->5\\n        ListNode pre = dummy, curNext = null;\\n        cur = head;\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                curNext = cur.next;\\n                cur.next = curNext.next;\\n                curNext.next = pre.next;\\n                pre.next = curNext;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621698039364.jpg\",\"articleTitle\":\"力扣刷题笔记之反转链表系列\",\"categoryId\":14,\"id\":67,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.241', '安徽省合肥市 联通', '2021-05-22 23:58:01');
INSERT INTO `tb_operation_log` VALUES (135, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [206.反转链表 (简单)](https://leetcode-cn.com/problems/reverse-linked-list/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode pre = null;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode temp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return pre;\\n    }\\n}\\n```\\n**递归实现**\\n\\n```java\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n}\\n```\\n\\n举个例子就容易明白了\\n\\n\\n```bash\\n1->2->3->4->5->null\\n(head)1->reverseList(2->3->4->5->null) //  ListNode newHead = reverseList(head.next);\\n(head)1->2<-3<-4<-5(newHead) // reverseList(head.next)执行完后\\n(head)1<-2<-3<-4<-5(newHead) // head.next.next = head\\nnull<-(head)1<-2<-3<-4<-5(newHead)  // head.next = null\\n```\\n\\n### [92. 反转链表 II (中等)](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for (int i = 1; i < left; i++) {\\n            pre = pre.next;\\n        }\\n        ListNode cur = pre.next;\\n        for (int i = left; i < right; i++) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**递归版**\\n\\n```java\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (left == 1) { // left = 1,相当于反转前 right 个节点\\n            return reverseN(head, right);\\n        }\\n        // head.next 为第一个节点，则反转区间从 left - 1 开始，right - 1 结束\\n        head.next = reverseBetween(head.next, left - 1, right - 1);\\n        return head;\\n    }\\n\\n    private ListNode successor = null; // 后继节点\\n\\n    // 反转以 head 为起点的 n 个节点，返回新的头节点\\n    public ListNode reverseN(ListNode head, int n) {\\n        if (n == 1) {\\n            successor = head.next; // 记录后继节点\\n            return head;\\n        }\\n        ListNode newHead = reverseN(head.next, n - 1);\\n        head.next.next = head;\\n        head.next = successor;\\n        return newHead;\\n    }\\n}\\n```\\n### [25. K 个一组翻转链表 (困难)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode p1 = head, p2 = head;\\n        for (int i = 0; i < k; i++) {\\n            if (p2 == null) {  // 不足 k 个直接返回\\n                return head;\\n            }\\n            p2 = p2.next;\\n        }\\n        ListNode newHead = reverse(p1, p2);\\n        p1.next = reverseKGroup(p2, k); // p1.next 指向后面反转的结果\\n        return newHead;\\n    }\\n\\n    // 反转 p1 和 p2 之间的节点，左闭右开\\n    public ListNode reverse(ListNode p1, ListNode p2) {\\n        ListNode pre = null;\\n        ListNode cur = p1;\\n        while (cur != p2) {\\n            ListNode curNext = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = curNext;\\n        }\\n        return pre;\\n    }\\n}\\n\\n\\n // 解法二\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int len = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            cur = cur.next;\\n            len++;\\n        }\\n        // 1->2->3->4->5  k = 3\\n        // 2->1->3->4->5\\n        // 3->2->1->4->5\\n        ListNode pre = dummy, curNext = null;\\n        cur = head;\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                curNext = cur.next;\\n                cur.next = curNext.next;\\n                curNext.next = pre.next;\\n                pre.next = curNext;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621698039364.jpg\",\"articleTitle\":\"力扣刷题笔记之反转链表系列\",\"categoryId\":14,\"id\":67,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-23 09:44:17');
INSERT INTO `tb_operation_log` VALUES (136, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [206.反转链表 (简单)](https://leetcode-cn.com/problems/reverse-linked-list/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\n// 解法一\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode pre = null;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode temp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return pre;\\n    }\\n}\\n\\n// 解法二\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy, cur = head;\\n        while (cur.next != null) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**递归实现**\\n\\n```java\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n}\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy, cur = head;\\n        while (cur.next != null) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n举个例子就容易明白了\\n\\n\\n```bash\\n1->2->3->4->5->null\\n(head)1->reverseList(2->3->4->5->null) //  ListNode newHead = reverseList(head.next);\\n(head)1->2<-3<-4<-5(newHead) // reverseList(head.next)执行完后\\n(head)1<-2<-3<-4<-5(newHead) // head.next.next = head\\nnull<-(head)1<-2<-3<-4<-5(newHead)  // head.next = null\\n```\\n\\n### [92. 反转链表 II (中等)](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for (int i = 1; i < left; i++) {\\n            pre = pre.next;\\n        }\\n        ListNode cur = pre.next;\\n        for (int i = left; i < right; i++) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**递归版**\\n\\n```java\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (left == 1) { // left = 1,相当于反转前 right 个节点\\n            return reverseN(head, right);\\n        }\\n        // head.next 为第一个节点，则反转区间从 left - 1 开始，right - 1 结束\\n        head.next = reverseBetween(head.next, left - 1, right - 1);\\n        return head;\\n    }\\n\\n    private ListNode successor = null; // 后继节点\\n\\n    // 反转以 head 为起点的 n 个节点，返回新的头节点\\n    public ListNode reverseN(ListNode head, int n) {\\n        if (n == 1) {\\n            successor = head.next; // 记录后继节点\\n            return head;\\n        }\\n        ListNode newHead = reverseN(head.next, n - 1);\\n        head.next.next = head;\\n        head.next = successor;\\n        return newHead;\\n    }\\n}\\n```\\n### [25. K 个一组翻转链表 (困难)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode p1 = head, p2 = head;\\n        for (int i = 0; i < k; i++) {\\n            if (p2 == null) {  // 不足 k 个直接返回\\n                return head;\\n            }\\n            p2 = p2.next;\\n        }\\n        ListNode newHead = reverse(p1, p2);\\n        p1.next = reverseKGroup(p2, k); // p1.next 指向后面反转的结果\\n        return newHead;\\n    }\\n\\n    // 反转 p1 和 p2 之间的节点，左闭右开\\n    public ListNode reverse(ListNode p1, ListNode p2) {\\n        ListNode pre = null;\\n        ListNode cur = p1;\\n        while (cur != p2) {\\n            ListNode curNext = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = curNext;\\n        }\\n        return pre;\\n    }\\n}\\n\\n\\n // 解法二\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int len = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            cur = cur.next;\\n            len++;\\n        }\\n        // 1->2->3->4->5  k = 3\\n        // 2->1->3->4->5\\n        // 3->2->1->4->5\\n        ListNode pre = dummy, curNext = null;\\n        cur = head;\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                curNext = cur.next;\\n                cur.next = curNext.next;\\n                curNext.next = pre.next;\\n                pre.next = curNext;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621698039364.jpg\",\"articleTitle\":\"力扣刷题笔记之反转链表系列\",\"categoryId\":14,\"id\":67,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-23 10:09:49');
INSERT INTO `tb_operation_log` VALUES (137, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [206.反转链表 (简单)](https://leetcode-cn.com/problems/reverse-linked-list/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\n// 解法一\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode pre = null;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode temp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return pre;\\n    }\\n}\\n\\n// 解法二\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy, cur = head;\\n        while (cur.next != null) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**递归实现**\\n\\n```java\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n}\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy, cur = head;\\n        while (cur.next != null) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n举个例子就容易明白了\\n\\n\\n```bash\\n1->2->3->4->5->null\\n(head)1->reverseList(2->3->4->5->null) #  ListNode newHead = reverseList(head.next);\\n(head)1->2<-3<-4<-5(newHead) # reverseList(head.next)执行完后\\n(head)1<-2<-3<-4<-5(newHead) # head.next.next = head\\nnull<-(head)1<-2<-3<-4<-5(newHead)  # head.next = null\\n```\\n\\n### [92. 反转链表 II (中等)](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\\n\\n**非递归**\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for (int i = 1; i < left; i++) {\\n            pre = pre.next;\\n        }\\n        ListNode cur = pre.next;\\n        for (int i = left; i < right; i++) {\\n            ListNode curNext = cur.next;\\n            cur.next = curNext.next;\\n            curNext.next = pre.next;\\n            pre.next = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**递归版**\\n\\n```java\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (left == 1) { // left = 1,相当于反转前 right 个节点\\n            return reverseN(head, right);\\n        }\\n        // head.next 为第一个节点，则反转区间从 left - 1 开始，right - 1 结束\\n        head.next = reverseBetween(head.next, left - 1, right - 1);\\n        return head;\\n    }\\n\\n    private ListNode successor = null; // 后继节点\\n\\n    // 反转以 head 为起点的 n 个节点，返回新的头节点\\n    public ListNode reverseN(ListNode head, int n) {\\n        if (n == 1) {\\n            successor = head.next; // 记录后继节点\\n            return head;\\n        }\\n        ListNode newHead = reverseN(head.next, n - 1);\\n        head.next.next = head;\\n        head.next = successor;\\n        return newHead;\\n    }\\n}\\n```\\n### [25. K 个一组翻转链表 (困难)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode p1 = head, p2 = head;\\n        for (int i = 0; i < k; i++) {\\n            if (p2 == null) {  // 不足 k 个直接返回\\n                return head;\\n            }\\n            p2 = p2.next;\\n        }\\n        ListNode newHead = reverse(p1, p2);\\n        p1.next = reverseKGroup(p2, k); // p1.next 指向后面反转的结果\\n        return newHead;\\n    }\\n\\n    // 反转 p1 和 p2 之间的节点，左闭右开\\n    public ListNode reverse(ListNode p1, ListNode p2) {\\n        ListNode pre = null;\\n        ListNode cur = p1;\\n        while (cur != p2) {\\n            ListNode curNext = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = curNext;\\n        }\\n        return pre;\\n    }\\n}\\n\\n\\n // 解法二\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k < 2) {\\n            return head;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int len = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            cur = cur.next;\\n            len++;\\n        }\\n        // 1->2->3->4->5  k = 3\\n        // 2->1->3->4->5\\n        // 3->2->1->4->5\\n        ListNode pre = dummy, curNext = null;\\n        cur = head;\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                curNext = cur.next;\\n                cur.next = curNext.next;\\n                curNext.next = pre.next;\\n                pre.next = curNext;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621698039364.jpg\",\"articleTitle\":\"力扣刷题笔记之反转链表系列\",\"categoryId\":14,\"id\":67,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-23 10:12:42');
INSERT INTO `tb_operation_log` VALUES (138, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [234. 回文链表 (简单)](https://leetcode-cn.com/problems/palindrome-linked-list/)\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n// 递归\\nclass Solution {\\n    private ListNode left;\\n    public boolean isPalindrome(ListNode head) {\\n        left = head;\\n        return traverse(head.next);\\n    }\\n\\n    public boolean traverse(ListNode right) {\\n        if (right == null) {\\n            return true;\\n        }\\n        boolean res = traverse(right.next);\\n        res = res && (left.val == right.val);\\n        left = left.next;\\n        return res;\\n    }\\n}\\n\\n// 非递归，把后半部分反转，再与前半段比较\\nclass Solution {\\n    public boolean isPalindrome(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return true;\\n        }\\n        ListNode fast = head, slow = head;\\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        ListNode preTail = slow; \\n        ListNode head2 = reverse(slow.next);\\n        ListNode left = head;\\n        ListNode right = head2;\\n        while (right != null) {\\n            if (left.val != right.val) {\\n                return false;\\n            }\\n            left = left.next;\\n            right = right.next;\\n        }\\n        // preTail.next = reverse(head2); // 恢复链表\\n        return true;\\n    }\\n\\n    public ListNode reverse(ListNode head) {\\n        ListNode pre = null;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode curNext = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = curNext;\\n        }\\n        return pre;\\n    }\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621774751117.jpg\",\"articleTitle\":\"力扣 234. 回文链表 (简单)\",\"categoryId\":14,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[28]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.23', '安徽省合肥市 联通', '2021-05-23 20:59:15');
INSERT INTO `tb_operation_log` VALUES (139, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [226. 翻转二叉树 (简单)](https://leetcode-cn.com/problems/invert-binary-tree/)\\n\\n```c++\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n// 前序遍历\\nclass Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        /* 前序遍历位置 */\\n        // 交换 root 的左右子节点\\n        TreeNode temp = root.left;\\n        root.left = root.right;\\n        root.right = temp;\\n        // 左右子节点继续翻转\\n        invertTree(root.left);\\n        invertTree(root.right);\\n        return root;\\n    }\\n}\\n\\n// 后序遍历\\nclass Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        // 左右子节点翻转\\n        invertTree(root.left);\\n        invertTree(root.right);\\n\\n        /* 后序遍历位置 */\\n        // 交换 root 的左右子节点\\n        TreeNode temp = root.left;\\n        root.left = root.right;\\n        root.right = temp;\\n        return root;\\n    }\\n}\\n\\n// 中序遍历\\nclass Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        // 递归翻转左子树\\n        invertTree(root.left);\\n    \\n        /* 中序序遍历位置 */\\n        // 交换 root 的左右子节点\\n        TreeNode temp = root.left;\\n        root.left = root.right;\\n        root.right = temp;\\n\\t    // 递归反转右子树，注意：这里是 root.left，因为上面的代码把左右节点互换了\\n        // 此时的 root.left 就是原先的 root.right\\n        invertTree(root.left);\\n        return root;\\n    }\\n}\\n\\n// 层次遍历\\nclass Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            TreeNode right = node.right;\\n            node.right = node.left;\\n            node.left = right;\\n            if (node.left != null) {\\n                q.offer(node.left);\\n            }\\n            if (node.right != null) {\\n                q.offer(node.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n### [116. 填充每个节点的下一个右侧节点指针 (中等)](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)\\n\\n```java\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\n// 递归前序遍历写法\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n\\n    public void connectTwoNodes(Node left, Node right) {\\n        if (left == null || right == null) {\\n            return;\\n        }\\n        /* 前序遍历位置 */\\n        // 连接传入的两个节点\\n        left.next = right;\\n        // 连接具有相同父结点的两个子节点\\n        connectTwoNodes(left.left, left.right);\\n        connectTwoNodes(right.left, right.right);\\n        // 连接具有不同父结点的两个子节点\\n        connectTwoNodes(left.right, right.left);\\n    }\\n}\\n\\n/*\\n\\t递归，前序遍历\\n\\t1.通过父节点来连接子节点 \\n\\t2.通过父节点的 next 域来进行不同父节点的字节点的连接\\n*/\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) {\\n            return root;\\n        }\\n        // root 的左子节点连接右子节点\\n        root.left.next = root.right;\\n        // 通过父节点的 next 域来进行不同父节点的字节点的连接\\n        // root 是左父节点，root.next 是右父节点\\n        if (root.next != null) {\\n            // root.right 是左父节点的右子节点，root.next.left 是右父结点的左子节点\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n\\n// 层次遍历\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n        // 初始化队列同时将第一层节点加入队列中，即根节点\\n        Queue<Node> queue = new LinkedList<Node>(); \\n        queue.offer(root);\\n        // 外层的 while 循环迭代的是层数\\n        while (!queue.isEmpty()) {\\n            // 记录当前队列大小\\n            int size = queue.size();\\n            // 遍历这一层的所有节点\\n            for (int i = 0; i < size; i++) {\\n                // 从队首取出元素\\n                Node node = queue.poll();\\n                // 连接\\n                if (i < size - 1) {\\n                    node.next = queue.peek();\\n                }\\n                // 拓展下一层节点\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n        }\\n        // 返回根节点\\n        return root;\\n    }\\n}\\n```\\n\\n\\n\\n### [114. 二叉树展开为链表 (中等)](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        // 递归展开左子树和右子树\\n        flatten(root.left);\\n        flatten(root.right);\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n\\t    // 因为按照先序遍历顺序，所以将左子树变为右子树\\n        // 此时 root.right 连接的是展开后为链表的左子树\\n        root.right = left;\\n        root.left = null;\\n\\n        // 将原来的右子树接到新右子树的末端\\n        TreeNode cur = root;\\n        while (cur.right != null) {\\n            cur = cur.right;\\n        }\\n        cur.right = right;\\n    }\\n}\\n\\n// 先序遍历的逆序遍历，右左根\\nclass Solution {\\n    private TreeNode right = null;\\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = right;\\n        root.left = null;\\n        right = root;\\n    }\\n}\\n\\n// 用 list 记录先序遍历序列，再遍历 list 修改 left，right 指向\\nclass Solution {\\n    private List<TreeNode> list = new ArrayList<>();\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        preOrder(root);\\n        for (int i = 0; i < list.size() - 1; i++) {\\n            TreeNode pre = list.get(i);\\n            TreeNode next = list.get(i + 1);\\n            pre.right = next;\\n            pre.left = null;\\n        }\\n    }\\n\\n    public void preOrder(TreeNode root) {\\n        if (root != null) {\\n            list.add(root);\\n            preOrder(root.left);\\n            preOrder(root.right);\\n        }\\n    }\\n}\\n```\\n\\n\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621774962251.jpg\",\"articleTitle\":\"力扣刷题笔记之二叉树（一）\",\"categoryId\":14,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[37]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '58.243.250.23', '安徽省合肥市 联通', '2021-05-23 21:02:48');
INSERT INTO `tb_operation_log` VALUES (140, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [654. 最大二叉树 (中等)](https://leetcode-cn.com/problems/maximum-binary-tree/)\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        return build(nums, 0, nums.length - 1);\\n    }\\n\\n    public TreeNode build(int[] nums, int low, int high) {\\n        if (low > high) {\\n            return null;\\n        }\\n        int index = -1, maxVal = Integer.MIN_VALUE;\\n        for (int i = low; i <= high; i++) {\\n            if (nums[i] > maxVal) {\\n                maxVal = nums[i];\\n                index = i;\\n            }\\n        }\\n        TreeNode root = new TreeNode(maxVal);\\n        root.left = build(nums, low, index - 1);\\n        root.right = build(nums, index + 1, high);\\n        return root;\\n    }\\n}\\n```\\n\\n### [105. 从前序与中序遍历序列构造二叉树 (中等)](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // 存放中序序列中的值与下标的映射，方便查询\\n    private Map<Integer, Integer> map = new HashMap<>();\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        if (preorder.length == 0 || inorder.length == 0) {\\n            return null;\\n        }\\n        for (int i = 0; i < inorder.length; i++) {\\n            map.put(inorder[i], i);\\n        }\\n        return buildTreeHelper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);\\n    }   \\n    // 先序：根左右\\n    // 中序：左根右\\n    public TreeNode buildTreeHelper(int[] preorder, int preStart, int preEnd,\\n                                    int[] inorder, int inStart, int inEnd) {\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        // 根节点的值\\n        int rootVal = preorder[preStart];\\n        // 创建根节点\\n        TreeNode root = new TreeNode(rootVal);\\n        // 获取根节点在中序数组中的索引\\n        int rootIndex = map.get(rootVal);\\n        // 左子树的大小\\n        int leftSize = rootIndex - inStart;\\n        root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, \\n                                    inorder, inStart, rootIndex - 1);\\n        root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, \\n                                    inorder, rootIndex + 1, inEnd);\\n        return root;\\n    }\\n}\\n```\\n\\n### [106. 从中序与后序遍历序列构造二叉树 (中等)](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // 存放中序数组中值和索引的映射关系\\n    private Map<Integer, Integer> map = new HashMap<>();\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length == 0 && postorder.length == 0) {\\n            return null;\\n        }\\n        for (int i = 0; i < inorder.length; i++) {\\n            map.put(inorder[i], i);\\n        }\\n        return buildTreeHelper(inorder, 0, inorder.length-1, postorder,0,postorder.length-1);\\n    }\\n\\n    // 中序：左根右\\n    // 后序：左右根\\n    public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd,\\n                            int[] postorder, int postStart, int postEnd) {\\n        if (inStart > inEnd) {\\n            return null;\\n        }\\n        // 根节点的值\\n        int rootVal = postorder[postEnd];\\n        // 创建根节点\\n        TreeNode root = new TreeNode(rootVal);\\n        // 根节点在中序数组中的下标\\n        int rootIndex = map.get(rootVal);\\n        // 左子树的长度\\n        int leftSize = rootIndex - inStart;\\n        root.left = buildTreeHelper(inorder, inStart, rootIndex - 1, \\n                                postorder, postStart, postStart + leftSize - 1);\\n        root.right = buildTreeHelper(inorder, rootIndex + 1, inEnd,\\n                                postorder, postStart + leftSize, postEnd - 1);\\n        return root;\\n    }\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621926835942.jpg\",\"articleTitle\":\"力扣刷题笔记之二叉树（二）\",\"categoryId\":14,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[37]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-25 15:14:09');
INSERT INTO `tb_operation_log` VALUES (141, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [652. 寻找重复的子树 (中等)](https://leetcode-cn.com/problems/find-duplicate-subtrees/)\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // 存放所有子树出现的次数\\n    private Map<String, Integer> subTreeMap = new HashMap<>();\\n    // 存放重复子树的根节点\\n    private List<TreeNode> res = new ArrayList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n\\n    public String postTraverse(TreeNode root) {\\n        if (root == null) {\\n            return \\\"#\\\";\\n        }\\n        String left = postTraverse(root.left);\\n        String right = postTraverse(root.right);\\n        String subTree = left + \\\",\\\" + right + \\\",\\\" + root.val;\\n        int count = subTreeMap.getOrDefault(subTree, 0);\\n        if (count == 1) {\\n            res.add(root);\\n        }\\n        subTreeMap.put(subTree, count + 1);\\n        return subTree;\\n    }\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621928977041.jpg\",\"articleTitle\":\"力扣刷题笔记之二叉树（三）\",\"categoryId\":14,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[37]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-25 15:49:40');
INSERT INTO `tb_operation_log` VALUES (142, '标签模块', '新增或修改', '/admin/tags', 'top.bravecoder.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"二叉搜索树\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-25 15:50:20');
INSERT INTO `tb_operation_log` VALUES (143, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"### [230. 二叉搜索树中第K小的元素 (中等)](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int res = 0; // 结果\\n    private int rank = 0; // 排名\\n\\n    public int kthSmallest(TreeNode root, int k) {\\n        traverse(root, k);\\n        return res;\\n    }\\n\\n    // 二叉搜索树中序遍历是升序的\\n    public void traverse(TreeNode root, int k) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left, k);\\n        /* 中序遍历处理代码 */\\n        rank++;\\n        if (k == rank) {\\n            res = root.val;\\n            return;\\n        }\\n        traverse(root.right, k);\\n    }\\n}\\n```\\n\\n### [538. 把二叉搜索树转换为累加树 (中等)](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)\\n\\n此题与 [1038. 把二叉搜索树转换为累加树 (中等)](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/) 是一样的\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sum = 0;\\n    // 二叉搜索树按中序遍历的逆序遍历，是递减的\\n    public TreeNode convertBST(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        convertBST(root.right);\\n        sum += root.val;\\n        root.val = sum;\\n        convertBST(root.left);\\n        return root;\\n    }\\n}\\n```\",\"articleCover\":\" https://blog-htz.oss-cn-hangzhou.aliyuncs.com/articles/1621929115889.jpg\",\"articleTitle\":\"力扣刷题笔记之二叉搜索树（一）\",\"categoryId\":14,\"isDraft\":0,\"isTop\":0,\"tagIdList\":[37,39]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '183.167.246.248', '安徽省安庆市 电信', '2021-05-25 15:52:00');
INSERT INTO `tb_operation_log` VALUES (144, '文章模块', '新增或修改', '/admin/articles', 'top.bravecoder.blog.controller.ArticleController.saveArticle', '添加或修改文章', '[{\"articleContent\":\"adwaw\",\"articleCover\":\"\",\"articleTitle\":\"2022-01-30\",\"isDraft\":1,\"isTop\":0,\"tagIdList\":[]}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-01-30 11:27:10');
INSERT INTO `tb_operation_log` VALUES (145, '文章模块', '修改', '/admin/articles/top/55', 'top.bravecoder.blog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[55,0]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-01-30 11:28:45');
INSERT INTO `tb_operation_log` VALUES (146, '文章模块', '修改', '/admin/articles/top/55', 'top.bravecoder.blog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[55,1]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-01-30 11:28:45');
INSERT INTO `tb_operation_log` VALUES (147, '博客信息模块', '修改', '/admin/about', 'top.bravecoder.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[\"![app.jpg](1)\\n大四毕业生。。。\"]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-02-09 10:50:36');
INSERT INTO `tb_operation_log` VALUES (148, '博客信息模块', '修改', '/admin/about', 'top.bravecoder.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[\"大四毕业生。。。\"]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-02-09 10:51:51');
INSERT INTO `tb_operation_log` VALUES (149, '博客信息模块', '修改', '/admin/about', 'top.bravecoder.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[\"大四毕业生。。。\\n等成绩的考研人。。。\\n摆烂第一人。。。\"]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"修改成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-02-09 10:58:15');
INSERT INTO `tb_operation_log` VALUES (150, '友链模块', '新增或修改', '/admin/links', 'top.bravecoder.blog.controller.FriendLinkController.saveOrUpdateFriendLink', '保存或修改友链', '[{\"id\":12,\"linkAddress\":\"https://www.talkxj.com/\",\"linkAvatar\":\"https://static.talkxj.com/photos/b553f564f81a80dc338695acb1b475d2.jpg\",\"linkIntro\":\"成事在人 谋事在天\",\"linkName\":\"风丶宇的个人博客\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'zhang、', '127.0.0.1', '', '2022-02-09 11:18:44');

-- ----------------------------
-- Table structure for tb_resource
-- ----------------------------
DROP TABLE IF EXISTS `tb_resource`;
CREATE TABLE `tb_resource`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '资源名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '权限路径',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '请求方式',
  `parent_id` int(0) DEFAULT NULL COMMENT '父权限id',
  `create_time` datetime(0) DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) DEFAULT NULL COMMENT '修改时间',
  `is_disable` tinyint(1) DEFAULT NULL COMMENT '是否禁用 0否 1是',
  `is_anonymous` tinyint(0) DEFAULT NULL COMMENT '是否匿名访问 0否 1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 250 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_resource
-- ----------------------------
INSERT INTO `tb_resource` VALUES (165, '分类模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (166, '博客信息模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (167, '友链模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (168, '文章模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (169, '日志模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (170, '标签模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (171, '用户信息模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (172, '用户账号模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (173, '留言模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (174, '菜单模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (175, '角色模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (176, '评论模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (177, '资源模块', NULL, NULL, NULL, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (178, '查看博客信息', '/', 'GET', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (179, '查看关于我信息', '/about', 'GET', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (180, '查看后台信息', '/admin', 'GET', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (181, '修改关于我信息', '/admin/about', 'PUT', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (182, '查看后台文章', '/admin/articles', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (183, '添加或修改文章', '/admin/articles', 'POST', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (184, '恢复或删除文章', '/admin/articles', 'PUT', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (185, '物理删除文章', '/admin/articles', 'DELETE', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (186, '上传文章图片', '/admin/articles/images', 'POST', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (187, '查看文章选项', '/admin/articles/options', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (188, '修改文章置顶', '/admin/articles/top/*', 'PUT', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (189, '根据id查看后台文章', '/admin/articles/*', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (190, '查看后台分类列表', '/admin/categories', 'GET', 165, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (191, '添加或修改分类', '/admin/categories', 'POST', 165, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (192, '删除分类', '/admin/categories', 'DELETE', 165, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (193, '查询后台评论', '/admin/comments', 'GET', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (194, '删除或恢复评论', '/admin/comments', 'PUT', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (195, '物理删除评论', '/admin/comments', 'DELETE', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (196, '查看后台友链列表', '/admin/links', 'GET', 167, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (197, '保存或修改友链', '/admin/links', 'POST', 167, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (198, '删除友链', '/admin/links', 'DELETE', 167, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (199, '查看菜单列表', '/admin/menus', 'GET', 174, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (200, '查看后台留言列表', '/admin/messages', 'GET', 173, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (201, '删除留言', '/admin/messages', 'DELETE', 173, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (202, '查看公告', '/admin/notice', 'GET', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (203, '修改公告', '/admin/notice', 'PUT', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (204, '查看操作日志', '/admin/operation/logs', 'GET', 169, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (205, '删除操作日志', '/admin/operation/logs', 'DELETE', 169, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (206, '查看资源列表', '/admin/resources', 'GET', 177, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (207, '新增或修改资源', '/admin/resources', 'POST', 177, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (208, '删除资源', '/admin/resources', 'DELETE', 177, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (209, '导入swagger接口', '/admin/resources/import/swagger', 'GET', 177, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (210, '保存或更新角色', '/admin/role', 'POST', 175, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (211, '查看角色菜单选项', '/admin/role/menus', 'GET', 174, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (212, '查看角色资源选项', '/admin/role/resources', 'GET', 177, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (213, '查询角色列表', '/admin/roles', 'GET', 175, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (214, '查看后台标签列表', '/admin/tags', 'GET', 170, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (215, '添加或修改标签', '/admin/tags', 'POST', 170, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (216, '删除标签', '/admin/tags', 'DELETE', 170, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (217, '查看用户菜单', '/admin/user/menus', 'GET', 174, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (218, '查看后台用户列表', '/admin/users', 'GET', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (219, '修改用户禁用状态', '/admin/users/disable/*', 'PUT', 171, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (220, '查看在线用户', '/admin/users/online', 'GET', 171, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (221, '下线用户', '/admin/users/online/*', 'DELETE', 171, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (222, '修改管理员密码', '/admin/users/password', 'PUT', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (223, '查询用户角色选项', '/admin/users/role', 'GET', 175, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (224, '修改用户角色', '/admin/users/role', 'PUT', 171, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (225, '查看首页文章', '/articles', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (226, '查看文章归档', '/articles/archives', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (227, '点赞文章', '/articles/like', 'POST', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (228, '查看最新文章', '/articles/newest', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (229, '搜索文章', '/articles/search', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (230, '根据id查看文章', '/articles/*', 'GET', 168, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (231, '查看分类列表', '/categories', 'GET', 165, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (232, '查看分类下对应的文章', '/categories/*', 'GET', 165, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (233, '查询评论', '/comments', 'GET', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (234, '添加评论或回复', '/comments', 'POST', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (235, '评论点赞', '/comments/like', 'POST', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (236, '查询评论下的回复', '/comments/replies/*', 'GET', 176, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (237, '查看友链列表', '/links', 'GET', 167, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (238, '查看留言列表', '/messages', 'GET', 173, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (239, '添加留言', '/messages', 'POST', 173, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (240, '查看标签列表', '/tags', 'GET', 170, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (241, '查看分类下对应的文章', '/tags/*', 'GET', 170, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (242, '用户注册', '/users', 'POST', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (243, '修改用户头像', '/users/avatar', 'POST', 171, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (244, '发送邮箱验证码', '/users/code', 'GET', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (245, '修改用户资料', '/users/info', 'PUT', 171, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 0);
INSERT INTO `tb_resource` VALUES (246, 'qq登录', '/users/oauth/qq', 'POST', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (247, '微博登录', '/users/oauth/weibo', 'POST', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (248, '修改密码', '/users/password', 'PUT', 172, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);
INSERT INTO `tb_resource` VALUES (249, '上传语音', '/voice', 'POST', 166, '2021-03-20 22:56:20', '2021-03-20 22:56:20', 0, 1);

-- ----------------------------
-- Table structure for tb_role
-- ----------------------------
DROP TABLE IF EXISTS `tb_role`;
CREATE TABLE `tb_role`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '角色名',
  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '角色描述',
  `create_time` datetime(0) DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) DEFAULT NULL COMMENT '更新时间',
  `is_disable` tinyint(1) DEFAULT NULL COMMENT '是否禁用  0否 1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_role
-- ----------------------------
INSERT INTO `tb_role` VALUES (1, '管理员', 'admin', '2021-01-11 17:21:57', '2021-05-06 12:34:33', 0);
INSERT INTO `tb_role` VALUES (2, '用户', 'user', '2021-01-11 20:17:05', '2021-05-01 22:59:11', 0);
INSERT INTO `tb_role` VALUES (3, '测试', 'test', '2021-01-11 20:17:23', '2021-03-16 23:41:59', 0);

-- ----------------------------
-- Table structure for tb_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `tb_role_menu`;
CREATE TABLE `tb_role_menu`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int(0) DEFAULT NULL COMMENT '角色id',
  `menu_id` int(0) DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1307 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_role_menu
-- ----------------------------
INSERT INTO `tb_role_menu` VALUES (1181, 3, 1);
INSERT INTO `tb_role_menu` VALUES (1182, 3, 202);
INSERT INTO `tb_role_menu` VALUES (1183, 3, 13);
INSERT INTO `tb_role_menu` VALUES (1184, 3, 14);
INSERT INTO `tb_role_menu` VALUES (1185, 3, 201);
INSERT INTO `tb_role_menu` VALUES (1286, 1, 1);
INSERT INTO `tb_role_menu` VALUES (1287, 1, 2);
INSERT INTO `tb_role_menu` VALUES (1288, 1, 6);
INSERT INTO `tb_role_menu` VALUES (1289, 1, 7);
INSERT INTO `tb_role_menu` VALUES (1290, 1, 8);
INSERT INTO `tb_role_menu` VALUES (1291, 1, 9);
INSERT INTO `tb_role_menu` VALUES (1292, 1, 10);
INSERT INTO `tb_role_menu` VALUES (1293, 1, 3);
INSERT INTO `tb_role_menu` VALUES (1294, 1, 11);
INSERT INTO `tb_role_menu` VALUES (1295, 1, 12);
INSERT INTO `tb_role_menu` VALUES (1296, 1, 202);
INSERT INTO `tb_role_menu` VALUES (1297, 1, 13);
INSERT INTO `tb_role_menu` VALUES (1298, 1, 14);
INSERT INTO `tb_role_menu` VALUES (1299, 1, 201);
INSERT INTO `tb_role_menu` VALUES (1300, 1, 4);
INSERT INTO `tb_role_menu` VALUES (1301, 1, 16);
INSERT INTO `tb_role_menu` VALUES (1302, 1, 15);
INSERT INTO `tb_role_menu` VALUES (1303, 1, 17);
INSERT INTO `tb_role_menu` VALUES (1304, 1, 18);
INSERT INTO `tb_role_menu` VALUES (1305, 1, 19);
INSERT INTO `tb_role_menu` VALUES (1306, 1, 20);
INSERT INTO `tb_role_menu` VALUES (1307, 1, 5);

-- ----------------------------
-- Table structure for tb_role_resource
-- ----------------------------
DROP TABLE IF EXISTS `tb_role_resource`;
CREATE TABLE `tb_role_resource`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `role_id` int(0) DEFAULT NULL COMMENT '角色id',
  `resource_id` int(0) DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4180 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_role_resource
-- ----------------------------
INSERT INTO `tb_role_resource` VALUES (4092, 1, 165);
INSERT INTO `tb_role_resource` VALUES (4093, 1, 190);
INSERT INTO `tb_role_resource` VALUES (4094, 1, 191);
INSERT INTO `tb_role_resource` VALUES (4095, 1, 192);
INSERT INTO `tb_role_resource` VALUES (4096, 1, 231);
INSERT INTO `tb_role_resource` VALUES (4097, 1, 232);
INSERT INTO `tb_role_resource` VALUES (4098, 1, 166);
INSERT INTO `tb_role_resource` VALUES (4099, 1, 178);
INSERT INTO `tb_role_resource` VALUES (4100, 1, 179);
INSERT INTO `tb_role_resource` VALUES (4101, 1, 180);
INSERT INTO `tb_role_resource` VALUES (4102, 1, 181);
INSERT INTO `tb_role_resource` VALUES (4103, 1, 202);
INSERT INTO `tb_role_resource` VALUES (4104, 1, 203);
INSERT INTO `tb_role_resource` VALUES (4105, 1, 249);
INSERT INTO `tb_role_resource` VALUES (4106, 1, 167);
INSERT INTO `tb_role_resource` VALUES (4107, 1, 196);
INSERT INTO `tb_role_resource` VALUES (4108, 1, 197);
INSERT INTO `tb_role_resource` VALUES (4109, 1, 198);
INSERT INTO `tb_role_resource` VALUES (4110, 1, 237);
INSERT INTO `tb_role_resource` VALUES (4111, 1, 168);
INSERT INTO `tb_role_resource` VALUES (4112, 1, 182);
INSERT INTO `tb_role_resource` VALUES (4113, 1, 183);
INSERT INTO `tb_role_resource` VALUES (4114, 1, 184);
INSERT INTO `tb_role_resource` VALUES (4115, 1, 185);
INSERT INTO `tb_role_resource` VALUES (4116, 1, 186);
INSERT INTO `tb_role_resource` VALUES (4117, 1, 187);
INSERT INTO `tb_role_resource` VALUES (4118, 1, 188);
INSERT INTO `tb_role_resource` VALUES (4119, 1, 189);
INSERT INTO `tb_role_resource` VALUES (4120, 1, 225);
INSERT INTO `tb_role_resource` VALUES (4121, 1, 226);
INSERT INTO `tb_role_resource` VALUES (4122, 1, 227);
INSERT INTO `tb_role_resource` VALUES (4123, 1, 228);
INSERT INTO `tb_role_resource` VALUES (4124, 1, 229);
INSERT INTO `tb_role_resource` VALUES (4125, 1, 230);
INSERT INTO `tb_role_resource` VALUES (4126, 1, 169);
INSERT INTO `tb_role_resource` VALUES (4127, 1, 204);
INSERT INTO `tb_role_resource` VALUES (4128, 1, 205);
INSERT INTO `tb_role_resource` VALUES (4129, 1, 170);
INSERT INTO `tb_role_resource` VALUES (4130, 1, 214);
INSERT INTO `tb_role_resource` VALUES (4131, 1, 215);
INSERT INTO `tb_role_resource` VALUES (4132, 1, 216);
INSERT INTO `tb_role_resource` VALUES (4133, 1, 240);
INSERT INTO `tb_role_resource` VALUES (4134, 1, 241);
INSERT INTO `tb_role_resource` VALUES (4135, 1, 171);
INSERT INTO `tb_role_resource` VALUES (4136, 1, 219);
INSERT INTO `tb_role_resource` VALUES (4137, 1, 220);
INSERT INTO `tb_role_resource` VALUES (4138, 1, 221);
INSERT INTO `tb_role_resource` VALUES (4139, 1, 224);
INSERT INTO `tb_role_resource` VALUES (4140, 1, 243);
INSERT INTO `tb_role_resource` VALUES (4141, 1, 245);
INSERT INTO `tb_role_resource` VALUES (4142, 1, 172);
INSERT INTO `tb_role_resource` VALUES (4143, 1, 218);
INSERT INTO `tb_role_resource` VALUES (4144, 1, 222);
INSERT INTO `tb_role_resource` VALUES (4145, 1, 242);
INSERT INTO `tb_role_resource` VALUES (4146, 1, 244);
INSERT INTO `tb_role_resource` VALUES (4147, 1, 246);
INSERT INTO `tb_role_resource` VALUES (4148, 1, 247);
INSERT INTO `tb_role_resource` VALUES (4149, 1, 248);
INSERT INTO `tb_role_resource` VALUES (4150, 1, 173);
INSERT INTO `tb_role_resource` VALUES (4151, 1, 200);
INSERT INTO `tb_role_resource` VALUES (4152, 1, 201);
INSERT INTO `tb_role_resource` VALUES (4153, 1, 238);
INSERT INTO `tb_role_resource` VALUES (4154, 1, 239);
INSERT INTO `tb_role_resource` VALUES (4155, 1, 174);
INSERT INTO `tb_role_resource` VALUES (4156, 1, 199);
INSERT INTO `tb_role_resource` VALUES (4157, 1, 211);
INSERT INTO `tb_role_resource` VALUES (4158, 1, 217);
INSERT INTO `tb_role_resource` VALUES (4159, 1, 175);
INSERT INTO `tb_role_resource` VALUES (4160, 1, 210);
INSERT INTO `tb_role_resource` VALUES (4161, 1, 213);
INSERT INTO `tb_role_resource` VALUES (4162, 1, 223);
INSERT INTO `tb_role_resource` VALUES (4163, 1, 176);
INSERT INTO `tb_role_resource` VALUES (4164, 1, 193);
INSERT INTO `tb_role_resource` VALUES (4165, 1, 194);
INSERT INTO `tb_role_resource` VALUES (4166, 1, 195);
INSERT INTO `tb_role_resource` VALUES (4167, 1, 233);
INSERT INTO `tb_role_resource` VALUES (4168, 1, 234);
INSERT INTO `tb_role_resource` VALUES (4169, 1, 235);
INSERT INTO `tb_role_resource` VALUES (4170, 1, 236);
INSERT INTO `tb_role_resource` VALUES (4171, 1, 177);
INSERT INTO `tb_role_resource` VALUES (4172, 1, 206);
INSERT INTO `tb_role_resource` VALUES (4173, 1, 207);
INSERT INTO `tb_role_resource` VALUES (4174, 1, 208);
INSERT INTO `tb_role_resource` VALUES (4175, 1, 209);
INSERT INTO `tb_role_resource` VALUES (4176, 1, 212);
INSERT INTO `tb_role_resource` VALUES (4177, 2, 227);
INSERT INTO `tb_role_resource` VALUES (4178, 2, 239);
INSERT INTO `tb_role_resource` VALUES (4179, 2, 234);
INSERT INTO `tb_role_resource` VALUES (4180, 2, 235);

-- ----------------------------
-- Table structure for tb_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_tag`;
CREATE TABLE `tb_tag`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标签名',
  `create_time` datetime(0) DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 40 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_tag
-- ----------------------------
INSERT INTO `tb_tag` VALUES (19, '博客', '2021-05-03 16:37:57');
INSERT INTO `tb_tag` VALUES (20, 'SpringSecurity', '2021-05-05 19:46:21');
INSERT INTO `tb_tag` VALUES (21, 'redis', '2021-05-05 19:53:34');
INSERT INTO `tb_tag` VALUES (22, '贪心', '2021-05-08 14:57:59');
INSERT INTO `tb_tag` VALUES (23, '动态规划', '2021-05-08 14:58:05');
INSERT INTO `tb_tag` VALUES (24, '二分', '2021-05-08 14:58:13');
INSERT INTO `tb_tag` VALUES (25, '排序', '2021-05-08 14:58:20');
INSERT INTO `tb_tag` VALUES (26, '程序设计竞赛', '2021-05-08 15:44:34');
INSERT INTO `tb_tag` VALUES (27, '顺序表', '2021-05-10 22:28:46');
INSERT INTO `tb_tag` VALUES (28, '链表', '2021-05-10 22:28:52');
INSERT INTO `tb_tag` VALUES (29, '顺序栈', '2021-05-10 22:28:57');
INSERT INTO `tb_tag` VALUES (30, '栈', '2021-05-11 23:04:23');
INSERT INTO `tb_tag` VALUES (31, '链栈', '2021-05-11 23:04:28');
INSERT INTO `tb_tag` VALUES (32, '线段树', '2021-05-16 16:44:14');
INSERT INTO `tb_tag` VALUES (33, '博弈', '2021-05-20 22:05:12');
INSERT INTO `tb_tag` VALUES (34, '循环队列', '2021-05-20 22:37:35');
INSERT INTO `tb_tag` VALUES (35, '队列', '2021-05-20 22:37:42');
INSERT INTO `tb_tag` VALUES (36, '链队', '2021-05-20 22:38:03');
INSERT INTO `tb_tag` VALUES (37, '二叉树', '2021-05-20 22:49:07');
INSERT INTO `tb_tag` VALUES (38, '分数规划', '2021-05-21 22:07:57');
INSERT INTO `tb_tag` VALUES (39, '二叉搜索树', '2021-05-25 15:50:20');

-- ----------------------------
-- Table structure for tb_unique_view
-- ----------------------------
DROP TABLE IF EXISTS `tb_unique_view`;
CREATE TABLE `tb_unique_view`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `create_time` datetime(0) NOT NULL COMMENT '时间',
  `views_count` int(0) NOT NULL COMMENT '访问量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 247 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_unique_view
-- ----------------------------
INSERT INTO `tb_unique_view` VALUES (223, '2021-05-01 08:00:00', 20);
INSERT INTO `tb_unique_view` VALUES (224, '2021-05-02 08:00:00', 30);
INSERT INTO `tb_unique_view` VALUES (225, '2021-05-03 08:00:00', 37);
INSERT INTO `tb_unique_view` VALUES (226, '2021-05-05 08:00:00', 33);
INSERT INTO `tb_unique_view` VALUES (227, '2021-05-06 08:00:00', 38);
INSERT INTO `tb_unique_view` VALUES (228, '2021-05-07 08:00:00', 39);
INSERT INTO `tb_unique_view` VALUES (229, '2021-05-08 08:00:00', 27);
INSERT INTO `tb_unique_view` VALUES (230, '2021-05-09 08:00:00', 31);
INSERT INTO `tb_unique_view` VALUES (231, '2021-05-10 08:00:00', 38);
INSERT INTO `tb_unique_view` VALUES (232, '2021-05-11 08:00:00', 25);
INSERT INTO `tb_unique_view` VALUES (233, '2021-05-12 08:00:00', 28);
INSERT INTO `tb_unique_view` VALUES (234, '2021-05-13 08:00:00', 24);
INSERT INTO `tb_unique_view` VALUES (235, '2021-05-14 08:00:00', 24);
INSERT INTO `tb_unique_view` VALUES (236, '2021-05-15 08:00:00', 27);
INSERT INTO `tb_unique_view` VALUES (237, '2021-05-16 08:00:00', 37);
INSERT INTO `tb_unique_view` VALUES (238, '2021-05-17 08:00:00', 31);
INSERT INTO `tb_unique_view` VALUES (239, '2021-05-18 08:00:00', 45);
INSERT INTO `tb_unique_view` VALUES (240, '2021-05-19 08:00:00', 45);
INSERT INTO `tb_unique_view` VALUES (241, '2022-02-01 08:00:00', 72);
INSERT INTO `tb_unique_view` VALUES (242, '2022-02-02 08:00:00', 75);
INSERT INTO `tb_unique_view` VALUES (243, '2022-02-03 08:00:00', 49);
INSERT INTO `tb_unique_view` VALUES (244, '2021-05-04 08:00:00', 38);
INSERT INTO `tb_unique_view` VALUES (245, '2022-02-05 08:00:00', 41);
INSERT INTO `tb_unique_view` VALUES (246, '2022-02-06 20:46:59', 3);
INSERT INTO `tb_unique_view` VALUES (247, '2022-02-07 12:23:22', 2);

-- ----------------------------
-- Table structure for tb_user_auth
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_auth`;
CREATE TABLE `tb_user_auth`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_info_id` int(0) NOT NULL COMMENT '用户信息id',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `login_type` tinyint(1) NOT NULL COMMENT '登录类型',
  `ip_addr` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户登录ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime(0) NOT NULL COMMENT '创建时间',
  `last_login_time` datetime(0) DEFAULT NULL COMMENT '上次登录时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 208 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_user_auth
-- ----------------------------
INSERT INTO `tb_user_auth` VALUES (1, 1, 'zhangzhi@admin.com', '$2a$10$jeq9CzD64KKfNDuofHmSy.fezPunMnvSwywvmgzqjgRJKNrBZEo6.', 0, '127.0.0.1', '', '2020-06-29 10:48:18', '2022-02-09 17:58:31');
INSERT INTO `tb_user_auth` VALUES (202, 213, 'zhangzhihtz@gmail.com', '$2a$10$5nSdhbXsJyaiM6tyHAWKyeOZKpGrFq9pzJ0pX4u/s0G6g5NYiHdca', 0, '58.243.254.57', '安徽省合肥市 联通', '2021-05-09 10:25:57', '2021-05-09 10:25:57');
INSERT INTO `tb_user_auth` VALUES (203, 214, '2204E789D9907F747C06BEF73E5CC9B2', '5741E54444B32AAD3F11736EE2555812', 1, '183.167.246.248', '安徽省安庆市 电信', '2021-05-09 13:00:02', '2021-05-21 11:07:49');
INSERT INTO `tb_user_auth` VALUES (205, 216, 'C92A1C2491DF40FC8BD56D5DC4EFB860', '82B8FCEBBC1FC25DB0B7BEEDE5C22CAE', 1, '223.104.37.121', '安徽省 移动', '2021-05-21 10:03:18', '2021-05-21 10:06:30');
INSERT INTO `tb_user_auth` VALUES (207, 218, '4A33706D42AD8F90683DC970060BF396', '364572A50E7EBF1C8646E0199B1563CF', 1, '202.104.31.105', '广东省佛山市顺德区 电信', '2021-05-21 10:33:24', '2021-05-21 10:33:24');

-- ----------------------------
-- Table structure for tb_user_info
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_info`;
CREATE TABLE `tb_user_info`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '邮箱号',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户昵称',
  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '用户头像',
  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户简介',
  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '个人网站',
  `create_time` datetime(0) NOT NULL COMMENT '创建时间',
  `update_time` datetime(0) DEFAULT NULL COMMENT '更新时间',
  `is_disable` tinyint(1) DEFAULT 0 COMMENT '是否禁用',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 219 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_user_info
-- ----------------------------
INSERT INTO `tb_user_info` VALUES (1, '1693740714@qq.com', 'zhang、', 'https://blog-htz.oss-cn-hangzhou.aliyuncs.com/avatar/20210426211343.jpg', '与自己促膝长谈，与孤独握手言欢', 'https://bravecoder.top', '2020-06-29 10:48:18', '2021-05-25 15:55:09', 0);
INSERT INTO `tb_user_info` VALUES (213, 'zhangzhihtz@gmail.com', '用户1389908724813926402', 'https://blog-htz.oss-cn-hangzhou.aliyuncs.com/avatar/user.png', NULL, NULL, '2021-05-09 10:25:57', NULL, 0);
INSERT INTO `tb_user_info` VALUES (214, NULL, '谁亦能呵一呵', 'http://thirdqq.qlogo.cn/g?b=oidb&k=aI2eHkWDtVbicAj3GnDvgAg&s=40&t=1586074784', NULL, NULL, '2021-05-09 13:00:01', NULL, 0);
INSERT INTO `tb_user_info` VALUES (216, NULL, 'Ashes of Time', 'http://thirdqq.qlogo.cn/g?b=oidb&k=lo7zGXnDnxOLAuoKciaLLbg&s=40&t=1609426162', NULL, NULL, '2021-05-21 10:03:18', NULL, 0);
INSERT INTO `tb_user_info` VALUES (218, NULL, '.', 'http://thirdqq.qlogo.cn/g?b=oidb&k=JuNtQDYCaT46hAia0hickkAg&s=40&t=1621530827', NULL, NULL, '2021-05-21 10:33:24', NULL, 0);

-- ----------------------------
-- Table structure for tb_user_role
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_role`;
CREATE TABLE `tb_user_role`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_id` int(0) DEFAULT NULL COMMENT '用户id',
  `role_id` int(0) DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 226 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tb_user_role
-- ----------------------------
INSERT INTO `tb_user_role` VALUES (217, 1, 1);
INSERT INTO `tb_user_role` VALUES (218, 1, 2);
INSERT INTO `tb_user_role` VALUES (221, 2, 2);
INSERT INTO `tb_user_role` VALUES (222, 212, 2);
INSERT INTO `tb_user_role` VALUES (223, 213, 2);
INSERT INTO `tb_user_role` VALUES (224, 214, 2);
INSERT INTO `tb_user_role` VALUES (225, 216, 2);
INSERT INTO `tb_user_role` VALUES (226, 218, 2);

SET FOREIGN_KEY_CHECKS = 1;
